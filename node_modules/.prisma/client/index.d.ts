
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export interface PrismaPromise<A> extends Promise<A> {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model MasterCountry
 * 
 */
export type MasterCountry = {
  id: number
  codeCountry: string
  countryName: string
  typeCountry: string
  isActive: number
}

/**
 * Model MasterDosage
 * 
 */
export type MasterDosage = {
  id: number
  nameDossage: string
  isActive: number
}

/**
 * Model MasterSpeciality
 * 
 */
export type MasterSpeciality = {
  id: number
  nameSpeciality: string
  isActive: number
}

/**
 * Model MasterUmbrellaBrand
 * 
 */
export type MasterUmbrellaBrand = {
  id: number
  nameUmbrellaBrand: string
  isActive: number
  masterSpecialityId: number | null
}

/**
 * Model MasterBrand
 * 
 */
export type MasterBrand = {
  id: number
  umbrellaBrandId: number
  nameBrand: string
  isActive: number
}

/**
 * Model MasterComposition
 * 
 */
export type MasterComposition = {
  id: number
  brandId: number
  nameComposition: string
  sku: string
  isActive: number
}

/**
 * Model MasterDistributionPartner
 * 
 */
export type MasterDistributionPartner = {
  id: number
  nameDist: string
  isActive: number
}

/**
 * Model MarketSurveyRequest
 * 
 */
export type MarketSurveyRequest = {
  id: string
  numberDocument: string
  type: string
  idBrand: number
  country: string
  brand: string
  dosageForm: string
  date: Date
  originatorBrand: string
  originatorCompany: string
  statusForm: string
  approvedIdUser: string
  createdAt: Date
  updatedAt: Date
  updatedBy: string | null
  createdBy: string | null
}

/**
 * Model MarketSurvey
 * 
 */
export type MarketSurvey = {
  id: string
  numberDocument: string
  pic: string
  date: Date
  priceSurveyed: string
  statusForm: string
  approvedIdUser: string
  createdAt: Date
  updatedAt: Date
  updatedBy: string | null
  createdBy: string | null
}

/**
 * Model MarketSurveyDetail
 * 
 */
export type MarketSurveyDetail = {
  id: string
  brand: string
  unit: number
  uomId: string
  manufacturer: string
  countryOrigin: string
  priceLocal: number
  priceUSD: number
  sales: string
  marketSurveyId: string | null
}

/**
 * Model MarketSurveyDetailComp
 * 
 */
export type MarketSurveyDetailComp = {
  id: string
  composition: string
  marketSurveyDetailId: string | null
}

/**
 * Model MasterRole
 * 
 */
export type MasterRole = {
  id: number
  roleName: string
  createdAt: Date
  updatedAt: Date
  updatedBy: string | null
  createdBy: string | null
}

/**
 * Model MasterRoleUser
 * 
 */
export type MasterRoleUser = {
  id: number
  userId: string
  nameRoleUser: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more MasterCountries
 * const masterCountries = await prisma.masterCountry.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more MasterCountries
   * const masterCountries = await prisma.masterCountry.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.masterCountry`: Exposes CRUD operations for the **MasterCountry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterCountries
    * const masterCountries = await prisma.masterCountry.findMany()
    * ```
    */
  get masterCountry(): Prisma.MasterCountryDelegate<GlobalReject>;

  /**
   * `prisma.masterDosage`: Exposes CRUD operations for the **MasterDosage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterDosages
    * const masterDosages = await prisma.masterDosage.findMany()
    * ```
    */
  get masterDosage(): Prisma.MasterDosageDelegate<GlobalReject>;

  /**
   * `prisma.masterSpeciality`: Exposes CRUD operations for the **MasterSpeciality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterSpecialities
    * const masterSpecialities = await prisma.masterSpeciality.findMany()
    * ```
    */
  get masterSpeciality(): Prisma.MasterSpecialityDelegate<GlobalReject>;

  /**
   * `prisma.masterUmbrellaBrand`: Exposes CRUD operations for the **MasterUmbrellaBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterUmbrellaBrands
    * const masterUmbrellaBrands = await prisma.masterUmbrellaBrand.findMany()
    * ```
    */
  get masterUmbrellaBrand(): Prisma.MasterUmbrellaBrandDelegate<GlobalReject>;

  /**
   * `prisma.masterBrand`: Exposes CRUD operations for the **MasterBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterBrands
    * const masterBrands = await prisma.masterBrand.findMany()
    * ```
    */
  get masterBrand(): Prisma.MasterBrandDelegate<GlobalReject>;

  /**
   * `prisma.masterComposition`: Exposes CRUD operations for the **MasterComposition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterCompositions
    * const masterCompositions = await prisma.masterComposition.findMany()
    * ```
    */
  get masterComposition(): Prisma.MasterCompositionDelegate<GlobalReject>;

  /**
   * `prisma.masterDistributionPartner`: Exposes CRUD operations for the **MasterDistributionPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterDistributionPartners
    * const masterDistributionPartners = await prisma.masterDistributionPartner.findMany()
    * ```
    */
  get masterDistributionPartner(): Prisma.MasterDistributionPartnerDelegate<GlobalReject>;

  /**
   * `prisma.marketSurveyRequest`: Exposes CRUD operations for the **MarketSurveyRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketSurveyRequests
    * const marketSurveyRequests = await prisma.marketSurveyRequest.findMany()
    * ```
    */
  get marketSurveyRequest(): Prisma.MarketSurveyRequestDelegate<GlobalReject>;

  /**
   * `prisma.marketSurvey`: Exposes CRUD operations for the **MarketSurvey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketSurveys
    * const marketSurveys = await prisma.marketSurvey.findMany()
    * ```
    */
  get marketSurvey(): Prisma.MarketSurveyDelegate<GlobalReject>;

  /**
   * `prisma.marketSurveyDetail`: Exposes CRUD operations for the **MarketSurveyDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketSurveyDetails
    * const marketSurveyDetails = await prisma.marketSurveyDetail.findMany()
    * ```
    */
  get marketSurveyDetail(): Prisma.MarketSurveyDetailDelegate<GlobalReject>;

  /**
   * `prisma.marketSurveyDetailComp`: Exposes CRUD operations for the **MarketSurveyDetailComp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketSurveyDetailComps
    * const marketSurveyDetailComps = await prisma.marketSurveyDetailComp.findMany()
    * ```
    */
  get marketSurveyDetailComp(): Prisma.MarketSurveyDetailCompDelegate<GlobalReject>;

  /**
   * `prisma.masterRole`: Exposes CRUD operations for the **MasterRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterRoles
    * const masterRoles = await prisma.masterRole.findMany()
    * ```
    */
  get masterRole(): Prisma.MasterRoleDelegate<GlobalReject>;

  /**
   * `prisma.masterRoleUser`: Exposes CRUD operations for the **MasterRoleUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterRoleUsers
    * const masterRoleUsers = await prisma.masterRoleUser.findMany()
    * ```
    */
  get masterRoleUser(): Prisma.MasterRoleUserDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.9.0
   * Query Engine version: ceb5c99003b99c9ee2c1d2e618e359c14aef2ea5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    MasterCountry: 'MasterCountry',
    MasterDosage: 'MasterDosage',
    MasterSpeciality: 'MasterSpeciality',
    MasterUmbrellaBrand: 'MasterUmbrellaBrand',
    MasterBrand: 'MasterBrand',
    MasterComposition: 'MasterComposition',
    MasterDistributionPartner: 'MasterDistributionPartner',
    MarketSurveyRequest: 'MarketSurveyRequest',
    MarketSurvey: 'MarketSurvey',
    MarketSurveyDetail: 'MarketSurveyDetail',
    MarketSurveyDetailComp: 'MarketSurveyDetailComp',
    MasterRole: 'MasterRole',
    MasterRoleUser: 'MasterRoleUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MasterSpecialityCountOutputType
   */


  export type MasterSpecialityCountOutputType = {
    umbrellaBrand: number
  }

  export type MasterSpecialityCountOutputTypeSelect = {
    umbrellaBrand?: boolean
  }

  export type MasterSpecialityCountOutputTypeGetPayload<S extends boolean | null | undefined | MasterSpecialityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterSpecialityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MasterSpecialityCountOutputTypeArgs)
    ? MasterSpecialityCountOutputType 
    : S extends { select: any } & (MasterSpecialityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MasterSpecialityCountOutputType ? MasterSpecialityCountOutputType[P] : never
  } 
      : MasterSpecialityCountOutputType




  // Custom InputTypes

  /**
   * MasterSpecialityCountOutputType without action
   */
  export type MasterSpecialityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MasterSpecialityCountOutputType
     */
    select?: MasterSpecialityCountOutputTypeSelect | null
  }



  /**
   * Count Type MasterUmbrellaBrandCountOutputType
   */


  export type MasterUmbrellaBrandCountOutputType = {
    masterBrand: number
  }

  export type MasterUmbrellaBrandCountOutputTypeSelect = {
    masterBrand?: boolean
  }

  export type MasterUmbrellaBrandCountOutputTypeGetPayload<S extends boolean | null | undefined | MasterUmbrellaBrandCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterUmbrellaBrandCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MasterUmbrellaBrandCountOutputTypeArgs)
    ? MasterUmbrellaBrandCountOutputType 
    : S extends { select: any } & (MasterUmbrellaBrandCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MasterUmbrellaBrandCountOutputType ? MasterUmbrellaBrandCountOutputType[P] : never
  } 
      : MasterUmbrellaBrandCountOutputType




  // Custom InputTypes

  /**
   * MasterUmbrellaBrandCountOutputType without action
   */
  export type MasterUmbrellaBrandCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrandCountOutputType
     */
    select?: MasterUmbrellaBrandCountOutputTypeSelect | null
  }



  /**
   * Count Type MasterBrandCountOutputType
   */


  export type MasterBrandCountOutputType = {
    MasterComposition: number
  }

  export type MasterBrandCountOutputTypeSelect = {
    MasterComposition?: boolean
  }

  export type MasterBrandCountOutputTypeGetPayload<S extends boolean | null | undefined | MasterBrandCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterBrandCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MasterBrandCountOutputTypeArgs)
    ? MasterBrandCountOutputType 
    : S extends { select: any } & (MasterBrandCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MasterBrandCountOutputType ? MasterBrandCountOutputType[P] : never
  } 
      : MasterBrandCountOutputType




  // Custom InputTypes

  /**
   * MasterBrandCountOutputType without action
   */
  export type MasterBrandCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MasterBrandCountOutputType
     */
    select?: MasterBrandCountOutputTypeSelect | null
  }



  /**
   * Count Type MarketSurveyCountOutputType
   */


  export type MarketSurveyCountOutputType = {
    marketSurveyDetail: number
  }

  export type MarketSurveyCountOutputTypeSelect = {
    marketSurveyDetail?: boolean
  }

  export type MarketSurveyCountOutputTypeGetPayload<S extends boolean | null | undefined | MarketSurveyCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MarketSurveyCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MarketSurveyCountOutputTypeArgs)
    ? MarketSurveyCountOutputType 
    : S extends { select: any } & (MarketSurveyCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MarketSurveyCountOutputType ? MarketSurveyCountOutputType[P] : never
  } 
      : MarketSurveyCountOutputType




  // Custom InputTypes

  /**
   * MarketSurveyCountOutputType without action
   */
  export type MarketSurveyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyCountOutputType
     */
    select?: MarketSurveyCountOutputTypeSelect | null
  }



  /**
   * Count Type MarketSurveyDetailCountOutputType
   */


  export type MarketSurveyDetailCountOutputType = {
    marketSurveyDetailComp: number
  }

  export type MarketSurveyDetailCountOutputTypeSelect = {
    marketSurveyDetailComp?: boolean
  }

  export type MarketSurveyDetailCountOutputTypeGetPayload<S extends boolean | null | undefined | MarketSurveyDetailCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MarketSurveyDetailCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MarketSurveyDetailCountOutputTypeArgs)
    ? MarketSurveyDetailCountOutputType 
    : S extends { select: any } & (MarketSurveyDetailCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MarketSurveyDetailCountOutputType ? MarketSurveyDetailCountOutputType[P] : never
  } 
      : MarketSurveyDetailCountOutputType




  // Custom InputTypes

  /**
   * MarketSurveyDetailCountOutputType without action
   */
  export type MarketSurveyDetailCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailCountOutputType
     */
    select?: MarketSurveyDetailCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model MasterCountry
   */


  export type AggregateMasterCountry = {
    _count: MasterCountryCountAggregateOutputType | null
    _avg: MasterCountryAvgAggregateOutputType | null
    _sum: MasterCountrySumAggregateOutputType | null
    _min: MasterCountryMinAggregateOutputType | null
    _max: MasterCountryMaxAggregateOutputType | null
  }

  export type MasterCountryAvgAggregateOutputType = {
    id: number | null
    isActive: number | null
  }

  export type MasterCountrySumAggregateOutputType = {
    id: number | null
    isActive: number | null
  }

  export type MasterCountryMinAggregateOutputType = {
    id: number | null
    codeCountry: string | null
    countryName: string | null
    typeCountry: string | null
    isActive: number | null
  }

  export type MasterCountryMaxAggregateOutputType = {
    id: number | null
    codeCountry: string | null
    countryName: string | null
    typeCountry: string | null
    isActive: number | null
  }

  export type MasterCountryCountAggregateOutputType = {
    id: number
    codeCountry: number
    countryName: number
    typeCountry: number
    isActive: number
    _all: number
  }


  export type MasterCountryAvgAggregateInputType = {
    id?: true
    isActive?: true
  }

  export type MasterCountrySumAggregateInputType = {
    id?: true
    isActive?: true
  }

  export type MasterCountryMinAggregateInputType = {
    id?: true
    codeCountry?: true
    countryName?: true
    typeCountry?: true
    isActive?: true
  }

  export type MasterCountryMaxAggregateInputType = {
    id?: true
    codeCountry?: true
    countryName?: true
    typeCountry?: true
    isActive?: true
  }

  export type MasterCountryCountAggregateInputType = {
    id?: true
    codeCountry?: true
    countryName?: true
    typeCountry?: true
    isActive?: true
    _all?: true
  }

  export type MasterCountryAggregateArgs = {
    /**
     * Filter which MasterCountry to aggregate.
     */
    where?: MasterCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterCountries to fetch.
     */
    orderBy?: Enumerable<MasterCountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterCountries
    **/
    _count?: true | MasterCountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterCountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterCountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterCountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterCountryMaxAggregateInputType
  }

  export type GetMasterCountryAggregateType<T extends MasterCountryAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterCountry[P]>
      : GetScalarType<T[P], AggregateMasterCountry[P]>
  }




  export type MasterCountryGroupByArgs = {
    where?: MasterCountryWhereInput
    orderBy?: Enumerable<MasterCountryOrderByWithAggregationInput>
    by: MasterCountryScalarFieldEnum[]
    having?: MasterCountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterCountryCountAggregateInputType | true
    _avg?: MasterCountryAvgAggregateInputType
    _sum?: MasterCountrySumAggregateInputType
    _min?: MasterCountryMinAggregateInputType
    _max?: MasterCountryMaxAggregateInputType
  }


  export type MasterCountryGroupByOutputType = {
    id: number
    codeCountry: string
    countryName: string
    typeCountry: string
    isActive: number
    _count: MasterCountryCountAggregateOutputType | null
    _avg: MasterCountryAvgAggregateOutputType | null
    _sum: MasterCountrySumAggregateOutputType | null
    _min: MasterCountryMinAggregateOutputType | null
    _max: MasterCountryMaxAggregateOutputType | null
  }

  type GetMasterCountryGroupByPayload<T extends MasterCountryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterCountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterCountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterCountryGroupByOutputType[P]>
            : GetScalarType<T[P], MasterCountryGroupByOutputType[P]>
        }
      >
    >


  export type MasterCountrySelect = {
    id?: boolean
    codeCountry?: boolean
    countryName?: boolean
    typeCountry?: boolean
    isActive?: boolean
  }


  export type MasterCountryGetPayload<S extends boolean | null | undefined | MasterCountryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterCountry :
    S extends undefined ? never :
    S extends { include: any } & (MasterCountryArgs | MasterCountryFindManyArgs)
    ? MasterCountry 
    : S extends { select: any } & (MasterCountryArgs | MasterCountryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MasterCountry ? MasterCountry[P] : never
  } 
      : MasterCountry


  type MasterCountryCountArgs = 
    Omit<MasterCountryFindManyArgs, 'select' | 'include'> & {
      select?: MasterCountryCountAggregateInputType | true
    }

  export interface MasterCountryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterCountry that matches the filter.
     * @param {MasterCountryFindUniqueArgs} args - Arguments to find a MasterCountry
     * @example
     * // Get one MasterCountry
     * const masterCountry = await prisma.masterCountry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterCountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterCountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterCountry'> extends True ? Prisma__MasterCountryClient<MasterCountryGetPayload<T>> : Prisma__MasterCountryClient<MasterCountryGetPayload<T> | null, null>

    /**
     * Find one MasterCountry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterCountryFindUniqueOrThrowArgs} args - Arguments to find a MasterCountry
     * @example
     * // Get one MasterCountry
     * const masterCountry = await prisma.masterCountry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterCountryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterCountryFindUniqueOrThrowArgs>
    ): Prisma__MasterCountryClient<MasterCountryGetPayload<T>>

    /**
     * Find the first MasterCountry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCountryFindFirstArgs} args - Arguments to find a MasterCountry
     * @example
     * // Get one MasterCountry
     * const masterCountry = await prisma.masterCountry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterCountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterCountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterCountry'> extends True ? Prisma__MasterCountryClient<MasterCountryGetPayload<T>> : Prisma__MasterCountryClient<MasterCountryGetPayload<T> | null, null>

    /**
     * Find the first MasterCountry that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCountryFindFirstOrThrowArgs} args - Arguments to find a MasterCountry
     * @example
     * // Get one MasterCountry
     * const masterCountry = await prisma.masterCountry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterCountryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterCountryFindFirstOrThrowArgs>
    ): Prisma__MasterCountryClient<MasterCountryGetPayload<T>>

    /**
     * Find zero or more MasterCountries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterCountries
     * const masterCountries = await prisma.masterCountry.findMany()
     * 
     * // Get first 10 MasterCountries
     * const masterCountries = await prisma.masterCountry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterCountryWithIdOnly = await prisma.masterCountry.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterCountryFindManyArgs>(
      args?: SelectSubset<T, MasterCountryFindManyArgs>
    ): PrismaPromise<Array<MasterCountryGetPayload<T>>>

    /**
     * Create a MasterCountry.
     * @param {MasterCountryCreateArgs} args - Arguments to create a MasterCountry.
     * @example
     * // Create one MasterCountry
     * const MasterCountry = await prisma.masterCountry.create({
     *   data: {
     *     // ... data to create a MasterCountry
     *   }
     * })
     * 
    **/
    create<T extends MasterCountryCreateArgs>(
      args: SelectSubset<T, MasterCountryCreateArgs>
    ): Prisma__MasterCountryClient<MasterCountryGetPayload<T>>

    /**
     * Create many MasterCountries.
     *     @param {MasterCountryCreateManyArgs} args - Arguments to create many MasterCountries.
     *     @example
     *     // Create many MasterCountries
     *     const masterCountry = await prisma.masterCountry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterCountryCreateManyArgs>(
      args?: SelectSubset<T, MasterCountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterCountry.
     * @param {MasterCountryDeleteArgs} args - Arguments to delete one MasterCountry.
     * @example
     * // Delete one MasterCountry
     * const MasterCountry = await prisma.masterCountry.delete({
     *   where: {
     *     // ... filter to delete one MasterCountry
     *   }
     * })
     * 
    **/
    delete<T extends MasterCountryDeleteArgs>(
      args: SelectSubset<T, MasterCountryDeleteArgs>
    ): Prisma__MasterCountryClient<MasterCountryGetPayload<T>>

    /**
     * Update one MasterCountry.
     * @param {MasterCountryUpdateArgs} args - Arguments to update one MasterCountry.
     * @example
     * // Update one MasterCountry
     * const masterCountry = await prisma.masterCountry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterCountryUpdateArgs>(
      args: SelectSubset<T, MasterCountryUpdateArgs>
    ): Prisma__MasterCountryClient<MasterCountryGetPayload<T>>

    /**
     * Delete zero or more MasterCountries.
     * @param {MasterCountryDeleteManyArgs} args - Arguments to filter MasterCountries to delete.
     * @example
     * // Delete a few MasterCountries
     * const { count } = await prisma.masterCountry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterCountryDeleteManyArgs>(
      args?: SelectSubset<T, MasterCountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterCountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterCountries
     * const masterCountry = await prisma.masterCountry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterCountryUpdateManyArgs>(
      args: SelectSubset<T, MasterCountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterCountry.
     * @param {MasterCountryUpsertArgs} args - Arguments to update or create a MasterCountry.
     * @example
     * // Update or create a MasterCountry
     * const masterCountry = await prisma.masterCountry.upsert({
     *   create: {
     *     // ... data to create a MasterCountry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterCountry we want to update
     *   }
     * })
    **/
    upsert<T extends MasterCountryUpsertArgs>(
      args: SelectSubset<T, MasterCountryUpsertArgs>
    ): Prisma__MasterCountryClient<MasterCountryGetPayload<T>>

    /**
     * Count the number of MasterCountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCountryCountArgs} args - Arguments to filter MasterCountries to count.
     * @example
     * // Count the number of MasterCountries
     * const count = await prisma.masterCountry.count({
     *   where: {
     *     // ... the filter for the MasterCountries we want to count
     *   }
     * })
    **/
    count<T extends MasterCountryCountArgs>(
      args?: Subset<T, MasterCountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterCountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterCountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterCountryAggregateArgs>(args: Subset<T, MasterCountryAggregateArgs>): PrismaPromise<GetMasterCountryAggregateType<T>>

    /**
     * Group by MasterCountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterCountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterCountryGroupByArgs['orderBy'] }
        : { orderBy?: MasterCountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterCountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterCountryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterCountry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterCountryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterCountry base type for findUnique actions
   */
  export type MasterCountryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * Filter, which MasterCountry to fetch.
     */
    where: MasterCountryWhereUniqueInput
  }

  /**
   * MasterCountry findUnique
   */
  export interface MasterCountryFindUniqueArgs extends MasterCountryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterCountry findUniqueOrThrow
   */
  export type MasterCountryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * Filter, which MasterCountry to fetch.
     */
    where: MasterCountryWhereUniqueInput
  }


  /**
   * MasterCountry base type for findFirst actions
   */
  export type MasterCountryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * Filter, which MasterCountry to fetch.
     */
    where?: MasterCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterCountries to fetch.
     */
    orderBy?: Enumerable<MasterCountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterCountries.
     */
    cursor?: MasterCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterCountries.
     */
    distinct?: Enumerable<MasterCountryScalarFieldEnum>
  }

  /**
   * MasterCountry findFirst
   */
  export interface MasterCountryFindFirstArgs extends MasterCountryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterCountry findFirstOrThrow
   */
  export type MasterCountryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * Filter, which MasterCountry to fetch.
     */
    where?: MasterCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterCountries to fetch.
     */
    orderBy?: Enumerable<MasterCountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterCountries.
     */
    cursor?: MasterCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterCountries.
     */
    distinct?: Enumerable<MasterCountryScalarFieldEnum>
  }


  /**
   * MasterCountry findMany
   */
  export type MasterCountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * Filter, which MasterCountries to fetch.
     */
    where?: MasterCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterCountries to fetch.
     */
    orderBy?: Enumerable<MasterCountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterCountries.
     */
    cursor?: MasterCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterCountries.
     */
    skip?: number
    distinct?: Enumerable<MasterCountryScalarFieldEnum>
  }


  /**
   * MasterCountry create
   */
  export type MasterCountryCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * The data needed to create a MasterCountry.
     */
    data: XOR<MasterCountryCreateInput, MasterCountryUncheckedCreateInput>
  }


  /**
   * MasterCountry createMany
   */
  export type MasterCountryCreateManyArgs = {
    /**
     * The data used to create many MasterCountries.
     */
    data: Enumerable<MasterCountryCreateManyInput>
  }


  /**
   * MasterCountry update
   */
  export type MasterCountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * The data needed to update a MasterCountry.
     */
    data: XOR<MasterCountryUpdateInput, MasterCountryUncheckedUpdateInput>
    /**
     * Choose, which MasterCountry to update.
     */
    where: MasterCountryWhereUniqueInput
  }


  /**
   * MasterCountry updateMany
   */
  export type MasterCountryUpdateManyArgs = {
    /**
     * The data used to update MasterCountries.
     */
    data: XOR<MasterCountryUpdateManyMutationInput, MasterCountryUncheckedUpdateManyInput>
    /**
     * Filter which MasterCountries to update
     */
    where?: MasterCountryWhereInput
  }


  /**
   * MasterCountry upsert
   */
  export type MasterCountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * The filter to search for the MasterCountry to update in case it exists.
     */
    where: MasterCountryWhereUniqueInput
    /**
     * In case the MasterCountry found by the `where` argument doesn't exist, create a new MasterCountry with this data.
     */
    create: XOR<MasterCountryCreateInput, MasterCountryUncheckedCreateInput>
    /**
     * In case the MasterCountry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterCountryUpdateInput, MasterCountryUncheckedUpdateInput>
  }


  /**
   * MasterCountry delete
   */
  export type MasterCountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
    /**
     * Filter which MasterCountry to delete.
     */
    where: MasterCountryWhereUniqueInput
  }


  /**
   * MasterCountry deleteMany
   */
  export type MasterCountryDeleteManyArgs = {
    /**
     * Filter which MasterCountries to delete
     */
    where?: MasterCountryWhereInput
  }


  /**
   * MasterCountry without action
   */
  export type MasterCountryArgs = {
    /**
     * Select specific fields to fetch from the MasterCountry
     */
    select?: MasterCountrySelect | null
  }



  /**
   * Model MasterDosage
   */


  export type AggregateMasterDosage = {
    _count: MasterDosageCountAggregateOutputType | null
    _avg: MasterDosageAvgAggregateOutputType | null
    _sum: MasterDosageSumAggregateOutputType | null
    _min: MasterDosageMinAggregateOutputType | null
    _max: MasterDosageMaxAggregateOutputType | null
  }

  export type MasterDosageAvgAggregateOutputType = {
    id: number | null
    isActive: number | null
  }

  export type MasterDosageSumAggregateOutputType = {
    id: number | null
    isActive: number | null
  }

  export type MasterDosageMinAggregateOutputType = {
    id: number | null
    nameDossage: string | null
    isActive: number | null
  }

  export type MasterDosageMaxAggregateOutputType = {
    id: number | null
    nameDossage: string | null
    isActive: number | null
  }

  export type MasterDosageCountAggregateOutputType = {
    id: number
    nameDossage: number
    isActive: number
    _all: number
  }


  export type MasterDosageAvgAggregateInputType = {
    id?: true
    isActive?: true
  }

  export type MasterDosageSumAggregateInputType = {
    id?: true
    isActive?: true
  }

  export type MasterDosageMinAggregateInputType = {
    id?: true
    nameDossage?: true
    isActive?: true
  }

  export type MasterDosageMaxAggregateInputType = {
    id?: true
    nameDossage?: true
    isActive?: true
  }

  export type MasterDosageCountAggregateInputType = {
    id?: true
    nameDossage?: true
    isActive?: true
    _all?: true
  }

  export type MasterDosageAggregateArgs = {
    /**
     * Filter which MasterDosage to aggregate.
     */
    where?: MasterDosageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDosages to fetch.
     */
    orderBy?: Enumerable<MasterDosageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterDosageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDosages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDosages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterDosages
    **/
    _count?: true | MasterDosageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterDosageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterDosageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterDosageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterDosageMaxAggregateInputType
  }

  export type GetMasterDosageAggregateType<T extends MasterDosageAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterDosage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterDosage[P]>
      : GetScalarType<T[P], AggregateMasterDosage[P]>
  }




  export type MasterDosageGroupByArgs = {
    where?: MasterDosageWhereInput
    orderBy?: Enumerable<MasterDosageOrderByWithAggregationInput>
    by: MasterDosageScalarFieldEnum[]
    having?: MasterDosageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterDosageCountAggregateInputType | true
    _avg?: MasterDosageAvgAggregateInputType
    _sum?: MasterDosageSumAggregateInputType
    _min?: MasterDosageMinAggregateInputType
    _max?: MasterDosageMaxAggregateInputType
  }


  export type MasterDosageGroupByOutputType = {
    id: number
    nameDossage: string
    isActive: number
    _count: MasterDosageCountAggregateOutputType | null
    _avg: MasterDosageAvgAggregateOutputType | null
    _sum: MasterDosageSumAggregateOutputType | null
    _min: MasterDosageMinAggregateOutputType | null
    _max: MasterDosageMaxAggregateOutputType | null
  }

  type GetMasterDosageGroupByPayload<T extends MasterDosageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterDosageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterDosageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterDosageGroupByOutputType[P]>
            : GetScalarType<T[P], MasterDosageGroupByOutputType[P]>
        }
      >
    >


  export type MasterDosageSelect = {
    id?: boolean
    nameDossage?: boolean
    isActive?: boolean
  }


  export type MasterDosageGetPayload<S extends boolean | null | undefined | MasterDosageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterDosage :
    S extends undefined ? never :
    S extends { include: any } & (MasterDosageArgs | MasterDosageFindManyArgs)
    ? MasterDosage 
    : S extends { select: any } & (MasterDosageArgs | MasterDosageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MasterDosage ? MasterDosage[P] : never
  } 
      : MasterDosage


  type MasterDosageCountArgs = 
    Omit<MasterDosageFindManyArgs, 'select' | 'include'> & {
      select?: MasterDosageCountAggregateInputType | true
    }

  export interface MasterDosageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterDosage that matches the filter.
     * @param {MasterDosageFindUniqueArgs} args - Arguments to find a MasterDosage
     * @example
     * // Get one MasterDosage
     * const masterDosage = await prisma.masterDosage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterDosageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterDosageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterDosage'> extends True ? Prisma__MasterDosageClient<MasterDosageGetPayload<T>> : Prisma__MasterDosageClient<MasterDosageGetPayload<T> | null, null>

    /**
     * Find one MasterDosage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterDosageFindUniqueOrThrowArgs} args - Arguments to find a MasterDosage
     * @example
     * // Get one MasterDosage
     * const masterDosage = await prisma.masterDosage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterDosageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterDosageFindUniqueOrThrowArgs>
    ): Prisma__MasterDosageClient<MasterDosageGetPayload<T>>

    /**
     * Find the first MasterDosage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDosageFindFirstArgs} args - Arguments to find a MasterDosage
     * @example
     * // Get one MasterDosage
     * const masterDosage = await prisma.masterDosage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterDosageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterDosageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterDosage'> extends True ? Prisma__MasterDosageClient<MasterDosageGetPayload<T>> : Prisma__MasterDosageClient<MasterDosageGetPayload<T> | null, null>

    /**
     * Find the first MasterDosage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDosageFindFirstOrThrowArgs} args - Arguments to find a MasterDosage
     * @example
     * // Get one MasterDosage
     * const masterDosage = await prisma.masterDosage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterDosageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterDosageFindFirstOrThrowArgs>
    ): Prisma__MasterDosageClient<MasterDosageGetPayload<T>>

    /**
     * Find zero or more MasterDosages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDosageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterDosages
     * const masterDosages = await prisma.masterDosage.findMany()
     * 
     * // Get first 10 MasterDosages
     * const masterDosages = await prisma.masterDosage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterDosageWithIdOnly = await prisma.masterDosage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterDosageFindManyArgs>(
      args?: SelectSubset<T, MasterDosageFindManyArgs>
    ): PrismaPromise<Array<MasterDosageGetPayload<T>>>

    /**
     * Create a MasterDosage.
     * @param {MasterDosageCreateArgs} args - Arguments to create a MasterDosage.
     * @example
     * // Create one MasterDosage
     * const MasterDosage = await prisma.masterDosage.create({
     *   data: {
     *     // ... data to create a MasterDosage
     *   }
     * })
     * 
    **/
    create<T extends MasterDosageCreateArgs>(
      args: SelectSubset<T, MasterDosageCreateArgs>
    ): Prisma__MasterDosageClient<MasterDosageGetPayload<T>>

    /**
     * Create many MasterDosages.
     *     @param {MasterDosageCreateManyArgs} args - Arguments to create many MasterDosages.
     *     @example
     *     // Create many MasterDosages
     *     const masterDosage = await prisma.masterDosage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterDosageCreateManyArgs>(
      args?: SelectSubset<T, MasterDosageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterDosage.
     * @param {MasterDosageDeleteArgs} args - Arguments to delete one MasterDosage.
     * @example
     * // Delete one MasterDosage
     * const MasterDosage = await prisma.masterDosage.delete({
     *   where: {
     *     // ... filter to delete one MasterDosage
     *   }
     * })
     * 
    **/
    delete<T extends MasterDosageDeleteArgs>(
      args: SelectSubset<T, MasterDosageDeleteArgs>
    ): Prisma__MasterDosageClient<MasterDosageGetPayload<T>>

    /**
     * Update one MasterDosage.
     * @param {MasterDosageUpdateArgs} args - Arguments to update one MasterDosage.
     * @example
     * // Update one MasterDosage
     * const masterDosage = await prisma.masterDosage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterDosageUpdateArgs>(
      args: SelectSubset<T, MasterDosageUpdateArgs>
    ): Prisma__MasterDosageClient<MasterDosageGetPayload<T>>

    /**
     * Delete zero or more MasterDosages.
     * @param {MasterDosageDeleteManyArgs} args - Arguments to filter MasterDosages to delete.
     * @example
     * // Delete a few MasterDosages
     * const { count } = await prisma.masterDosage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterDosageDeleteManyArgs>(
      args?: SelectSubset<T, MasterDosageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterDosages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDosageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterDosages
     * const masterDosage = await prisma.masterDosage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterDosageUpdateManyArgs>(
      args: SelectSubset<T, MasterDosageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterDosage.
     * @param {MasterDosageUpsertArgs} args - Arguments to update or create a MasterDosage.
     * @example
     * // Update or create a MasterDosage
     * const masterDosage = await prisma.masterDosage.upsert({
     *   create: {
     *     // ... data to create a MasterDosage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterDosage we want to update
     *   }
     * })
    **/
    upsert<T extends MasterDosageUpsertArgs>(
      args: SelectSubset<T, MasterDosageUpsertArgs>
    ): Prisma__MasterDosageClient<MasterDosageGetPayload<T>>

    /**
     * Count the number of MasterDosages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDosageCountArgs} args - Arguments to filter MasterDosages to count.
     * @example
     * // Count the number of MasterDosages
     * const count = await prisma.masterDosage.count({
     *   where: {
     *     // ... the filter for the MasterDosages we want to count
     *   }
     * })
    **/
    count<T extends MasterDosageCountArgs>(
      args?: Subset<T, MasterDosageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterDosageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterDosage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDosageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterDosageAggregateArgs>(args: Subset<T, MasterDosageAggregateArgs>): PrismaPromise<GetMasterDosageAggregateType<T>>

    /**
     * Group by MasterDosage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDosageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterDosageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterDosageGroupByArgs['orderBy'] }
        : { orderBy?: MasterDosageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterDosageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterDosageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterDosage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterDosageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterDosage base type for findUnique actions
   */
  export type MasterDosageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * Filter, which MasterDosage to fetch.
     */
    where: MasterDosageWhereUniqueInput
  }

  /**
   * MasterDosage findUnique
   */
  export interface MasterDosageFindUniqueArgs extends MasterDosageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterDosage findUniqueOrThrow
   */
  export type MasterDosageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * Filter, which MasterDosage to fetch.
     */
    where: MasterDosageWhereUniqueInput
  }


  /**
   * MasterDosage base type for findFirst actions
   */
  export type MasterDosageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * Filter, which MasterDosage to fetch.
     */
    where?: MasterDosageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDosages to fetch.
     */
    orderBy?: Enumerable<MasterDosageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterDosages.
     */
    cursor?: MasterDosageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDosages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDosages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterDosages.
     */
    distinct?: Enumerable<MasterDosageScalarFieldEnum>
  }

  /**
   * MasterDosage findFirst
   */
  export interface MasterDosageFindFirstArgs extends MasterDosageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterDosage findFirstOrThrow
   */
  export type MasterDosageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * Filter, which MasterDosage to fetch.
     */
    where?: MasterDosageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDosages to fetch.
     */
    orderBy?: Enumerable<MasterDosageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterDosages.
     */
    cursor?: MasterDosageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDosages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDosages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterDosages.
     */
    distinct?: Enumerable<MasterDosageScalarFieldEnum>
  }


  /**
   * MasterDosage findMany
   */
  export type MasterDosageFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * Filter, which MasterDosages to fetch.
     */
    where?: MasterDosageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDosages to fetch.
     */
    orderBy?: Enumerable<MasterDosageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterDosages.
     */
    cursor?: MasterDosageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDosages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDosages.
     */
    skip?: number
    distinct?: Enumerable<MasterDosageScalarFieldEnum>
  }


  /**
   * MasterDosage create
   */
  export type MasterDosageCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * The data needed to create a MasterDosage.
     */
    data: XOR<MasterDosageCreateInput, MasterDosageUncheckedCreateInput>
  }


  /**
   * MasterDosage createMany
   */
  export type MasterDosageCreateManyArgs = {
    /**
     * The data used to create many MasterDosages.
     */
    data: Enumerable<MasterDosageCreateManyInput>
  }


  /**
   * MasterDosage update
   */
  export type MasterDosageUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * The data needed to update a MasterDosage.
     */
    data: XOR<MasterDosageUpdateInput, MasterDosageUncheckedUpdateInput>
    /**
     * Choose, which MasterDosage to update.
     */
    where: MasterDosageWhereUniqueInput
  }


  /**
   * MasterDosage updateMany
   */
  export type MasterDosageUpdateManyArgs = {
    /**
     * The data used to update MasterDosages.
     */
    data: XOR<MasterDosageUpdateManyMutationInput, MasterDosageUncheckedUpdateManyInput>
    /**
     * Filter which MasterDosages to update
     */
    where?: MasterDosageWhereInput
  }


  /**
   * MasterDosage upsert
   */
  export type MasterDosageUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * The filter to search for the MasterDosage to update in case it exists.
     */
    where: MasterDosageWhereUniqueInput
    /**
     * In case the MasterDosage found by the `where` argument doesn't exist, create a new MasterDosage with this data.
     */
    create: XOR<MasterDosageCreateInput, MasterDosageUncheckedCreateInput>
    /**
     * In case the MasterDosage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterDosageUpdateInput, MasterDosageUncheckedUpdateInput>
  }


  /**
   * MasterDosage delete
   */
  export type MasterDosageDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
    /**
     * Filter which MasterDosage to delete.
     */
    where: MasterDosageWhereUniqueInput
  }


  /**
   * MasterDosage deleteMany
   */
  export type MasterDosageDeleteManyArgs = {
    /**
     * Filter which MasterDosages to delete
     */
    where?: MasterDosageWhereInput
  }


  /**
   * MasterDosage without action
   */
  export type MasterDosageArgs = {
    /**
     * Select specific fields to fetch from the MasterDosage
     */
    select?: MasterDosageSelect | null
  }



  /**
   * Model MasterSpeciality
   */


  export type AggregateMasterSpeciality = {
    _count: MasterSpecialityCountAggregateOutputType | null
    _avg: MasterSpecialityAvgAggregateOutputType | null
    _sum: MasterSpecialitySumAggregateOutputType | null
    _min: MasterSpecialityMinAggregateOutputType | null
    _max: MasterSpecialityMaxAggregateOutputType | null
  }

  export type MasterSpecialityAvgAggregateOutputType = {
    id: number | null
    isActive: number | null
  }

  export type MasterSpecialitySumAggregateOutputType = {
    id: number | null
    isActive: number | null
  }

  export type MasterSpecialityMinAggregateOutputType = {
    id: number | null
    nameSpeciality: string | null
    isActive: number | null
  }

  export type MasterSpecialityMaxAggregateOutputType = {
    id: number | null
    nameSpeciality: string | null
    isActive: number | null
  }

  export type MasterSpecialityCountAggregateOutputType = {
    id: number
    nameSpeciality: number
    isActive: number
    _all: number
  }


  export type MasterSpecialityAvgAggregateInputType = {
    id?: true
    isActive?: true
  }

  export type MasterSpecialitySumAggregateInputType = {
    id?: true
    isActive?: true
  }

  export type MasterSpecialityMinAggregateInputType = {
    id?: true
    nameSpeciality?: true
    isActive?: true
  }

  export type MasterSpecialityMaxAggregateInputType = {
    id?: true
    nameSpeciality?: true
    isActive?: true
  }

  export type MasterSpecialityCountAggregateInputType = {
    id?: true
    nameSpeciality?: true
    isActive?: true
    _all?: true
  }

  export type MasterSpecialityAggregateArgs = {
    /**
     * Filter which MasterSpeciality to aggregate.
     */
    where?: MasterSpecialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterSpecialities to fetch.
     */
    orderBy?: Enumerable<MasterSpecialityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterSpecialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterSpecialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterSpecialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterSpecialities
    **/
    _count?: true | MasterSpecialityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterSpecialityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterSpecialitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterSpecialityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterSpecialityMaxAggregateInputType
  }

  export type GetMasterSpecialityAggregateType<T extends MasterSpecialityAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterSpeciality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterSpeciality[P]>
      : GetScalarType<T[P], AggregateMasterSpeciality[P]>
  }




  export type MasterSpecialityGroupByArgs = {
    where?: MasterSpecialityWhereInput
    orderBy?: Enumerable<MasterSpecialityOrderByWithAggregationInput>
    by: MasterSpecialityScalarFieldEnum[]
    having?: MasterSpecialityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterSpecialityCountAggregateInputType | true
    _avg?: MasterSpecialityAvgAggregateInputType
    _sum?: MasterSpecialitySumAggregateInputType
    _min?: MasterSpecialityMinAggregateInputType
    _max?: MasterSpecialityMaxAggregateInputType
  }


  export type MasterSpecialityGroupByOutputType = {
    id: number
    nameSpeciality: string
    isActive: number
    _count: MasterSpecialityCountAggregateOutputType | null
    _avg: MasterSpecialityAvgAggregateOutputType | null
    _sum: MasterSpecialitySumAggregateOutputType | null
    _min: MasterSpecialityMinAggregateOutputType | null
    _max: MasterSpecialityMaxAggregateOutputType | null
  }

  type GetMasterSpecialityGroupByPayload<T extends MasterSpecialityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterSpecialityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterSpecialityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterSpecialityGroupByOutputType[P]>
            : GetScalarType<T[P], MasterSpecialityGroupByOutputType[P]>
        }
      >
    >


  export type MasterSpecialitySelect = {
    id?: boolean
    nameSpeciality?: boolean
    isActive?: boolean
    umbrellaBrand?: boolean | MasterSpeciality$umbrellaBrandArgs
    _count?: boolean | MasterSpecialityCountOutputTypeArgs
  }


  export type MasterSpecialityInclude = {
    umbrellaBrand?: boolean | MasterSpeciality$umbrellaBrandArgs
    _count?: boolean | MasterSpecialityCountOutputTypeArgs
  }

  export type MasterSpecialityGetPayload<S extends boolean | null | undefined | MasterSpecialityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterSpeciality :
    S extends undefined ? never :
    S extends { include: any } & (MasterSpecialityArgs | MasterSpecialityFindManyArgs)
    ? MasterSpeciality  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'umbrellaBrand' ? Array < MasterUmbrellaBrandGetPayload<S['include'][P]>>  :
        P extends '_count' ? MasterSpecialityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MasterSpecialityArgs | MasterSpecialityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'umbrellaBrand' ? Array < MasterUmbrellaBrandGetPayload<S['select'][P]>>  :
        P extends '_count' ? MasterSpecialityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MasterSpeciality ? MasterSpeciality[P] : never
  } 
      : MasterSpeciality


  type MasterSpecialityCountArgs = 
    Omit<MasterSpecialityFindManyArgs, 'select' | 'include'> & {
      select?: MasterSpecialityCountAggregateInputType | true
    }

  export interface MasterSpecialityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterSpeciality that matches the filter.
     * @param {MasterSpecialityFindUniqueArgs} args - Arguments to find a MasterSpeciality
     * @example
     * // Get one MasterSpeciality
     * const masterSpeciality = await prisma.masterSpeciality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterSpecialityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterSpecialityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterSpeciality'> extends True ? Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T>> : Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T> | null, null>

    /**
     * Find one MasterSpeciality that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterSpecialityFindUniqueOrThrowArgs} args - Arguments to find a MasterSpeciality
     * @example
     * // Get one MasterSpeciality
     * const masterSpeciality = await prisma.masterSpeciality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterSpecialityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterSpecialityFindUniqueOrThrowArgs>
    ): Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T>>

    /**
     * Find the first MasterSpeciality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSpecialityFindFirstArgs} args - Arguments to find a MasterSpeciality
     * @example
     * // Get one MasterSpeciality
     * const masterSpeciality = await prisma.masterSpeciality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterSpecialityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterSpecialityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterSpeciality'> extends True ? Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T>> : Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T> | null, null>

    /**
     * Find the first MasterSpeciality that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSpecialityFindFirstOrThrowArgs} args - Arguments to find a MasterSpeciality
     * @example
     * // Get one MasterSpeciality
     * const masterSpeciality = await prisma.masterSpeciality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterSpecialityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterSpecialityFindFirstOrThrowArgs>
    ): Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T>>

    /**
     * Find zero or more MasterSpecialities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSpecialityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterSpecialities
     * const masterSpecialities = await prisma.masterSpeciality.findMany()
     * 
     * // Get first 10 MasterSpecialities
     * const masterSpecialities = await prisma.masterSpeciality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterSpecialityWithIdOnly = await prisma.masterSpeciality.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterSpecialityFindManyArgs>(
      args?: SelectSubset<T, MasterSpecialityFindManyArgs>
    ): PrismaPromise<Array<MasterSpecialityGetPayload<T>>>

    /**
     * Create a MasterSpeciality.
     * @param {MasterSpecialityCreateArgs} args - Arguments to create a MasterSpeciality.
     * @example
     * // Create one MasterSpeciality
     * const MasterSpeciality = await prisma.masterSpeciality.create({
     *   data: {
     *     // ... data to create a MasterSpeciality
     *   }
     * })
     * 
    **/
    create<T extends MasterSpecialityCreateArgs>(
      args: SelectSubset<T, MasterSpecialityCreateArgs>
    ): Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T>>

    /**
     * Create many MasterSpecialities.
     *     @param {MasterSpecialityCreateManyArgs} args - Arguments to create many MasterSpecialities.
     *     @example
     *     // Create many MasterSpecialities
     *     const masterSpeciality = await prisma.masterSpeciality.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterSpecialityCreateManyArgs>(
      args?: SelectSubset<T, MasterSpecialityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterSpeciality.
     * @param {MasterSpecialityDeleteArgs} args - Arguments to delete one MasterSpeciality.
     * @example
     * // Delete one MasterSpeciality
     * const MasterSpeciality = await prisma.masterSpeciality.delete({
     *   where: {
     *     // ... filter to delete one MasterSpeciality
     *   }
     * })
     * 
    **/
    delete<T extends MasterSpecialityDeleteArgs>(
      args: SelectSubset<T, MasterSpecialityDeleteArgs>
    ): Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T>>

    /**
     * Update one MasterSpeciality.
     * @param {MasterSpecialityUpdateArgs} args - Arguments to update one MasterSpeciality.
     * @example
     * // Update one MasterSpeciality
     * const masterSpeciality = await prisma.masterSpeciality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterSpecialityUpdateArgs>(
      args: SelectSubset<T, MasterSpecialityUpdateArgs>
    ): Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T>>

    /**
     * Delete zero or more MasterSpecialities.
     * @param {MasterSpecialityDeleteManyArgs} args - Arguments to filter MasterSpecialities to delete.
     * @example
     * // Delete a few MasterSpecialities
     * const { count } = await prisma.masterSpeciality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterSpecialityDeleteManyArgs>(
      args?: SelectSubset<T, MasterSpecialityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterSpecialities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSpecialityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterSpecialities
     * const masterSpeciality = await prisma.masterSpeciality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterSpecialityUpdateManyArgs>(
      args: SelectSubset<T, MasterSpecialityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterSpeciality.
     * @param {MasterSpecialityUpsertArgs} args - Arguments to update or create a MasterSpeciality.
     * @example
     * // Update or create a MasterSpeciality
     * const masterSpeciality = await prisma.masterSpeciality.upsert({
     *   create: {
     *     // ... data to create a MasterSpeciality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterSpeciality we want to update
     *   }
     * })
    **/
    upsert<T extends MasterSpecialityUpsertArgs>(
      args: SelectSubset<T, MasterSpecialityUpsertArgs>
    ): Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T>>

    /**
     * Count the number of MasterSpecialities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSpecialityCountArgs} args - Arguments to filter MasterSpecialities to count.
     * @example
     * // Count the number of MasterSpecialities
     * const count = await prisma.masterSpeciality.count({
     *   where: {
     *     // ... the filter for the MasterSpecialities we want to count
     *   }
     * })
    **/
    count<T extends MasterSpecialityCountArgs>(
      args?: Subset<T, MasterSpecialityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterSpecialityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterSpeciality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSpecialityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterSpecialityAggregateArgs>(args: Subset<T, MasterSpecialityAggregateArgs>): PrismaPromise<GetMasterSpecialityAggregateType<T>>

    /**
     * Group by MasterSpeciality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSpecialityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterSpecialityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterSpecialityGroupByArgs['orderBy'] }
        : { orderBy?: MasterSpecialityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterSpecialityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterSpecialityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterSpeciality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterSpecialityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    umbrellaBrand<T extends MasterSpeciality$umbrellaBrandArgs= {}>(args?: Subset<T, MasterSpeciality$umbrellaBrandArgs>): PrismaPromise<Array<MasterUmbrellaBrandGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterSpeciality base type for findUnique actions
   */
  export type MasterSpecialityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * Filter, which MasterSpeciality to fetch.
     */
    where: MasterSpecialityWhereUniqueInput
  }

  /**
   * MasterSpeciality findUnique
   */
  export interface MasterSpecialityFindUniqueArgs extends MasterSpecialityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterSpeciality findUniqueOrThrow
   */
  export type MasterSpecialityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * Filter, which MasterSpeciality to fetch.
     */
    where: MasterSpecialityWhereUniqueInput
  }


  /**
   * MasterSpeciality base type for findFirst actions
   */
  export type MasterSpecialityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * Filter, which MasterSpeciality to fetch.
     */
    where?: MasterSpecialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterSpecialities to fetch.
     */
    orderBy?: Enumerable<MasterSpecialityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterSpecialities.
     */
    cursor?: MasterSpecialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterSpecialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterSpecialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterSpecialities.
     */
    distinct?: Enumerable<MasterSpecialityScalarFieldEnum>
  }

  /**
   * MasterSpeciality findFirst
   */
  export interface MasterSpecialityFindFirstArgs extends MasterSpecialityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterSpeciality findFirstOrThrow
   */
  export type MasterSpecialityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * Filter, which MasterSpeciality to fetch.
     */
    where?: MasterSpecialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterSpecialities to fetch.
     */
    orderBy?: Enumerable<MasterSpecialityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterSpecialities.
     */
    cursor?: MasterSpecialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterSpecialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterSpecialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterSpecialities.
     */
    distinct?: Enumerable<MasterSpecialityScalarFieldEnum>
  }


  /**
   * MasterSpeciality findMany
   */
  export type MasterSpecialityFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * Filter, which MasterSpecialities to fetch.
     */
    where?: MasterSpecialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterSpecialities to fetch.
     */
    orderBy?: Enumerable<MasterSpecialityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterSpecialities.
     */
    cursor?: MasterSpecialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterSpecialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterSpecialities.
     */
    skip?: number
    distinct?: Enumerable<MasterSpecialityScalarFieldEnum>
  }


  /**
   * MasterSpeciality create
   */
  export type MasterSpecialityCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * The data needed to create a MasterSpeciality.
     */
    data: XOR<MasterSpecialityCreateInput, MasterSpecialityUncheckedCreateInput>
  }


  /**
   * MasterSpeciality createMany
   */
  export type MasterSpecialityCreateManyArgs = {
    /**
     * The data used to create many MasterSpecialities.
     */
    data: Enumerable<MasterSpecialityCreateManyInput>
  }


  /**
   * MasterSpeciality update
   */
  export type MasterSpecialityUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * The data needed to update a MasterSpeciality.
     */
    data: XOR<MasterSpecialityUpdateInput, MasterSpecialityUncheckedUpdateInput>
    /**
     * Choose, which MasterSpeciality to update.
     */
    where: MasterSpecialityWhereUniqueInput
  }


  /**
   * MasterSpeciality updateMany
   */
  export type MasterSpecialityUpdateManyArgs = {
    /**
     * The data used to update MasterSpecialities.
     */
    data: XOR<MasterSpecialityUpdateManyMutationInput, MasterSpecialityUncheckedUpdateManyInput>
    /**
     * Filter which MasterSpecialities to update
     */
    where?: MasterSpecialityWhereInput
  }


  /**
   * MasterSpeciality upsert
   */
  export type MasterSpecialityUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * The filter to search for the MasterSpeciality to update in case it exists.
     */
    where: MasterSpecialityWhereUniqueInput
    /**
     * In case the MasterSpeciality found by the `where` argument doesn't exist, create a new MasterSpeciality with this data.
     */
    create: XOR<MasterSpecialityCreateInput, MasterSpecialityUncheckedCreateInput>
    /**
     * In case the MasterSpeciality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterSpecialityUpdateInput, MasterSpecialityUncheckedUpdateInput>
  }


  /**
   * MasterSpeciality delete
   */
  export type MasterSpecialityDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
    /**
     * Filter which MasterSpeciality to delete.
     */
    where: MasterSpecialityWhereUniqueInput
  }


  /**
   * MasterSpeciality deleteMany
   */
  export type MasterSpecialityDeleteManyArgs = {
    /**
     * Filter which MasterSpecialities to delete
     */
    where?: MasterSpecialityWhereInput
  }


  /**
   * MasterSpeciality.umbrellaBrand
   */
  export type MasterSpeciality$umbrellaBrandArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    where?: MasterUmbrellaBrandWhereInput
    orderBy?: Enumerable<MasterUmbrellaBrandOrderByWithRelationInput>
    cursor?: MasterUmbrellaBrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MasterUmbrellaBrandScalarFieldEnum>
  }


  /**
   * MasterSpeciality without action
   */
  export type MasterSpecialityArgs = {
    /**
     * Select specific fields to fetch from the MasterSpeciality
     */
    select?: MasterSpecialitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterSpecialityInclude | null
  }



  /**
   * Model MasterUmbrellaBrand
   */


  export type AggregateMasterUmbrellaBrand = {
    _count: MasterUmbrellaBrandCountAggregateOutputType | null
    _avg: MasterUmbrellaBrandAvgAggregateOutputType | null
    _sum: MasterUmbrellaBrandSumAggregateOutputType | null
    _min: MasterUmbrellaBrandMinAggregateOutputType | null
    _max: MasterUmbrellaBrandMaxAggregateOutputType | null
  }

  export type MasterUmbrellaBrandAvgAggregateOutputType = {
    id: number | null
    isActive: number | null
    masterSpecialityId: number | null
  }

  export type MasterUmbrellaBrandSumAggregateOutputType = {
    id: number | null
    isActive: number | null
    masterSpecialityId: number | null
  }

  export type MasterUmbrellaBrandMinAggregateOutputType = {
    id: number | null
    nameUmbrellaBrand: string | null
    isActive: number | null
    masterSpecialityId: number | null
  }

  export type MasterUmbrellaBrandMaxAggregateOutputType = {
    id: number | null
    nameUmbrellaBrand: string | null
    isActive: number | null
    masterSpecialityId: number | null
  }

  export type MasterUmbrellaBrandCountAggregateOutputType = {
    id: number
    nameUmbrellaBrand: number
    isActive: number
    masterSpecialityId: number
    _all: number
  }


  export type MasterUmbrellaBrandAvgAggregateInputType = {
    id?: true
    isActive?: true
    masterSpecialityId?: true
  }

  export type MasterUmbrellaBrandSumAggregateInputType = {
    id?: true
    isActive?: true
    masterSpecialityId?: true
  }

  export type MasterUmbrellaBrandMinAggregateInputType = {
    id?: true
    nameUmbrellaBrand?: true
    isActive?: true
    masterSpecialityId?: true
  }

  export type MasterUmbrellaBrandMaxAggregateInputType = {
    id?: true
    nameUmbrellaBrand?: true
    isActive?: true
    masterSpecialityId?: true
  }

  export type MasterUmbrellaBrandCountAggregateInputType = {
    id?: true
    nameUmbrellaBrand?: true
    isActive?: true
    masterSpecialityId?: true
    _all?: true
  }

  export type MasterUmbrellaBrandAggregateArgs = {
    /**
     * Filter which MasterUmbrellaBrand to aggregate.
     */
    where?: MasterUmbrellaBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterUmbrellaBrands to fetch.
     */
    orderBy?: Enumerable<MasterUmbrellaBrandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterUmbrellaBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterUmbrellaBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterUmbrellaBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterUmbrellaBrands
    **/
    _count?: true | MasterUmbrellaBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterUmbrellaBrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterUmbrellaBrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterUmbrellaBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterUmbrellaBrandMaxAggregateInputType
  }

  export type GetMasterUmbrellaBrandAggregateType<T extends MasterUmbrellaBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterUmbrellaBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterUmbrellaBrand[P]>
      : GetScalarType<T[P], AggregateMasterUmbrellaBrand[P]>
  }




  export type MasterUmbrellaBrandGroupByArgs = {
    where?: MasterUmbrellaBrandWhereInput
    orderBy?: Enumerable<MasterUmbrellaBrandOrderByWithAggregationInput>
    by: MasterUmbrellaBrandScalarFieldEnum[]
    having?: MasterUmbrellaBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterUmbrellaBrandCountAggregateInputType | true
    _avg?: MasterUmbrellaBrandAvgAggregateInputType
    _sum?: MasterUmbrellaBrandSumAggregateInputType
    _min?: MasterUmbrellaBrandMinAggregateInputType
    _max?: MasterUmbrellaBrandMaxAggregateInputType
  }


  export type MasterUmbrellaBrandGroupByOutputType = {
    id: number
    nameUmbrellaBrand: string
    isActive: number
    masterSpecialityId: number | null
    _count: MasterUmbrellaBrandCountAggregateOutputType | null
    _avg: MasterUmbrellaBrandAvgAggregateOutputType | null
    _sum: MasterUmbrellaBrandSumAggregateOutputType | null
    _min: MasterUmbrellaBrandMinAggregateOutputType | null
    _max: MasterUmbrellaBrandMaxAggregateOutputType | null
  }

  type GetMasterUmbrellaBrandGroupByPayload<T extends MasterUmbrellaBrandGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterUmbrellaBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterUmbrellaBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterUmbrellaBrandGroupByOutputType[P]>
            : GetScalarType<T[P], MasterUmbrellaBrandGroupByOutputType[P]>
        }
      >
    >


  export type MasterUmbrellaBrandSelect = {
    id?: boolean
    nameUmbrellaBrand?: boolean
    isActive?: boolean
    masterBrand?: boolean | MasterUmbrellaBrand$masterBrandArgs
    MasterSpeciality?: boolean | MasterSpecialityArgs
    masterSpecialityId?: boolean
    _count?: boolean | MasterUmbrellaBrandCountOutputTypeArgs
  }


  export type MasterUmbrellaBrandInclude = {
    masterBrand?: boolean | MasterUmbrellaBrand$masterBrandArgs
    MasterSpeciality?: boolean | MasterSpecialityArgs
    _count?: boolean | MasterUmbrellaBrandCountOutputTypeArgs
  }

  export type MasterUmbrellaBrandGetPayload<S extends boolean | null | undefined | MasterUmbrellaBrandArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterUmbrellaBrand :
    S extends undefined ? never :
    S extends { include: any } & (MasterUmbrellaBrandArgs | MasterUmbrellaBrandFindManyArgs)
    ? MasterUmbrellaBrand  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'masterBrand' ? Array < MasterBrandGetPayload<S['include'][P]>>  :
        P extends 'MasterSpeciality' ? MasterSpecialityGetPayload<S['include'][P]> | null :
        P extends '_count' ? MasterUmbrellaBrandCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MasterUmbrellaBrandArgs | MasterUmbrellaBrandFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'masterBrand' ? Array < MasterBrandGetPayload<S['select'][P]>>  :
        P extends 'MasterSpeciality' ? MasterSpecialityGetPayload<S['select'][P]> | null :
        P extends '_count' ? MasterUmbrellaBrandCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MasterUmbrellaBrand ? MasterUmbrellaBrand[P] : never
  } 
      : MasterUmbrellaBrand


  type MasterUmbrellaBrandCountArgs = 
    Omit<MasterUmbrellaBrandFindManyArgs, 'select' | 'include'> & {
      select?: MasterUmbrellaBrandCountAggregateInputType | true
    }

  export interface MasterUmbrellaBrandDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterUmbrellaBrand that matches the filter.
     * @param {MasterUmbrellaBrandFindUniqueArgs} args - Arguments to find a MasterUmbrellaBrand
     * @example
     * // Get one MasterUmbrellaBrand
     * const masterUmbrellaBrand = await prisma.masterUmbrellaBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterUmbrellaBrandFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterUmbrellaBrandFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterUmbrellaBrand'> extends True ? Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T>> : Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T> | null, null>

    /**
     * Find one MasterUmbrellaBrand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterUmbrellaBrandFindUniqueOrThrowArgs} args - Arguments to find a MasterUmbrellaBrand
     * @example
     * // Get one MasterUmbrellaBrand
     * const masterUmbrellaBrand = await prisma.masterUmbrellaBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterUmbrellaBrandFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterUmbrellaBrandFindUniqueOrThrowArgs>
    ): Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T>>

    /**
     * Find the first MasterUmbrellaBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUmbrellaBrandFindFirstArgs} args - Arguments to find a MasterUmbrellaBrand
     * @example
     * // Get one MasterUmbrellaBrand
     * const masterUmbrellaBrand = await prisma.masterUmbrellaBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterUmbrellaBrandFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterUmbrellaBrandFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterUmbrellaBrand'> extends True ? Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T>> : Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T> | null, null>

    /**
     * Find the first MasterUmbrellaBrand that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUmbrellaBrandFindFirstOrThrowArgs} args - Arguments to find a MasterUmbrellaBrand
     * @example
     * // Get one MasterUmbrellaBrand
     * const masterUmbrellaBrand = await prisma.masterUmbrellaBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterUmbrellaBrandFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterUmbrellaBrandFindFirstOrThrowArgs>
    ): Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T>>

    /**
     * Find zero or more MasterUmbrellaBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUmbrellaBrandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterUmbrellaBrands
     * const masterUmbrellaBrands = await prisma.masterUmbrellaBrand.findMany()
     * 
     * // Get first 10 MasterUmbrellaBrands
     * const masterUmbrellaBrands = await prisma.masterUmbrellaBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterUmbrellaBrandWithIdOnly = await prisma.masterUmbrellaBrand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterUmbrellaBrandFindManyArgs>(
      args?: SelectSubset<T, MasterUmbrellaBrandFindManyArgs>
    ): PrismaPromise<Array<MasterUmbrellaBrandGetPayload<T>>>

    /**
     * Create a MasterUmbrellaBrand.
     * @param {MasterUmbrellaBrandCreateArgs} args - Arguments to create a MasterUmbrellaBrand.
     * @example
     * // Create one MasterUmbrellaBrand
     * const MasterUmbrellaBrand = await prisma.masterUmbrellaBrand.create({
     *   data: {
     *     // ... data to create a MasterUmbrellaBrand
     *   }
     * })
     * 
    **/
    create<T extends MasterUmbrellaBrandCreateArgs>(
      args: SelectSubset<T, MasterUmbrellaBrandCreateArgs>
    ): Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T>>

    /**
     * Create many MasterUmbrellaBrands.
     *     @param {MasterUmbrellaBrandCreateManyArgs} args - Arguments to create many MasterUmbrellaBrands.
     *     @example
     *     // Create many MasterUmbrellaBrands
     *     const masterUmbrellaBrand = await prisma.masterUmbrellaBrand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterUmbrellaBrandCreateManyArgs>(
      args?: SelectSubset<T, MasterUmbrellaBrandCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterUmbrellaBrand.
     * @param {MasterUmbrellaBrandDeleteArgs} args - Arguments to delete one MasterUmbrellaBrand.
     * @example
     * // Delete one MasterUmbrellaBrand
     * const MasterUmbrellaBrand = await prisma.masterUmbrellaBrand.delete({
     *   where: {
     *     // ... filter to delete one MasterUmbrellaBrand
     *   }
     * })
     * 
    **/
    delete<T extends MasterUmbrellaBrandDeleteArgs>(
      args: SelectSubset<T, MasterUmbrellaBrandDeleteArgs>
    ): Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T>>

    /**
     * Update one MasterUmbrellaBrand.
     * @param {MasterUmbrellaBrandUpdateArgs} args - Arguments to update one MasterUmbrellaBrand.
     * @example
     * // Update one MasterUmbrellaBrand
     * const masterUmbrellaBrand = await prisma.masterUmbrellaBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterUmbrellaBrandUpdateArgs>(
      args: SelectSubset<T, MasterUmbrellaBrandUpdateArgs>
    ): Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T>>

    /**
     * Delete zero or more MasterUmbrellaBrands.
     * @param {MasterUmbrellaBrandDeleteManyArgs} args - Arguments to filter MasterUmbrellaBrands to delete.
     * @example
     * // Delete a few MasterUmbrellaBrands
     * const { count } = await prisma.masterUmbrellaBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterUmbrellaBrandDeleteManyArgs>(
      args?: SelectSubset<T, MasterUmbrellaBrandDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterUmbrellaBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUmbrellaBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterUmbrellaBrands
     * const masterUmbrellaBrand = await prisma.masterUmbrellaBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterUmbrellaBrandUpdateManyArgs>(
      args: SelectSubset<T, MasterUmbrellaBrandUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterUmbrellaBrand.
     * @param {MasterUmbrellaBrandUpsertArgs} args - Arguments to update or create a MasterUmbrellaBrand.
     * @example
     * // Update or create a MasterUmbrellaBrand
     * const masterUmbrellaBrand = await prisma.masterUmbrellaBrand.upsert({
     *   create: {
     *     // ... data to create a MasterUmbrellaBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterUmbrellaBrand we want to update
     *   }
     * })
    **/
    upsert<T extends MasterUmbrellaBrandUpsertArgs>(
      args: SelectSubset<T, MasterUmbrellaBrandUpsertArgs>
    ): Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T>>

    /**
     * Count the number of MasterUmbrellaBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUmbrellaBrandCountArgs} args - Arguments to filter MasterUmbrellaBrands to count.
     * @example
     * // Count the number of MasterUmbrellaBrands
     * const count = await prisma.masterUmbrellaBrand.count({
     *   where: {
     *     // ... the filter for the MasterUmbrellaBrands we want to count
     *   }
     * })
    **/
    count<T extends MasterUmbrellaBrandCountArgs>(
      args?: Subset<T, MasterUmbrellaBrandCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterUmbrellaBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterUmbrellaBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUmbrellaBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterUmbrellaBrandAggregateArgs>(args: Subset<T, MasterUmbrellaBrandAggregateArgs>): PrismaPromise<GetMasterUmbrellaBrandAggregateType<T>>

    /**
     * Group by MasterUmbrellaBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUmbrellaBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterUmbrellaBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterUmbrellaBrandGroupByArgs['orderBy'] }
        : { orderBy?: MasterUmbrellaBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterUmbrellaBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterUmbrellaBrandGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterUmbrellaBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterUmbrellaBrandClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    masterBrand<T extends MasterUmbrellaBrand$masterBrandArgs= {}>(args?: Subset<T, MasterUmbrellaBrand$masterBrandArgs>): PrismaPromise<Array<MasterBrandGetPayload<T>>| Null>;

    MasterSpeciality<T extends MasterSpecialityArgs= {}>(args?: Subset<T, MasterSpecialityArgs>): Prisma__MasterSpecialityClient<MasterSpecialityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterUmbrellaBrand base type for findUnique actions
   */
  export type MasterUmbrellaBrandFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * Filter, which MasterUmbrellaBrand to fetch.
     */
    where: MasterUmbrellaBrandWhereUniqueInput
  }

  /**
   * MasterUmbrellaBrand findUnique
   */
  export interface MasterUmbrellaBrandFindUniqueArgs extends MasterUmbrellaBrandFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterUmbrellaBrand findUniqueOrThrow
   */
  export type MasterUmbrellaBrandFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * Filter, which MasterUmbrellaBrand to fetch.
     */
    where: MasterUmbrellaBrandWhereUniqueInput
  }


  /**
   * MasterUmbrellaBrand base type for findFirst actions
   */
  export type MasterUmbrellaBrandFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * Filter, which MasterUmbrellaBrand to fetch.
     */
    where?: MasterUmbrellaBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterUmbrellaBrands to fetch.
     */
    orderBy?: Enumerable<MasterUmbrellaBrandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterUmbrellaBrands.
     */
    cursor?: MasterUmbrellaBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterUmbrellaBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterUmbrellaBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterUmbrellaBrands.
     */
    distinct?: Enumerable<MasterUmbrellaBrandScalarFieldEnum>
  }

  /**
   * MasterUmbrellaBrand findFirst
   */
  export interface MasterUmbrellaBrandFindFirstArgs extends MasterUmbrellaBrandFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterUmbrellaBrand findFirstOrThrow
   */
  export type MasterUmbrellaBrandFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * Filter, which MasterUmbrellaBrand to fetch.
     */
    where?: MasterUmbrellaBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterUmbrellaBrands to fetch.
     */
    orderBy?: Enumerable<MasterUmbrellaBrandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterUmbrellaBrands.
     */
    cursor?: MasterUmbrellaBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterUmbrellaBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterUmbrellaBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterUmbrellaBrands.
     */
    distinct?: Enumerable<MasterUmbrellaBrandScalarFieldEnum>
  }


  /**
   * MasterUmbrellaBrand findMany
   */
  export type MasterUmbrellaBrandFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * Filter, which MasterUmbrellaBrands to fetch.
     */
    where?: MasterUmbrellaBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterUmbrellaBrands to fetch.
     */
    orderBy?: Enumerable<MasterUmbrellaBrandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterUmbrellaBrands.
     */
    cursor?: MasterUmbrellaBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterUmbrellaBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterUmbrellaBrands.
     */
    skip?: number
    distinct?: Enumerable<MasterUmbrellaBrandScalarFieldEnum>
  }


  /**
   * MasterUmbrellaBrand create
   */
  export type MasterUmbrellaBrandCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * The data needed to create a MasterUmbrellaBrand.
     */
    data: XOR<MasterUmbrellaBrandCreateInput, MasterUmbrellaBrandUncheckedCreateInput>
  }


  /**
   * MasterUmbrellaBrand createMany
   */
  export type MasterUmbrellaBrandCreateManyArgs = {
    /**
     * The data used to create many MasterUmbrellaBrands.
     */
    data: Enumerable<MasterUmbrellaBrandCreateManyInput>
  }


  /**
   * MasterUmbrellaBrand update
   */
  export type MasterUmbrellaBrandUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * The data needed to update a MasterUmbrellaBrand.
     */
    data: XOR<MasterUmbrellaBrandUpdateInput, MasterUmbrellaBrandUncheckedUpdateInput>
    /**
     * Choose, which MasterUmbrellaBrand to update.
     */
    where: MasterUmbrellaBrandWhereUniqueInput
  }


  /**
   * MasterUmbrellaBrand updateMany
   */
  export type MasterUmbrellaBrandUpdateManyArgs = {
    /**
     * The data used to update MasterUmbrellaBrands.
     */
    data: XOR<MasterUmbrellaBrandUpdateManyMutationInput, MasterUmbrellaBrandUncheckedUpdateManyInput>
    /**
     * Filter which MasterUmbrellaBrands to update
     */
    where?: MasterUmbrellaBrandWhereInput
  }


  /**
   * MasterUmbrellaBrand upsert
   */
  export type MasterUmbrellaBrandUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * The filter to search for the MasterUmbrellaBrand to update in case it exists.
     */
    where: MasterUmbrellaBrandWhereUniqueInput
    /**
     * In case the MasterUmbrellaBrand found by the `where` argument doesn't exist, create a new MasterUmbrellaBrand with this data.
     */
    create: XOR<MasterUmbrellaBrandCreateInput, MasterUmbrellaBrandUncheckedCreateInput>
    /**
     * In case the MasterUmbrellaBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterUmbrellaBrandUpdateInput, MasterUmbrellaBrandUncheckedUpdateInput>
  }


  /**
   * MasterUmbrellaBrand delete
   */
  export type MasterUmbrellaBrandDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
    /**
     * Filter which MasterUmbrellaBrand to delete.
     */
    where: MasterUmbrellaBrandWhereUniqueInput
  }


  /**
   * MasterUmbrellaBrand deleteMany
   */
  export type MasterUmbrellaBrandDeleteManyArgs = {
    /**
     * Filter which MasterUmbrellaBrands to delete
     */
    where?: MasterUmbrellaBrandWhereInput
  }


  /**
   * MasterUmbrellaBrand.masterBrand
   */
  export type MasterUmbrellaBrand$masterBrandArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    where?: MasterBrandWhereInput
    orderBy?: Enumerable<MasterBrandOrderByWithRelationInput>
    cursor?: MasterBrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MasterBrandScalarFieldEnum>
  }


  /**
   * MasterUmbrellaBrand without action
   */
  export type MasterUmbrellaBrandArgs = {
    /**
     * Select specific fields to fetch from the MasterUmbrellaBrand
     */
    select?: MasterUmbrellaBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterUmbrellaBrandInclude | null
  }



  /**
   * Model MasterBrand
   */


  export type AggregateMasterBrand = {
    _count: MasterBrandCountAggregateOutputType | null
    _avg: MasterBrandAvgAggregateOutputType | null
    _sum: MasterBrandSumAggregateOutputType | null
    _min: MasterBrandMinAggregateOutputType | null
    _max: MasterBrandMaxAggregateOutputType | null
  }

  export type MasterBrandAvgAggregateOutputType = {
    id: number | null
    umbrellaBrandId: number | null
    isActive: number | null
  }

  export type MasterBrandSumAggregateOutputType = {
    id: number | null
    umbrellaBrandId: number | null
    isActive: number | null
  }

  export type MasterBrandMinAggregateOutputType = {
    id: number | null
    umbrellaBrandId: number | null
    nameBrand: string | null
    isActive: number | null
  }

  export type MasterBrandMaxAggregateOutputType = {
    id: number | null
    umbrellaBrandId: number | null
    nameBrand: string | null
    isActive: number | null
  }

  export type MasterBrandCountAggregateOutputType = {
    id: number
    umbrellaBrandId: number
    nameBrand: number
    isActive: number
    _all: number
  }


  export type MasterBrandAvgAggregateInputType = {
    id?: true
    umbrellaBrandId?: true
    isActive?: true
  }

  export type MasterBrandSumAggregateInputType = {
    id?: true
    umbrellaBrandId?: true
    isActive?: true
  }

  export type MasterBrandMinAggregateInputType = {
    id?: true
    umbrellaBrandId?: true
    nameBrand?: true
    isActive?: true
  }

  export type MasterBrandMaxAggregateInputType = {
    id?: true
    umbrellaBrandId?: true
    nameBrand?: true
    isActive?: true
  }

  export type MasterBrandCountAggregateInputType = {
    id?: true
    umbrellaBrandId?: true
    nameBrand?: true
    isActive?: true
    _all?: true
  }

  export type MasterBrandAggregateArgs = {
    /**
     * Filter which MasterBrand to aggregate.
     */
    where?: MasterBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBrands to fetch.
     */
    orderBy?: Enumerable<MasterBrandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterBrands
    **/
    _count?: true | MasterBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterBrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterBrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterBrandMaxAggregateInputType
  }

  export type GetMasterBrandAggregateType<T extends MasterBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterBrand[P]>
      : GetScalarType<T[P], AggregateMasterBrand[P]>
  }




  export type MasterBrandGroupByArgs = {
    where?: MasterBrandWhereInput
    orderBy?: Enumerable<MasterBrandOrderByWithAggregationInput>
    by: MasterBrandScalarFieldEnum[]
    having?: MasterBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterBrandCountAggregateInputType | true
    _avg?: MasterBrandAvgAggregateInputType
    _sum?: MasterBrandSumAggregateInputType
    _min?: MasterBrandMinAggregateInputType
    _max?: MasterBrandMaxAggregateInputType
  }


  export type MasterBrandGroupByOutputType = {
    id: number
    umbrellaBrandId: number
    nameBrand: string
    isActive: number
    _count: MasterBrandCountAggregateOutputType | null
    _avg: MasterBrandAvgAggregateOutputType | null
    _sum: MasterBrandSumAggregateOutputType | null
    _min: MasterBrandMinAggregateOutputType | null
    _max: MasterBrandMaxAggregateOutputType | null
  }

  type GetMasterBrandGroupByPayload<T extends MasterBrandGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterBrandGroupByOutputType[P]>
            : GetScalarType<T[P], MasterBrandGroupByOutputType[P]>
        }
      >
    >


  export type MasterBrandSelect = {
    id?: boolean
    umbrellaBrand?: boolean | MasterUmbrellaBrandArgs
    umbrellaBrandId?: boolean
    nameBrand?: boolean
    isActive?: boolean
    MasterComposition?: boolean | MasterBrand$MasterCompositionArgs
    _count?: boolean | MasterBrandCountOutputTypeArgs
  }


  export type MasterBrandInclude = {
    umbrellaBrand?: boolean | MasterUmbrellaBrandArgs
    MasterComposition?: boolean | MasterBrand$MasterCompositionArgs
    _count?: boolean | MasterBrandCountOutputTypeArgs
  }

  export type MasterBrandGetPayload<S extends boolean | null | undefined | MasterBrandArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterBrand :
    S extends undefined ? never :
    S extends { include: any } & (MasterBrandArgs | MasterBrandFindManyArgs)
    ? MasterBrand  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'umbrellaBrand' ? MasterUmbrellaBrandGetPayload<S['include'][P]> :
        P extends 'MasterComposition' ? Array < MasterCompositionGetPayload<S['include'][P]>>  :
        P extends '_count' ? MasterBrandCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MasterBrandArgs | MasterBrandFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'umbrellaBrand' ? MasterUmbrellaBrandGetPayload<S['select'][P]> :
        P extends 'MasterComposition' ? Array < MasterCompositionGetPayload<S['select'][P]>>  :
        P extends '_count' ? MasterBrandCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MasterBrand ? MasterBrand[P] : never
  } 
      : MasterBrand


  type MasterBrandCountArgs = 
    Omit<MasterBrandFindManyArgs, 'select' | 'include'> & {
      select?: MasterBrandCountAggregateInputType | true
    }

  export interface MasterBrandDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterBrand that matches the filter.
     * @param {MasterBrandFindUniqueArgs} args - Arguments to find a MasterBrand
     * @example
     * // Get one MasterBrand
     * const masterBrand = await prisma.masterBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterBrandFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterBrandFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterBrand'> extends True ? Prisma__MasterBrandClient<MasterBrandGetPayload<T>> : Prisma__MasterBrandClient<MasterBrandGetPayload<T> | null, null>

    /**
     * Find one MasterBrand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterBrandFindUniqueOrThrowArgs} args - Arguments to find a MasterBrand
     * @example
     * // Get one MasterBrand
     * const masterBrand = await prisma.masterBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterBrandFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterBrandFindUniqueOrThrowArgs>
    ): Prisma__MasterBrandClient<MasterBrandGetPayload<T>>

    /**
     * Find the first MasterBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBrandFindFirstArgs} args - Arguments to find a MasterBrand
     * @example
     * // Get one MasterBrand
     * const masterBrand = await prisma.masterBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterBrandFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterBrandFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterBrand'> extends True ? Prisma__MasterBrandClient<MasterBrandGetPayload<T>> : Prisma__MasterBrandClient<MasterBrandGetPayload<T> | null, null>

    /**
     * Find the first MasterBrand that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBrandFindFirstOrThrowArgs} args - Arguments to find a MasterBrand
     * @example
     * // Get one MasterBrand
     * const masterBrand = await prisma.masterBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterBrandFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterBrandFindFirstOrThrowArgs>
    ): Prisma__MasterBrandClient<MasterBrandGetPayload<T>>

    /**
     * Find zero or more MasterBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBrandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterBrands
     * const masterBrands = await prisma.masterBrand.findMany()
     * 
     * // Get first 10 MasterBrands
     * const masterBrands = await prisma.masterBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterBrandWithIdOnly = await prisma.masterBrand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterBrandFindManyArgs>(
      args?: SelectSubset<T, MasterBrandFindManyArgs>
    ): PrismaPromise<Array<MasterBrandGetPayload<T>>>

    /**
     * Create a MasterBrand.
     * @param {MasterBrandCreateArgs} args - Arguments to create a MasterBrand.
     * @example
     * // Create one MasterBrand
     * const MasterBrand = await prisma.masterBrand.create({
     *   data: {
     *     // ... data to create a MasterBrand
     *   }
     * })
     * 
    **/
    create<T extends MasterBrandCreateArgs>(
      args: SelectSubset<T, MasterBrandCreateArgs>
    ): Prisma__MasterBrandClient<MasterBrandGetPayload<T>>

    /**
     * Create many MasterBrands.
     *     @param {MasterBrandCreateManyArgs} args - Arguments to create many MasterBrands.
     *     @example
     *     // Create many MasterBrands
     *     const masterBrand = await prisma.masterBrand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterBrandCreateManyArgs>(
      args?: SelectSubset<T, MasterBrandCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterBrand.
     * @param {MasterBrandDeleteArgs} args - Arguments to delete one MasterBrand.
     * @example
     * // Delete one MasterBrand
     * const MasterBrand = await prisma.masterBrand.delete({
     *   where: {
     *     // ... filter to delete one MasterBrand
     *   }
     * })
     * 
    **/
    delete<T extends MasterBrandDeleteArgs>(
      args: SelectSubset<T, MasterBrandDeleteArgs>
    ): Prisma__MasterBrandClient<MasterBrandGetPayload<T>>

    /**
     * Update one MasterBrand.
     * @param {MasterBrandUpdateArgs} args - Arguments to update one MasterBrand.
     * @example
     * // Update one MasterBrand
     * const masterBrand = await prisma.masterBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterBrandUpdateArgs>(
      args: SelectSubset<T, MasterBrandUpdateArgs>
    ): Prisma__MasterBrandClient<MasterBrandGetPayload<T>>

    /**
     * Delete zero or more MasterBrands.
     * @param {MasterBrandDeleteManyArgs} args - Arguments to filter MasterBrands to delete.
     * @example
     * // Delete a few MasterBrands
     * const { count } = await prisma.masterBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterBrandDeleteManyArgs>(
      args?: SelectSubset<T, MasterBrandDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterBrands
     * const masterBrand = await prisma.masterBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterBrandUpdateManyArgs>(
      args: SelectSubset<T, MasterBrandUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterBrand.
     * @param {MasterBrandUpsertArgs} args - Arguments to update or create a MasterBrand.
     * @example
     * // Update or create a MasterBrand
     * const masterBrand = await prisma.masterBrand.upsert({
     *   create: {
     *     // ... data to create a MasterBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterBrand we want to update
     *   }
     * })
    **/
    upsert<T extends MasterBrandUpsertArgs>(
      args: SelectSubset<T, MasterBrandUpsertArgs>
    ): Prisma__MasterBrandClient<MasterBrandGetPayload<T>>

    /**
     * Count the number of MasterBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBrandCountArgs} args - Arguments to filter MasterBrands to count.
     * @example
     * // Count the number of MasterBrands
     * const count = await prisma.masterBrand.count({
     *   where: {
     *     // ... the filter for the MasterBrands we want to count
     *   }
     * })
    **/
    count<T extends MasterBrandCountArgs>(
      args?: Subset<T, MasterBrandCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterBrandAggregateArgs>(args: Subset<T, MasterBrandAggregateArgs>): PrismaPromise<GetMasterBrandAggregateType<T>>

    /**
     * Group by MasterBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterBrandGroupByArgs['orderBy'] }
        : { orderBy?: MasterBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterBrandGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterBrandClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    umbrellaBrand<T extends MasterUmbrellaBrandArgs= {}>(args?: Subset<T, MasterUmbrellaBrandArgs>): Prisma__MasterUmbrellaBrandClient<MasterUmbrellaBrandGetPayload<T> | Null>;

    MasterComposition<T extends MasterBrand$MasterCompositionArgs= {}>(args?: Subset<T, MasterBrand$MasterCompositionArgs>): PrismaPromise<Array<MasterCompositionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterBrand base type for findUnique actions
   */
  export type MasterBrandFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * Filter, which MasterBrand to fetch.
     */
    where: MasterBrandWhereUniqueInput
  }

  /**
   * MasterBrand findUnique
   */
  export interface MasterBrandFindUniqueArgs extends MasterBrandFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterBrand findUniqueOrThrow
   */
  export type MasterBrandFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * Filter, which MasterBrand to fetch.
     */
    where: MasterBrandWhereUniqueInput
  }


  /**
   * MasterBrand base type for findFirst actions
   */
  export type MasterBrandFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * Filter, which MasterBrand to fetch.
     */
    where?: MasterBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBrands to fetch.
     */
    orderBy?: Enumerable<MasterBrandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterBrands.
     */
    cursor?: MasterBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterBrands.
     */
    distinct?: Enumerable<MasterBrandScalarFieldEnum>
  }

  /**
   * MasterBrand findFirst
   */
  export interface MasterBrandFindFirstArgs extends MasterBrandFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterBrand findFirstOrThrow
   */
  export type MasterBrandFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * Filter, which MasterBrand to fetch.
     */
    where?: MasterBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBrands to fetch.
     */
    orderBy?: Enumerable<MasterBrandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterBrands.
     */
    cursor?: MasterBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterBrands.
     */
    distinct?: Enumerable<MasterBrandScalarFieldEnum>
  }


  /**
   * MasterBrand findMany
   */
  export type MasterBrandFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * Filter, which MasterBrands to fetch.
     */
    where?: MasterBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBrands to fetch.
     */
    orderBy?: Enumerable<MasterBrandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterBrands.
     */
    cursor?: MasterBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBrands.
     */
    skip?: number
    distinct?: Enumerable<MasterBrandScalarFieldEnum>
  }


  /**
   * MasterBrand create
   */
  export type MasterBrandCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * The data needed to create a MasterBrand.
     */
    data: XOR<MasterBrandCreateInput, MasterBrandUncheckedCreateInput>
  }


  /**
   * MasterBrand createMany
   */
  export type MasterBrandCreateManyArgs = {
    /**
     * The data used to create many MasterBrands.
     */
    data: Enumerable<MasterBrandCreateManyInput>
  }


  /**
   * MasterBrand update
   */
  export type MasterBrandUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * The data needed to update a MasterBrand.
     */
    data: XOR<MasterBrandUpdateInput, MasterBrandUncheckedUpdateInput>
    /**
     * Choose, which MasterBrand to update.
     */
    where: MasterBrandWhereUniqueInput
  }


  /**
   * MasterBrand updateMany
   */
  export type MasterBrandUpdateManyArgs = {
    /**
     * The data used to update MasterBrands.
     */
    data: XOR<MasterBrandUpdateManyMutationInput, MasterBrandUncheckedUpdateManyInput>
    /**
     * Filter which MasterBrands to update
     */
    where?: MasterBrandWhereInput
  }


  /**
   * MasterBrand upsert
   */
  export type MasterBrandUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * The filter to search for the MasterBrand to update in case it exists.
     */
    where: MasterBrandWhereUniqueInput
    /**
     * In case the MasterBrand found by the `where` argument doesn't exist, create a new MasterBrand with this data.
     */
    create: XOR<MasterBrandCreateInput, MasterBrandUncheckedCreateInput>
    /**
     * In case the MasterBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterBrandUpdateInput, MasterBrandUncheckedUpdateInput>
  }


  /**
   * MasterBrand delete
   */
  export type MasterBrandDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
    /**
     * Filter which MasterBrand to delete.
     */
    where: MasterBrandWhereUniqueInput
  }


  /**
   * MasterBrand deleteMany
   */
  export type MasterBrandDeleteManyArgs = {
    /**
     * Filter which MasterBrands to delete
     */
    where?: MasterBrandWhereInput
  }


  /**
   * MasterBrand.MasterComposition
   */
  export type MasterBrand$MasterCompositionArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    where?: MasterCompositionWhereInput
    orderBy?: Enumerable<MasterCompositionOrderByWithRelationInput>
    cursor?: MasterCompositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MasterCompositionScalarFieldEnum>
  }


  /**
   * MasterBrand without action
   */
  export type MasterBrandArgs = {
    /**
     * Select specific fields to fetch from the MasterBrand
     */
    select?: MasterBrandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterBrandInclude | null
  }



  /**
   * Model MasterComposition
   */


  export type AggregateMasterComposition = {
    _count: MasterCompositionCountAggregateOutputType | null
    _avg: MasterCompositionAvgAggregateOutputType | null
    _sum: MasterCompositionSumAggregateOutputType | null
    _min: MasterCompositionMinAggregateOutputType | null
    _max: MasterCompositionMaxAggregateOutputType | null
  }

  export type MasterCompositionAvgAggregateOutputType = {
    id: number | null
    brandId: number | null
    isActive: number | null
  }

  export type MasterCompositionSumAggregateOutputType = {
    id: number | null
    brandId: number | null
    isActive: number | null
  }

  export type MasterCompositionMinAggregateOutputType = {
    id: number | null
    brandId: number | null
    nameComposition: string | null
    sku: string | null
    isActive: number | null
  }

  export type MasterCompositionMaxAggregateOutputType = {
    id: number | null
    brandId: number | null
    nameComposition: string | null
    sku: string | null
    isActive: number | null
  }

  export type MasterCompositionCountAggregateOutputType = {
    id: number
    brandId: number
    nameComposition: number
    sku: number
    isActive: number
    _all: number
  }


  export type MasterCompositionAvgAggregateInputType = {
    id?: true
    brandId?: true
    isActive?: true
  }

  export type MasterCompositionSumAggregateInputType = {
    id?: true
    brandId?: true
    isActive?: true
  }

  export type MasterCompositionMinAggregateInputType = {
    id?: true
    brandId?: true
    nameComposition?: true
    sku?: true
    isActive?: true
  }

  export type MasterCompositionMaxAggregateInputType = {
    id?: true
    brandId?: true
    nameComposition?: true
    sku?: true
    isActive?: true
  }

  export type MasterCompositionCountAggregateInputType = {
    id?: true
    brandId?: true
    nameComposition?: true
    sku?: true
    isActive?: true
    _all?: true
  }

  export type MasterCompositionAggregateArgs = {
    /**
     * Filter which MasterComposition to aggregate.
     */
    where?: MasterCompositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterCompositions to fetch.
     */
    orderBy?: Enumerable<MasterCompositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterCompositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterCompositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterCompositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterCompositions
    **/
    _count?: true | MasterCompositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterCompositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterCompositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterCompositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterCompositionMaxAggregateInputType
  }

  export type GetMasterCompositionAggregateType<T extends MasterCompositionAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterComposition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterComposition[P]>
      : GetScalarType<T[P], AggregateMasterComposition[P]>
  }




  export type MasterCompositionGroupByArgs = {
    where?: MasterCompositionWhereInput
    orderBy?: Enumerable<MasterCompositionOrderByWithAggregationInput>
    by: MasterCompositionScalarFieldEnum[]
    having?: MasterCompositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterCompositionCountAggregateInputType | true
    _avg?: MasterCompositionAvgAggregateInputType
    _sum?: MasterCompositionSumAggregateInputType
    _min?: MasterCompositionMinAggregateInputType
    _max?: MasterCompositionMaxAggregateInputType
  }


  export type MasterCompositionGroupByOutputType = {
    id: number
    brandId: number
    nameComposition: string
    sku: string
    isActive: number
    _count: MasterCompositionCountAggregateOutputType | null
    _avg: MasterCompositionAvgAggregateOutputType | null
    _sum: MasterCompositionSumAggregateOutputType | null
    _min: MasterCompositionMinAggregateOutputType | null
    _max: MasterCompositionMaxAggregateOutputType | null
  }

  type GetMasterCompositionGroupByPayload<T extends MasterCompositionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterCompositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterCompositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterCompositionGroupByOutputType[P]>
            : GetScalarType<T[P], MasterCompositionGroupByOutputType[P]>
        }
      >
    >


  export type MasterCompositionSelect = {
    id?: boolean
    brand?: boolean | MasterBrandArgs
    brandId?: boolean
    nameComposition?: boolean
    sku?: boolean
    isActive?: boolean
  }


  export type MasterCompositionInclude = {
    brand?: boolean | MasterBrandArgs
  }

  export type MasterCompositionGetPayload<S extends boolean | null | undefined | MasterCompositionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterComposition :
    S extends undefined ? never :
    S extends { include: any } & (MasterCompositionArgs | MasterCompositionFindManyArgs)
    ? MasterComposition  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'brand' ? MasterBrandGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MasterCompositionArgs | MasterCompositionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'brand' ? MasterBrandGetPayload<S['select'][P]> :  P extends keyof MasterComposition ? MasterComposition[P] : never
  } 
      : MasterComposition


  type MasterCompositionCountArgs = 
    Omit<MasterCompositionFindManyArgs, 'select' | 'include'> & {
      select?: MasterCompositionCountAggregateInputType | true
    }

  export interface MasterCompositionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterComposition that matches the filter.
     * @param {MasterCompositionFindUniqueArgs} args - Arguments to find a MasterComposition
     * @example
     * // Get one MasterComposition
     * const masterComposition = await prisma.masterComposition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterCompositionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterCompositionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterComposition'> extends True ? Prisma__MasterCompositionClient<MasterCompositionGetPayload<T>> : Prisma__MasterCompositionClient<MasterCompositionGetPayload<T> | null, null>

    /**
     * Find one MasterComposition that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterCompositionFindUniqueOrThrowArgs} args - Arguments to find a MasterComposition
     * @example
     * // Get one MasterComposition
     * const masterComposition = await prisma.masterComposition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterCompositionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterCompositionFindUniqueOrThrowArgs>
    ): Prisma__MasterCompositionClient<MasterCompositionGetPayload<T>>

    /**
     * Find the first MasterComposition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCompositionFindFirstArgs} args - Arguments to find a MasterComposition
     * @example
     * // Get one MasterComposition
     * const masterComposition = await prisma.masterComposition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterCompositionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterCompositionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterComposition'> extends True ? Prisma__MasterCompositionClient<MasterCompositionGetPayload<T>> : Prisma__MasterCompositionClient<MasterCompositionGetPayload<T> | null, null>

    /**
     * Find the first MasterComposition that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCompositionFindFirstOrThrowArgs} args - Arguments to find a MasterComposition
     * @example
     * // Get one MasterComposition
     * const masterComposition = await prisma.masterComposition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterCompositionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterCompositionFindFirstOrThrowArgs>
    ): Prisma__MasterCompositionClient<MasterCompositionGetPayload<T>>

    /**
     * Find zero or more MasterCompositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCompositionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterCompositions
     * const masterCompositions = await prisma.masterComposition.findMany()
     * 
     * // Get first 10 MasterCompositions
     * const masterCompositions = await prisma.masterComposition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterCompositionWithIdOnly = await prisma.masterComposition.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterCompositionFindManyArgs>(
      args?: SelectSubset<T, MasterCompositionFindManyArgs>
    ): PrismaPromise<Array<MasterCompositionGetPayload<T>>>

    /**
     * Create a MasterComposition.
     * @param {MasterCompositionCreateArgs} args - Arguments to create a MasterComposition.
     * @example
     * // Create one MasterComposition
     * const MasterComposition = await prisma.masterComposition.create({
     *   data: {
     *     // ... data to create a MasterComposition
     *   }
     * })
     * 
    **/
    create<T extends MasterCompositionCreateArgs>(
      args: SelectSubset<T, MasterCompositionCreateArgs>
    ): Prisma__MasterCompositionClient<MasterCompositionGetPayload<T>>

    /**
     * Create many MasterCompositions.
     *     @param {MasterCompositionCreateManyArgs} args - Arguments to create many MasterCompositions.
     *     @example
     *     // Create many MasterCompositions
     *     const masterComposition = await prisma.masterComposition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterCompositionCreateManyArgs>(
      args?: SelectSubset<T, MasterCompositionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterComposition.
     * @param {MasterCompositionDeleteArgs} args - Arguments to delete one MasterComposition.
     * @example
     * // Delete one MasterComposition
     * const MasterComposition = await prisma.masterComposition.delete({
     *   where: {
     *     // ... filter to delete one MasterComposition
     *   }
     * })
     * 
    **/
    delete<T extends MasterCompositionDeleteArgs>(
      args: SelectSubset<T, MasterCompositionDeleteArgs>
    ): Prisma__MasterCompositionClient<MasterCompositionGetPayload<T>>

    /**
     * Update one MasterComposition.
     * @param {MasterCompositionUpdateArgs} args - Arguments to update one MasterComposition.
     * @example
     * // Update one MasterComposition
     * const masterComposition = await prisma.masterComposition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterCompositionUpdateArgs>(
      args: SelectSubset<T, MasterCompositionUpdateArgs>
    ): Prisma__MasterCompositionClient<MasterCompositionGetPayload<T>>

    /**
     * Delete zero or more MasterCompositions.
     * @param {MasterCompositionDeleteManyArgs} args - Arguments to filter MasterCompositions to delete.
     * @example
     * // Delete a few MasterCompositions
     * const { count } = await prisma.masterComposition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterCompositionDeleteManyArgs>(
      args?: SelectSubset<T, MasterCompositionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterCompositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCompositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterCompositions
     * const masterComposition = await prisma.masterComposition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterCompositionUpdateManyArgs>(
      args: SelectSubset<T, MasterCompositionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterComposition.
     * @param {MasterCompositionUpsertArgs} args - Arguments to update or create a MasterComposition.
     * @example
     * // Update or create a MasterComposition
     * const masterComposition = await prisma.masterComposition.upsert({
     *   create: {
     *     // ... data to create a MasterComposition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterComposition we want to update
     *   }
     * })
    **/
    upsert<T extends MasterCompositionUpsertArgs>(
      args: SelectSubset<T, MasterCompositionUpsertArgs>
    ): Prisma__MasterCompositionClient<MasterCompositionGetPayload<T>>

    /**
     * Count the number of MasterCompositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCompositionCountArgs} args - Arguments to filter MasterCompositions to count.
     * @example
     * // Count the number of MasterCompositions
     * const count = await prisma.masterComposition.count({
     *   where: {
     *     // ... the filter for the MasterCompositions we want to count
     *   }
     * })
    **/
    count<T extends MasterCompositionCountArgs>(
      args?: Subset<T, MasterCompositionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterCompositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterComposition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCompositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterCompositionAggregateArgs>(args: Subset<T, MasterCompositionAggregateArgs>): PrismaPromise<GetMasterCompositionAggregateType<T>>

    /**
     * Group by MasterComposition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCompositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterCompositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterCompositionGroupByArgs['orderBy'] }
        : { orderBy?: MasterCompositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterCompositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterCompositionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterComposition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterCompositionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    brand<T extends MasterBrandArgs= {}>(args?: Subset<T, MasterBrandArgs>): Prisma__MasterBrandClient<MasterBrandGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterComposition base type for findUnique actions
   */
  export type MasterCompositionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * Filter, which MasterComposition to fetch.
     */
    where: MasterCompositionWhereUniqueInput
  }

  /**
   * MasterComposition findUnique
   */
  export interface MasterCompositionFindUniqueArgs extends MasterCompositionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterComposition findUniqueOrThrow
   */
  export type MasterCompositionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * Filter, which MasterComposition to fetch.
     */
    where: MasterCompositionWhereUniqueInput
  }


  /**
   * MasterComposition base type for findFirst actions
   */
  export type MasterCompositionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * Filter, which MasterComposition to fetch.
     */
    where?: MasterCompositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterCompositions to fetch.
     */
    orderBy?: Enumerable<MasterCompositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterCompositions.
     */
    cursor?: MasterCompositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterCompositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterCompositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterCompositions.
     */
    distinct?: Enumerable<MasterCompositionScalarFieldEnum>
  }

  /**
   * MasterComposition findFirst
   */
  export interface MasterCompositionFindFirstArgs extends MasterCompositionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterComposition findFirstOrThrow
   */
  export type MasterCompositionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * Filter, which MasterComposition to fetch.
     */
    where?: MasterCompositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterCompositions to fetch.
     */
    orderBy?: Enumerable<MasterCompositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterCompositions.
     */
    cursor?: MasterCompositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterCompositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterCompositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterCompositions.
     */
    distinct?: Enumerable<MasterCompositionScalarFieldEnum>
  }


  /**
   * MasterComposition findMany
   */
  export type MasterCompositionFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * Filter, which MasterCompositions to fetch.
     */
    where?: MasterCompositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterCompositions to fetch.
     */
    orderBy?: Enumerable<MasterCompositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterCompositions.
     */
    cursor?: MasterCompositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterCompositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterCompositions.
     */
    skip?: number
    distinct?: Enumerable<MasterCompositionScalarFieldEnum>
  }


  /**
   * MasterComposition create
   */
  export type MasterCompositionCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * The data needed to create a MasterComposition.
     */
    data: XOR<MasterCompositionCreateInput, MasterCompositionUncheckedCreateInput>
  }


  /**
   * MasterComposition createMany
   */
  export type MasterCompositionCreateManyArgs = {
    /**
     * The data used to create many MasterCompositions.
     */
    data: Enumerable<MasterCompositionCreateManyInput>
  }


  /**
   * MasterComposition update
   */
  export type MasterCompositionUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * The data needed to update a MasterComposition.
     */
    data: XOR<MasterCompositionUpdateInput, MasterCompositionUncheckedUpdateInput>
    /**
     * Choose, which MasterComposition to update.
     */
    where: MasterCompositionWhereUniqueInput
  }


  /**
   * MasterComposition updateMany
   */
  export type MasterCompositionUpdateManyArgs = {
    /**
     * The data used to update MasterCompositions.
     */
    data: XOR<MasterCompositionUpdateManyMutationInput, MasterCompositionUncheckedUpdateManyInput>
    /**
     * Filter which MasterCompositions to update
     */
    where?: MasterCompositionWhereInput
  }


  /**
   * MasterComposition upsert
   */
  export type MasterCompositionUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * The filter to search for the MasterComposition to update in case it exists.
     */
    where: MasterCompositionWhereUniqueInput
    /**
     * In case the MasterComposition found by the `where` argument doesn't exist, create a new MasterComposition with this data.
     */
    create: XOR<MasterCompositionCreateInput, MasterCompositionUncheckedCreateInput>
    /**
     * In case the MasterComposition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterCompositionUpdateInput, MasterCompositionUncheckedUpdateInput>
  }


  /**
   * MasterComposition delete
   */
  export type MasterCompositionDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
    /**
     * Filter which MasterComposition to delete.
     */
    where: MasterCompositionWhereUniqueInput
  }


  /**
   * MasterComposition deleteMany
   */
  export type MasterCompositionDeleteManyArgs = {
    /**
     * Filter which MasterCompositions to delete
     */
    where?: MasterCompositionWhereInput
  }


  /**
   * MasterComposition without action
   */
  export type MasterCompositionArgs = {
    /**
     * Select specific fields to fetch from the MasterComposition
     */
    select?: MasterCompositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterCompositionInclude | null
  }



  /**
   * Model MasterDistributionPartner
   */


  export type AggregateMasterDistributionPartner = {
    _count: MasterDistributionPartnerCountAggregateOutputType | null
    _avg: MasterDistributionPartnerAvgAggregateOutputType | null
    _sum: MasterDistributionPartnerSumAggregateOutputType | null
    _min: MasterDistributionPartnerMinAggregateOutputType | null
    _max: MasterDistributionPartnerMaxAggregateOutputType | null
  }

  export type MasterDistributionPartnerAvgAggregateOutputType = {
    id: number | null
    isActive: number | null
  }

  export type MasterDistributionPartnerSumAggregateOutputType = {
    id: number | null
    isActive: number | null
  }

  export type MasterDistributionPartnerMinAggregateOutputType = {
    id: number | null
    nameDist: string | null
    isActive: number | null
  }

  export type MasterDistributionPartnerMaxAggregateOutputType = {
    id: number | null
    nameDist: string | null
    isActive: number | null
  }

  export type MasterDistributionPartnerCountAggregateOutputType = {
    id: number
    nameDist: number
    isActive: number
    _all: number
  }


  export type MasterDistributionPartnerAvgAggregateInputType = {
    id?: true
    isActive?: true
  }

  export type MasterDistributionPartnerSumAggregateInputType = {
    id?: true
    isActive?: true
  }

  export type MasterDistributionPartnerMinAggregateInputType = {
    id?: true
    nameDist?: true
    isActive?: true
  }

  export type MasterDistributionPartnerMaxAggregateInputType = {
    id?: true
    nameDist?: true
    isActive?: true
  }

  export type MasterDistributionPartnerCountAggregateInputType = {
    id?: true
    nameDist?: true
    isActive?: true
    _all?: true
  }

  export type MasterDistributionPartnerAggregateArgs = {
    /**
     * Filter which MasterDistributionPartner to aggregate.
     */
    where?: MasterDistributionPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDistributionPartners to fetch.
     */
    orderBy?: Enumerable<MasterDistributionPartnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterDistributionPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDistributionPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDistributionPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterDistributionPartners
    **/
    _count?: true | MasterDistributionPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterDistributionPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterDistributionPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterDistributionPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterDistributionPartnerMaxAggregateInputType
  }

  export type GetMasterDistributionPartnerAggregateType<T extends MasterDistributionPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterDistributionPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterDistributionPartner[P]>
      : GetScalarType<T[P], AggregateMasterDistributionPartner[P]>
  }




  export type MasterDistributionPartnerGroupByArgs = {
    where?: MasterDistributionPartnerWhereInput
    orderBy?: Enumerable<MasterDistributionPartnerOrderByWithAggregationInput>
    by: MasterDistributionPartnerScalarFieldEnum[]
    having?: MasterDistributionPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterDistributionPartnerCountAggregateInputType | true
    _avg?: MasterDistributionPartnerAvgAggregateInputType
    _sum?: MasterDistributionPartnerSumAggregateInputType
    _min?: MasterDistributionPartnerMinAggregateInputType
    _max?: MasterDistributionPartnerMaxAggregateInputType
  }


  export type MasterDistributionPartnerGroupByOutputType = {
    id: number
    nameDist: string
    isActive: number
    _count: MasterDistributionPartnerCountAggregateOutputType | null
    _avg: MasterDistributionPartnerAvgAggregateOutputType | null
    _sum: MasterDistributionPartnerSumAggregateOutputType | null
    _min: MasterDistributionPartnerMinAggregateOutputType | null
    _max: MasterDistributionPartnerMaxAggregateOutputType | null
  }

  type GetMasterDistributionPartnerGroupByPayload<T extends MasterDistributionPartnerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterDistributionPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterDistributionPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterDistributionPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], MasterDistributionPartnerGroupByOutputType[P]>
        }
      >
    >


  export type MasterDistributionPartnerSelect = {
    id?: boolean
    nameDist?: boolean
    isActive?: boolean
  }


  export type MasterDistributionPartnerGetPayload<S extends boolean | null | undefined | MasterDistributionPartnerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterDistributionPartner :
    S extends undefined ? never :
    S extends { include: any } & (MasterDistributionPartnerArgs | MasterDistributionPartnerFindManyArgs)
    ? MasterDistributionPartner 
    : S extends { select: any } & (MasterDistributionPartnerArgs | MasterDistributionPartnerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MasterDistributionPartner ? MasterDistributionPartner[P] : never
  } 
      : MasterDistributionPartner


  type MasterDistributionPartnerCountArgs = 
    Omit<MasterDistributionPartnerFindManyArgs, 'select' | 'include'> & {
      select?: MasterDistributionPartnerCountAggregateInputType | true
    }

  export interface MasterDistributionPartnerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterDistributionPartner that matches the filter.
     * @param {MasterDistributionPartnerFindUniqueArgs} args - Arguments to find a MasterDistributionPartner
     * @example
     * // Get one MasterDistributionPartner
     * const masterDistributionPartner = await prisma.masterDistributionPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterDistributionPartnerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterDistributionPartnerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterDistributionPartner'> extends True ? Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T>> : Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T> | null, null>

    /**
     * Find one MasterDistributionPartner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterDistributionPartnerFindUniqueOrThrowArgs} args - Arguments to find a MasterDistributionPartner
     * @example
     * // Get one MasterDistributionPartner
     * const masterDistributionPartner = await prisma.masterDistributionPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterDistributionPartnerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterDistributionPartnerFindUniqueOrThrowArgs>
    ): Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T>>

    /**
     * Find the first MasterDistributionPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDistributionPartnerFindFirstArgs} args - Arguments to find a MasterDistributionPartner
     * @example
     * // Get one MasterDistributionPartner
     * const masterDistributionPartner = await prisma.masterDistributionPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterDistributionPartnerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterDistributionPartnerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterDistributionPartner'> extends True ? Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T>> : Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T> | null, null>

    /**
     * Find the first MasterDistributionPartner that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDistributionPartnerFindFirstOrThrowArgs} args - Arguments to find a MasterDistributionPartner
     * @example
     * // Get one MasterDistributionPartner
     * const masterDistributionPartner = await prisma.masterDistributionPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterDistributionPartnerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterDistributionPartnerFindFirstOrThrowArgs>
    ): Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T>>

    /**
     * Find zero or more MasterDistributionPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDistributionPartnerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterDistributionPartners
     * const masterDistributionPartners = await prisma.masterDistributionPartner.findMany()
     * 
     * // Get first 10 MasterDistributionPartners
     * const masterDistributionPartners = await prisma.masterDistributionPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterDistributionPartnerWithIdOnly = await prisma.masterDistributionPartner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterDistributionPartnerFindManyArgs>(
      args?: SelectSubset<T, MasterDistributionPartnerFindManyArgs>
    ): PrismaPromise<Array<MasterDistributionPartnerGetPayload<T>>>

    /**
     * Create a MasterDistributionPartner.
     * @param {MasterDistributionPartnerCreateArgs} args - Arguments to create a MasterDistributionPartner.
     * @example
     * // Create one MasterDistributionPartner
     * const MasterDistributionPartner = await prisma.masterDistributionPartner.create({
     *   data: {
     *     // ... data to create a MasterDistributionPartner
     *   }
     * })
     * 
    **/
    create<T extends MasterDistributionPartnerCreateArgs>(
      args: SelectSubset<T, MasterDistributionPartnerCreateArgs>
    ): Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T>>

    /**
     * Create many MasterDistributionPartners.
     *     @param {MasterDistributionPartnerCreateManyArgs} args - Arguments to create many MasterDistributionPartners.
     *     @example
     *     // Create many MasterDistributionPartners
     *     const masterDistributionPartner = await prisma.masterDistributionPartner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterDistributionPartnerCreateManyArgs>(
      args?: SelectSubset<T, MasterDistributionPartnerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterDistributionPartner.
     * @param {MasterDistributionPartnerDeleteArgs} args - Arguments to delete one MasterDistributionPartner.
     * @example
     * // Delete one MasterDistributionPartner
     * const MasterDistributionPartner = await prisma.masterDistributionPartner.delete({
     *   where: {
     *     // ... filter to delete one MasterDistributionPartner
     *   }
     * })
     * 
    **/
    delete<T extends MasterDistributionPartnerDeleteArgs>(
      args: SelectSubset<T, MasterDistributionPartnerDeleteArgs>
    ): Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T>>

    /**
     * Update one MasterDistributionPartner.
     * @param {MasterDistributionPartnerUpdateArgs} args - Arguments to update one MasterDistributionPartner.
     * @example
     * // Update one MasterDistributionPartner
     * const masterDistributionPartner = await prisma.masterDistributionPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterDistributionPartnerUpdateArgs>(
      args: SelectSubset<T, MasterDistributionPartnerUpdateArgs>
    ): Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T>>

    /**
     * Delete zero or more MasterDistributionPartners.
     * @param {MasterDistributionPartnerDeleteManyArgs} args - Arguments to filter MasterDistributionPartners to delete.
     * @example
     * // Delete a few MasterDistributionPartners
     * const { count } = await prisma.masterDistributionPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterDistributionPartnerDeleteManyArgs>(
      args?: SelectSubset<T, MasterDistributionPartnerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterDistributionPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDistributionPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterDistributionPartners
     * const masterDistributionPartner = await prisma.masterDistributionPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterDistributionPartnerUpdateManyArgs>(
      args: SelectSubset<T, MasterDistributionPartnerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterDistributionPartner.
     * @param {MasterDistributionPartnerUpsertArgs} args - Arguments to update or create a MasterDistributionPartner.
     * @example
     * // Update or create a MasterDistributionPartner
     * const masterDistributionPartner = await prisma.masterDistributionPartner.upsert({
     *   create: {
     *     // ... data to create a MasterDistributionPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterDistributionPartner we want to update
     *   }
     * })
    **/
    upsert<T extends MasterDistributionPartnerUpsertArgs>(
      args: SelectSubset<T, MasterDistributionPartnerUpsertArgs>
    ): Prisma__MasterDistributionPartnerClient<MasterDistributionPartnerGetPayload<T>>

    /**
     * Count the number of MasterDistributionPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDistributionPartnerCountArgs} args - Arguments to filter MasterDistributionPartners to count.
     * @example
     * // Count the number of MasterDistributionPartners
     * const count = await prisma.masterDistributionPartner.count({
     *   where: {
     *     // ... the filter for the MasterDistributionPartners we want to count
     *   }
     * })
    **/
    count<T extends MasterDistributionPartnerCountArgs>(
      args?: Subset<T, MasterDistributionPartnerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterDistributionPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterDistributionPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDistributionPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterDistributionPartnerAggregateArgs>(args: Subset<T, MasterDistributionPartnerAggregateArgs>): PrismaPromise<GetMasterDistributionPartnerAggregateType<T>>

    /**
     * Group by MasterDistributionPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDistributionPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterDistributionPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterDistributionPartnerGroupByArgs['orderBy'] }
        : { orderBy?: MasterDistributionPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterDistributionPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterDistributionPartnerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterDistributionPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterDistributionPartnerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterDistributionPartner base type for findUnique actions
   */
  export type MasterDistributionPartnerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * Filter, which MasterDistributionPartner to fetch.
     */
    where: MasterDistributionPartnerWhereUniqueInput
  }

  /**
   * MasterDistributionPartner findUnique
   */
  export interface MasterDistributionPartnerFindUniqueArgs extends MasterDistributionPartnerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterDistributionPartner findUniqueOrThrow
   */
  export type MasterDistributionPartnerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * Filter, which MasterDistributionPartner to fetch.
     */
    where: MasterDistributionPartnerWhereUniqueInput
  }


  /**
   * MasterDistributionPartner base type for findFirst actions
   */
  export type MasterDistributionPartnerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * Filter, which MasterDistributionPartner to fetch.
     */
    where?: MasterDistributionPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDistributionPartners to fetch.
     */
    orderBy?: Enumerable<MasterDistributionPartnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterDistributionPartners.
     */
    cursor?: MasterDistributionPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDistributionPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDistributionPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterDistributionPartners.
     */
    distinct?: Enumerable<MasterDistributionPartnerScalarFieldEnum>
  }

  /**
   * MasterDistributionPartner findFirst
   */
  export interface MasterDistributionPartnerFindFirstArgs extends MasterDistributionPartnerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterDistributionPartner findFirstOrThrow
   */
  export type MasterDistributionPartnerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * Filter, which MasterDistributionPartner to fetch.
     */
    where?: MasterDistributionPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDistributionPartners to fetch.
     */
    orderBy?: Enumerable<MasterDistributionPartnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterDistributionPartners.
     */
    cursor?: MasterDistributionPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDistributionPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDistributionPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterDistributionPartners.
     */
    distinct?: Enumerable<MasterDistributionPartnerScalarFieldEnum>
  }


  /**
   * MasterDistributionPartner findMany
   */
  export type MasterDistributionPartnerFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * Filter, which MasterDistributionPartners to fetch.
     */
    where?: MasterDistributionPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDistributionPartners to fetch.
     */
    orderBy?: Enumerable<MasterDistributionPartnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterDistributionPartners.
     */
    cursor?: MasterDistributionPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDistributionPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDistributionPartners.
     */
    skip?: number
    distinct?: Enumerable<MasterDistributionPartnerScalarFieldEnum>
  }


  /**
   * MasterDistributionPartner create
   */
  export type MasterDistributionPartnerCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * The data needed to create a MasterDistributionPartner.
     */
    data: XOR<MasterDistributionPartnerCreateInput, MasterDistributionPartnerUncheckedCreateInput>
  }


  /**
   * MasterDistributionPartner createMany
   */
  export type MasterDistributionPartnerCreateManyArgs = {
    /**
     * The data used to create many MasterDistributionPartners.
     */
    data: Enumerable<MasterDistributionPartnerCreateManyInput>
  }


  /**
   * MasterDistributionPartner update
   */
  export type MasterDistributionPartnerUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * The data needed to update a MasterDistributionPartner.
     */
    data: XOR<MasterDistributionPartnerUpdateInput, MasterDistributionPartnerUncheckedUpdateInput>
    /**
     * Choose, which MasterDistributionPartner to update.
     */
    where: MasterDistributionPartnerWhereUniqueInput
  }


  /**
   * MasterDistributionPartner updateMany
   */
  export type MasterDistributionPartnerUpdateManyArgs = {
    /**
     * The data used to update MasterDistributionPartners.
     */
    data: XOR<MasterDistributionPartnerUpdateManyMutationInput, MasterDistributionPartnerUncheckedUpdateManyInput>
    /**
     * Filter which MasterDistributionPartners to update
     */
    where?: MasterDistributionPartnerWhereInput
  }


  /**
   * MasterDistributionPartner upsert
   */
  export type MasterDistributionPartnerUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * The filter to search for the MasterDistributionPartner to update in case it exists.
     */
    where: MasterDistributionPartnerWhereUniqueInput
    /**
     * In case the MasterDistributionPartner found by the `where` argument doesn't exist, create a new MasterDistributionPartner with this data.
     */
    create: XOR<MasterDistributionPartnerCreateInput, MasterDistributionPartnerUncheckedCreateInput>
    /**
     * In case the MasterDistributionPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterDistributionPartnerUpdateInput, MasterDistributionPartnerUncheckedUpdateInput>
  }


  /**
   * MasterDistributionPartner delete
   */
  export type MasterDistributionPartnerDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
    /**
     * Filter which MasterDistributionPartner to delete.
     */
    where: MasterDistributionPartnerWhereUniqueInput
  }


  /**
   * MasterDistributionPartner deleteMany
   */
  export type MasterDistributionPartnerDeleteManyArgs = {
    /**
     * Filter which MasterDistributionPartners to delete
     */
    where?: MasterDistributionPartnerWhereInput
  }


  /**
   * MasterDistributionPartner without action
   */
  export type MasterDistributionPartnerArgs = {
    /**
     * Select specific fields to fetch from the MasterDistributionPartner
     */
    select?: MasterDistributionPartnerSelect | null
  }



  /**
   * Model MarketSurveyRequest
   */


  export type AggregateMarketSurveyRequest = {
    _count: MarketSurveyRequestCountAggregateOutputType | null
    _avg: MarketSurveyRequestAvgAggregateOutputType | null
    _sum: MarketSurveyRequestSumAggregateOutputType | null
    _min: MarketSurveyRequestMinAggregateOutputType | null
    _max: MarketSurveyRequestMaxAggregateOutputType | null
  }

  export type MarketSurveyRequestAvgAggregateOutputType = {
    idBrand: number | null
  }

  export type MarketSurveyRequestSumAggregateOutputType = {
    idBrand: number | null
  }

  export type MarketSurveyRequestMinAggregateOutputType = {
    id: string | null
    numberDocument: string | null
    type: string | null
    idBrand: number | null
    country: string | null
    brand: string | null
    dosageForm: string | null
    date: Date | null
    originatorBrand: string | null
    originatorCompany: string | null
    statusForm: string | null
    approvedIdUser: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    createdBy: string | null
  }

  export type MarketSurveyRequestMaxAggregateOutputType = {
    id: string | null
    numberDocument: string | null
    type: string | null
    idBrand: number | null
    country: string | null
    brand: string | null
    dosageForm: string | null
    date: Date | null
    originatorBrand: string | null
    originatorCompany: string | null
    statusForm: string | null
    approvedIdUser: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    createdBy: string | null
  }

  export type MarketSurveyRequestCountAggregateOutputType = {
    id: number
    numberDocument: number
    type: number
    idBrand: number
    country: number
    brand: number
    dosageForm: number
    date: number
    originatorBrand: number
    originatorCompany: number
    statusForm: number
    approvedIdUser: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    createdBy: number
    _all: number
  }


  export type MarketSurveyRequestAvgAggregateInputType = {
    idBrand?: true
  }

  export type MarketSurveyRequestSumAggregateInputType = {
    idBrand?: true
  }

  export type MarketSurveyRequestMinAggregateInputType = {
    id?: true
    numberDocument?: true
    type?: true
    idBrand?: true
    country?: true
    brand?: true
    dosageForm?: true
    date?: true
    originatorBrand?: true
    originatorCompany?: true
    statusForm?: true
    approvedIdUser?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
  }

  export type MarketSurveyRequestMaxAggregateInputType = {
    id?: true
    numberDocument?: true
    type?: true
    idBrand?: true
    country?: true
    brand?: true
    dosageForm?: true
    date?: true
    originatorBrand?: true
    originatorCompany?: true
    statusForm?: true
    approvedIdUser?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
  }

  export type MarketSurveyRequestCountAggregateInputType = {
    id?: true
    numberDocument?: true
    type?: true
    idBrand?: true
    country?: true
    brand?: true
    dosageForm?: true
    date?: true
    originatorBrand?: true
    originatorCompany?: true
    statusForm?: true
    approvedIdUser?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
    _all?: true
  }

  export type MarketSurveyRequestAggregateArgs = {
    /**
     * Filter which MarketSurveyRequest to aggregate.
     */
    where?: MarketSurveyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyRequests to fetch.
     */
    orderBy?: Enumerable<MarketSurveyRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketSurveyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketSurveyRequests
    **/
    _count?: true | MarketSurveyRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketSurveyRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketSurveyRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketSurveyRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketSurveyRequestMaxAggregateInputType
  }

  export type GetMarketSurveyRequestAggregateType<T extends MarketSurveyRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketSurveyRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketSurveyRequest[P]>
      : GetScalarType<T[P], AggregateMarketSurveyRequest[P]>
  }




  export type MarketSurveyRequestGroupByArgs = {
    where?: MarketSurveyRequestWhereInput
    orderBy?: Enumerable<MarketSurveyRequestOrderByWithAggregationInput>
    by: MarketSurveyRequestScalarFieldEnum[]
    having?: MarketSurveyRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketSurveyRequestCountAggregateInputType | true
    _avg?: MarketSurveyRequestAvgAggregateInputType
    _sum?: MarketSurveyRequestSumAggregateInputType
    _min?: MarketSurveyRequestMinAggregateInputType
    _max?: MarketSurveyRequestMaxAggregateInputType
  }


  export type MarketSurveyRequestGroupByOutputType = {
    id: string
    numberDocument: string
    type: string
    idBrand: number
    country: string
    brand: string
    dosageForm: string
    date: Date
    originatorBrand: string
    originatorCompany: string
    statusForm: string
    approvedIdUser: string
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    createdBy: string | null
    _count: MarketSurveyRequestCountAggregateOutputType | null
    _avg: MarketSurveyRequestAvgAggregateOutputType | null
    _sum: MarketSurveyRequestSumAggregateOutputType | null
    _min: MarketSurveyRequestMinAggregateOutputType | null
    _max: MarketSurveyRequestMaxAggregateOutputType | null
  }

  type GetMarketSurveyRequestGroupByPayload<T extends MarketSurveyRequestGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MarketSurveyRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketSurveyRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketSurveyRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MarketSurveyRequestGroupByOutputType[P]>
        }
      >
    >


  export type MarketSurveyRequestSelect = {
    id?: boolean
    numberDocument?: boolean
    type?: boolean
    idBrand?: boolean
    country?: boolean
    brand?: boolean
    dosageForm?: boolean
    date?: boolean
    originatorBrand?: boolean
    originatorCompany?: boolean
    statusForm?: boolean
    approvedIdUser?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    createdBy?: boolean
  }


  export type MarketSurveyRequestGetPayload<S extends boolean | null | undefined | MarketSurveyRequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MarketSurveyRequest :
    S extends undefined ? never :
    S extends { include: any } & (MarketSurveyRequestArgs | MarketSurveyRequestFindManyArgs)
    ? MarketSurveyRequest 
    : S extends { select: any } & (MarketSurveyRequestArgs | MarketSurveyRequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MarketSurveyRequest ? MarketSurveyRequest[P] : never
  } 
      : MarketSurveyRequest


  type MarketSurveyRequestCountArgs = 
    Omit<MarketSurveyRequestFindManyArgs, 'select' | 'include'> & {
      select?: MarketSurveyRequestCountAggregateInputType | true
    }

  export interface MarketSurveyRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MarketSurveyRequest that matches the filter.
     * @param {MarketSurveyRequestFindUniqueArgs} args - Arguments to find a MarketSurveyRequest
     * @example
     * // Get one MarketSurveyRequest
     * const marketSurveyRequest = await prisma.marketSurveyRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarketSurveyRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarketSurveyRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MarketSurveyRequest'> extends True ? Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T>> : Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T> | null, null>

    /**
     * Find one MarketSurveyRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarketSurveyRequestFindUniqueOrThrowArgs} args - Arguments to find a MarketSurveyRequest
     * @example
     * // Get one MarketSurveyRequest
     * const marketSurveyRequest = await prisma.marketSurveyRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarketSurveyRequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MarketSurveyRequestFindUniqueOrThrowArgs>
    ): Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T>>

    /**
     * Find the first MarketSurveyRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyRequestFindFirstArgs} args - Arguments to find a MarketSurveyRequest
     * @example
     * // Get one MarketSurveyRequest
     * const marketSurveyRequest = await prisma.marketSurveyRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarketSurveyRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarketSurveyRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MarketSurveyRequest'> extends True ? Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T>> : Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T> | null, null>

    /**
     * Find the first MarketSurveyRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyRequestFindFirstOrThrowArgs} args - Arguments to find a MarketSurveyRequest
     * @example
     * // Get one MarketSurveyRequest
     * const marketSurveyRequest = await prisma.marketSurveyRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarketSurveyRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MarketSurveyRequestFindFirstOrThrowArgs>
    ): Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T>>

    /**
     * Find zero or more MarketSurveyRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketSurveyRequests
     * const marketSurveyRequests = await prisma.marketSurveyRequest.findMany()
     * 
     * // Get first 10 MarketSurveyRequests
     * const marketSurveyRequests = await prisma.marketSurveyRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketSurveyRequestWithIdOnly = await prisma.marketSurveyRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MarketSurveyRequestFindManyArgs>(
      args?: SelectSubset<T, MarketSurveyRequestFindManyArgs>
    ): PrismaPromise<Array<MarketSurveyRequestGetPayload<T>>>

    /**
     * Create a MarketSurveyRequest.
     * @param {MarketSurveyRequestCreateArgs} args - Arguments to create a MarketSurveyRequest.
     * @example
     * // Create one MarketSurveyRequest
     * const MarketSurveyRequest = await prisma.marketSurveyRequest.create({
     *   data: {
     *     // ... data to create a MarketSurveyRequest
     *   }
     * })
     * 
    **/
    create<T extends MarketSurveyRequestCreateArgs>(
      args: SelectSubset<T, MarketSurveyRequestCreateArgs>
    ): Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T>>

    /**
     * Create many MarketSurveyRequests.
     *     @param {MarketSurveyRequestCreateManyArgs} args - Arguments to create many MarketSurveyRequests.
     *     @example
     *     // Create many MarketSurveyRequests
     *     const marketSurveyRequest = await prisma.marketSurveyRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarketSurveyRequestCreateManyArgs>(
      args?: SelectSubset<T, MarketSurveyRequestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MarketSurveyRequest.
     * @param {MarketSurveyRequestDeleteArgs} args - Arguments to delete one MarketSurveyRequest.
     * @example
     * // Delete one MarketSurveyRequest
     * const MarketSurveyRequest = await prisma.marketSurveyRequest.delete({
     *   where: {
     *     // ... filter to delete one MarketSurveyRequest
     *   }
     * })
     * 
    **/
    delete<T extends MarketSurveyRequestDeleteArgs>(
      args: SelectSubset<T, MarketSurveyRequestDeleteArgs>
    ): Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T>>

    /**
     * Update one MarketSurveyRequest.
     * @param {MarketSurveyRequestUpdateArgs} args - Arguments to update one MarketSurveyRequest.
     * @example
     * // Update one MarketSurveyRequest
     * const marketSurveyRequest = await prisma.marketSurveyRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarketSurveyRequestUpdateArgs>(
      args: SelectSubset<T, MarketSurveyRequestUpdateArgs>
    ): Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T>>

    /**
     * Delete zero or more MarketSurveyRequests.
     * @param {MarketSurveyRequestDeleteManyArgs} args - Arguments to filter MarketSurveyRequests to delete.
     * @example
     * // Delete a few MarketSurveyRequests
     * const { count } = await prisma.marketSurveyRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarketSurveyRequestDeleteManyArgs>(
      args?: SelectSubset<T, MarketSurveyRequestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketSurveyRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketSurveyRequests
     * const marketSurveyRequest = await prisma.marketSurveyRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarketSurveyRequestUpdateManyArgs>(
      args: SelectSubset<T, MarketSurveyRequestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketSurveyRequest.
     * @param {MarketSurveyRequestUpsertArgs} args - Arguments to update or create a MarketSurveyRequest.
     * @example
     * // Update or create a MarketSurveyRequest
     * const marketSurveyRequest = await prisma.marketSurveyRequest.upsert({
     *   create: {
     *     // ... data to create a MarketSurveyRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketSurveyRequest we want to update
     *   }
     * })
    **/
    upsert<T extends MarketSurveyRequestUpsertArgs>(
      args: SelectSubset<T, MarketSurveyRequestUpsertArgs>
    ): Prisma__MarketSurveyRequestClient<MarketSurveyRequestGetPayload<T>>

    /**
     * Count the number of MarketSurveyRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyRequestCountArgs} args - Arguments to filter MarketSurveyRequests to count.
     * @example
     * // Count the number of MarketSurveyRequests
     * const count = await prisma.marketSurveyRequest.count({
     *   where: {
     *     // ... the filter for the MarketSurveyRequests we want to count
     *   }
     * })
    **/
    count<T extends MarketSurveyRequestCountArgs>(
      args?: Subset<T, MarketSurveyRequestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketSurveyRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketSurveyRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketSurveyRequestAggregateArgs>(args: Subset<T, MarketSurveyRequestAggregateArgs>): PrismaPromise<GetMarketSurveyRequestAggregateType<T>>

    /**
     * Group by MarketSurveyRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketSurveyRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketSurveyRequestGroupByArgs['orderBy'] }
        : { orderBy?: MarketSurveyRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketSurveyRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketSurveyRequestGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketSurveyRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarketSurveyRequestClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MarketSurveyRequest base type for findUnique actions
   */
  export type MarketSurveyRequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * Filter, which MarketSurveyRequest to fetch.
     */
    where: MarketSurveyRequestWhereUniqueInput
  }

  /**
   * MarketSurveyRequest findUnique
   */
  export interface MarketSurveyRequestFindUniqueArgs extends MarketSurveyRequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketSurveyRequest findUniqueOrThrow
   */
  export type MarketSurveyRequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * Filter, which MarketSurveyRequest to fetch.
     */
    where: MarketSurveyRequestWhereUniqueInput
  }


  /**
   * MarketSurveyRequest base type for findFirst actions
   */
  export type MarketSurveyRequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * Filter, which MarketSurveyRequest to fetch.
     */
    where?: MarketSurveyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyRequests to fetch.
     */
    orderBy?: Enumerable<MarketSurveyRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSurveyRequests.
     */
    cursor?: MarketSurveyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSurveyRequests.
     */
    distinct?: Enumerable<MarketSurveyRequestScalarFieldEnum>
  }

  /**
   * MarketSurveyRequest findFirst
   */
  export interface MarketSurveyRequestFindFirstArgs extends MarketSurveyRequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketSurveyRequest findFirstOrThrow
   */
  export type MarketSurveyRequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * Filter, which MarketSurveyRequest to fetch.
     */
    where?: MarketSurveyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyRequests to fetch.
     */
    orderBy?: Enumerable<MarketSurveyRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSurveyRequests.
     */
    cursor?: MarketSurveyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSurveyRequests.
     */
    distinct?: Enumerable<MarketSurveyRequestScalarFieldEnum>
  }


  /**
   * MarketSurveyRequest findMany
   */
  export type MarketSurveyRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * Filter, which MarketSurveyRequests to fetch.
     */
    where?: MarketSurveyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyRequests to fetch.
     */
    orderBy?: Enumerable<MarketSurveyRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketSurveyRequests.
     */
    cursor?: MarketSurveyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyRequests.
     */
    skip?: number
    distinct?: Enumerable<MarketSurveyRequestScalarFieldEnum>
  }


  /**
   * MarketSurveyRequest create
   */
  export type MarketSurveyRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * The data needed to create a MarketSurveyRequest.
     */
    data: XOR<MarketSurveyRequestCreateInput, MarketSurveyRequestUncheckedCreateInput>
  }


  /**
   * MarketSurveyRequest createMany
   */
  export type MarketSurveyRequestCreateManyArgs = {
    /**
     * The data used to create many MarketSurveyRequests.
     */
    data: Enumerable<MarketSurveyRequestCreateManyInput>
  }


  /**
   * MarketSurveyRequest update
   */
  export type MarketSurveyRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * The data needed to update a MarketSurveyRequest.
     */
    data: XOR<MarketSurveyRequestUpdateInput, MarketSurveyRequestUncheckedUpdateInput>
    /**
     * Choose, which MarketSurveyRequest to update.
     */
    where: MarketSurveyRequestWhereUniqueInput
  }


  /**
   * MarketSurveyRequest updateMany
   */
  export type MarketSurveyRequestUpdateManyArgs = {
    /**
     * The data used to update MarketSurveyRequests.
     */
    data: XOR<MarketSurveyRequestUpdateManyMutationInput, MarketSurveyRequestUncheckedUpdateManyInput>
    /**
     * Filter which MarketSurveyRequests to update
     */
    where?: MarketSurveyRequestWhereInput
  }


  /**
   * MarketSurveyRequest upsert
   */
  export type MarketSurveyRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * The filter to search for the MarketSurveyRequest to update in case it exists.
     */
    where: MarketSurveyRequestWhereUniqueInput
    /**
     * In case the MarketSurveyRequest found by the `where` argument doesn't exist, create a new MarketSurveyRequest with this data.
     */
    create: XOR<MarketSurveyRequestCreateInput, MarketSurveyRequestUncheckedCreateInput>
    /**
     * In case the MarketSurveyRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketSurveyRequestUpdateInput, MarketSurveyRequestUncheckedUpdateInput>
  }


  /**
   * MarketSurveyRequest delete
   */
  export type MarketSurveyRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
    /**
     * Filter which MarketSurveyRequest to delete.
     */
    where: MarketSurveyRequestWhereUniqueInput
  }


  /**
   * MarketSurveyRequest deleteMany
   */
  export type MarketSurveyRequestDeleteManyArgs = {
    /**
     * Filter which MarketSurveyRequests to delete
     */
    where?: MarketSurveyRequestWhereInput
  }


  /**
   * MarketSurveyRequest without action
   */
  export type MarketSurveyRequestArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyRequest
     */
    select?: MarketSurveyRequestSelect | null
  }



  /**
   * Model MarketSurvey
   */


  export type AggregateMarketSurvey = {
    _count: MarketSurveyCountAggregateOutputType | null
    _min: MarketSurveyMinAggregateOutputType | null
    _max: MarketSurveyMaxAggregateOutputType | null
  }

  export type MarketSurveyMinAggregateOutputType = {
    id: string | null
    numberDocument: string | null
    pic: string | null
    date: Date | null
    priceSurveyed: string | null
    statusForm: string | null
    approvedIdUser: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    createdBy: string | null
  }

  export type MarketSurveyMaxAggregateOutputType = {
    id: string | null
    numberDocument: string | null
    pic: string | null
    date: Date | null
    priceSurveyed: string | null
    statusForm: string | null
    approvedIdUser: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    createdBy: string | null
  }

  export type MarketSurveyCountAggregateOutputType = {
    id: number
    numberDocument: number
    pic: number
    date: number
    priceSurveyed: number
    statusForm: number
    approvedIdUser: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    createdBy: number
    _all: number
  }


  export type MarketSurveyMinAggregateInputType = {
    id?: true
    numberDocument?: true
    pic?: true
    date?: true
    priceSurveyed?: true
    statusForm?: true
    approvedIdUser?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
  }

  export type MarketSurveyMaxAggregateInputType = {
    id?: true
    numberDocument?: true
    pic?: true
    date?: true
    priceSurveyed?: true
    statusForm?: true
    approvedIdUser?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
  }

  export type MarketSurveyCountAggregateInputType = {
    id?: true
    numberDocument?: true
    pic?: true
    date?: true
    priceSurveyed?: true
    statusForm?: true
    approvedIdUser?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
    _all?: true
  }

  export type MarketSurveyAggregateArgs = {
    /**
     * Filter which MarketSurvey to aggregate.
     */
    where?: MarketSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveys to fetch.
     */
    orderBy?: Enumerable<MarketSurveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketSurveys
    **/
    _count?: true | MarketSurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketSurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketSurveyMaxAggregateInputType
  }

  export type GetMarketSurveyAggregateType<T extends MarketSurveyAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketSurvey[P]>
      : GetScalarType<T[P], AggregateMarketSurvey[P]>
  }




  export type MarketSurveyGroupByArgs = {
    where?: MarketSurveyWhereInput
    orderBy?: Enumerable<MarketSurveyOrderByWithAggregationInput>
    by: MarketSurveyScalarFieldEnum[]
    having?: MarketSurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketSurveyCountAggregateInputType | true
    _min?: MarketSurveyMinAggregateInputType
    _max?: MarketSurveyMaxAggregateInputType
  }


  export type MarketSurveyGroupByOutputType = {
    id: string
    numberDocument: string
    pic: string
    date: Date
    priceSurveyed: string
    statusForm: string
    approvedIdUser: string
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    createdBy: string | null
    _count: MarketSurveyCountAggregateOutputType | null
    _min: MarketSurveyMinAggregateOutputType | null
    _max: MarketSurveyMaxAggregateOutputType | null
  }

  type GetMarketSurveyGroupByPayload<T extends MarketSurveyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MarketSurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketSurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketSurveyGroupByOutputType[P]>
            : GetScalarType<T[P], MarketSurveyGroupByOutputType[P]>
        }
      >
    >


  export type MarketSurveySelect = {
    id?: boolean
    numberDocument?: boolean
    pic?: boolean
    date?: boolean
    priceSurveyed?: boolean
    statusForm?: boolean
    approvedIdUser?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    createdBy?: boolean
    marketSurveyDetail?: boolean | MarketSurvey$marketSurveyDetailArgs
    _count?: boolean | MarketSurveyCountOutputTypeArgs
  }


  export type MarketSurveyInclude = {
    marketSurveyDetail?: boolean | MarketSurvey$marketSurveyDetailArgs
    _count?: boolean | MarketSurveyCountOutputTypeArgs
  }

  export type MarketSurveyGetPayload<S extends boolean | null | undefined | MarketSurveyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MarketSurvey :
    S extends undefined ? never :
    S extends { include: any } & (MarketSurveyArgs | MarketSurveyFindManyArgs)
    ? MarketSurvey  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'marketSurveyDetail' ? Array < MarketSurveyDetailGetPayload<S['include'][P]>>  :
        P extends '_count' ? MarketSurveyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MarketSurveyArgs | MarketSurveyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'marketSurveyDetail' ? Array < MarketSurveyDetailGetPayload<S['select'][P]>>  :
        P extends '_count' ? MarketSurveyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MarketSurvey ? MarketSurvey[P] : never
  } 
      : MarketSurvey


  type MarketSurveyCountArgs = 
    Omit<MarketSurveyFindManyArgs, 'select' | 'include'> & {
      select?: MarketSurveyCountAggregateInputType | true
    }

  export interface MarketSurveyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MarketSurvey that matches the filter.
     * @param {MarketSurveyFindUniqueArgs} args - Arguments to find a MarketSurvey
     * @example
     * // Get one MarketSurvey
     * const marketSurvey = await prisma.marketSurvey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarketSurveyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarketSurveyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MarketSurvey'> extends True ? Prisma__MarketSurveyClient<MarketSurveyGetPayload<T>> : Prisma__MarketSurveyClient<MarketSurveyGetPayload<T> | null, null>

    /**
     * Find one MarketSurvey that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarketSurveyFindUniqueOrThrowArgs} args - Arguments to find a MarketSurvey
     * @example
     * // Get one MarketSurvey
     * const marketSurvey = await prisma.marketSurvey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarketSurveyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MarketSurveyFindUniqueOrThrowArgs>
    ): Prisma__MarketSurveyClient<MarketSurveyGetPayload<T>>

    /**
     * Find the first MarketSurvey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyFindFirstArgs} args - Arguments to find a MarketSurvey
     * @example
     * // Get one MarketSurvey
     * const marketSurvey = await prisma.marketSurvey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarketSurveyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarketSurveyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MarketSurvey'> extends True ? Prisma__MarketSurveyClient<MarketSurveyGetPayload<T>> : Prisma__MarketSurveyClient<MarketSurveyGetPayload<T> | null, null>

    /**
     * Find the first MarketSurvey that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyFindFirstOrThrowArgs} args - Arguments to find a MarketSurvey
     * @example
     * // Get one MarketSurvey
     * const marketSurvey = await prisma.marketSurvey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarketSurveyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MarketSurveyFindFirstOrThrowArgs>
    ): Prisma__MarketSurveyClient<MarketSurveyGetPayload<T>>

    /**
     * Find zero or more MarketSurveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketSurveys
     * const marketSurveys = await prisma.marketSurvey.findMany()
     * 
     * // Get first 10 MarketSurveys
     * const marketSurveys = await prisma.marketSurvey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketSurveyWithIdOnly = await prisma.marketSurvey.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MarketSurveyFindManyArgs>(
      args?: SelectSubset<T, MarketSurveyFindManyArgs>
    ): PrismaPromise<Array<MarketSurveyGetPayload<T>>>

    /**
     * Create a MarketSurvey.
     * @param {MarketSurveyCreateArgs} args - Arguments to create a MarketSurvey.
     * @example
     * // Create one MarketSurvey
     * const MarketSurvey = await prisma.marketSurvey.create({
     *   data: {
     *     // ... data to create a MarketSurvey
     *   }
     * })
     * 
    **/
    create<T extends MarketSurveyCreateArgs>(
      args: SelectSubset<T, MarketSurveyCreateArgs>
    ): Prisma__MarketSurveyClient<MarketSurveyGetPayload<T>>

    /**
     * Create many MarketSurveys.
     *     @param {MarketSurveyCreateManyArgs} args - Arguments to create many MarketSurveys.
     *     @example
     *     // Create many MarketSurveys
     *     const marketSurvey = await prisma.marketSurvey.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarketSurveyCreateManyArgs>(
      args?: SelectSubset<T, MarketSurveyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MarketSurvey.
     * @param {MarketSurveyDeleteArgs} args - Arguments to delete one MarketSurvey.
     * @example
     * // Delete one MarketSurvey
     * const MarketSurvey = await prisma.marketSurvey.delete({
     *   where: {
     *     // ... filter to delete one MarketSurvey
     *   }
     * })
     * 
    **/
    delete<T extends MarketSurveyDeleteArgs>(
      args: SelectSubset<T, MarketSurveyDeleteArgs>
    ): Prisma__MarketSurveyClient<MarketSurveyGetPayload<T>>

    /**
     * Update one MarketSurvey.
     * @param {MarketSurveyUpdateArgs} args - Arguments to update one MarketSurvey.
     * @example
     * // Update one MarketSurvey
     * const marketSurvey = await prisma.marketSurvey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarketSurveyUpdateArgs>(
      args: SelectSubset<T, MarketSurveyUpdateArgs>
    ): Prisma__MarketSurveyClient<MarketSurveyGetPayload<T>>

    /**
     * Delete zero or more MarketSurveys.
     * @param {MarketSurveyDeleteManyArgs} args - Arguments to filter MarketSurveys to delete.
     * @example
     * // Delete a few MarketSurveys
     * const { count } = await prisma.marketSurvey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarketSurveyDeleteManyArgs>(
      args?: SelectSubset<T, MarketSurveyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketSurveys
     * const marketSurvey = await prisma.marketSurvey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarketSurveyUpdateManyArgs>(
      args: SelectSubset<T, MarketSurveyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketSurvey.
     * @param {MarketSurveyUpsertArgs} args - Arguments to update or create a MarketSurvey.
     * @example
     * // Update or create a MarketSurvey
     * const marketSurvey = await prisma.marketSurvey.upsert({
     *   create: {
     *     // ... data to create a MarketSurvey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketSurvey we want to update
     *   }
     * })
    **/
    upsert<T extends MarketSurveyUpsertArgs>(
      args: SelectSubset<T, MarketSurveyUpsertArgs>
    ): Prisma__MarketSurveyClient<MarketSurveyGetPayload<T>>

    /**
     * Count the number of MarketSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyCountArgs} args - Arguments to filter MarketSurveys to count.
     * @example
     * // Count the number of MarketSurveys
     * const count = await prisma.marketSurvey.count({
     *   where: {
     *     // ... the filter for the MarketSurveys we want to count
     *   }
     * })
    **/
    count<T extends MarketSurveyCountArgs>(
      args?: Subset<T, MarketSurveyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketSurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketSurveyAggregateArgs>(args: Subset<T, MarketSurveyAggregateArgs>): PrismaPromise<GetMarketSurveyAggregateType<T>>

    /**
     * Group by MarketSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketSurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketSurveyGroupByArgs['orderBy'] }
        : { orderBy?: MarketSurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketSurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketSurveyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketSurvey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarketSurveyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    marketSurveyDetail<T extends MarketSurvey$marketSurveyDetailArgs= {}>(args?: Subset<T, MarketSurvey$marketSurveyDetailArgs>): PrismaPromise<Array<MarketSurveyDetailGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MarketSurvey base type for findUnique actions
   */
  export type MarketSurveyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * Filter, which MarketSurvey to fetch.
     */
    where: MarketSurveyWhereUniqueInput
  }

  /**
   * MarketSurvey findUnique
   */
  export interface MarketSurveyFindUniqueArgs extends MarketSurveyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketSurvey findUniqueOrThrow
   */
  export type MarketSurveyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * Filter, which MarketSurvey to fetch.
     */
    where: MarketSurveyWhereUniqueInput
  }


  /**
   * MarketSurvey base type for findFirst actions
   */
  export type MarketSurveyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * Filter, which MarketSurvey to fetch.
     */
    where?: MarketSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveys to fetch.
     */
    orderBy?: Enumerable<MarketSurveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSurveys.
     */
    cursor?: MarketSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSurveys.
     */
    distinct?: Enumerable<MarketSurveyScalarFieldEnum>
  }

  /**
   * MarketSurvey findFirst
   */
  export interface MarketSurveyFindFirstArgs extends MarketSurveyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketSurvey findFirstOrThrow
   */
  export type MarketSurveyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * Filter, which MarketSurvey to fetch.
     */
    where?: MarketSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveys to fetch.
     */
    orderBy?: Enumerable<MarketSurveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSurveys.
     */
    cursor?: MarketSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSurveys.
     */
    distinct?: Enumerable<MarketSurveyScalarFieldEnum>
  }


  /**
   * MarketSurvey findMany
   */
  export type MarketSurveyFindManyArgs = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * Filter, which MarketSurveys to fetch.
     */
    where?: MarketSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveys to fetch.
     */
    orderBy?: Enumerable<MarketSurveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketSurveys.
     */
    cursor?: MarketSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveys.
     */
    skip?: number
    distinct?: Enumerable<MarketSurveyScalarFieldEnum>
  }


  /**
   * MarketSurvey create
   */
  export type MarketSurveyCreateArgs = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * The data needed to create a MarketSurvey.
     */
    data: XOR<MarketSurveyCreateInput, MarketSurveyUncheckedCreateInput>
  }


  /**
   * MarketSurvey createMany
   */
  export type MarketSurveyCreateManyArgs = {
    /**
     * The data used to create many MarketSurveys.
     */
    data: Enumerable<MarketSurveyCreateManyInput>
  }


  /**
   * MarketSurvey update
   */
  export type MarketSurveyUpdateArgs = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * The data needed to update a MarketSurvey.
     */
    data: XOR<MarketSurveyUpdateInput, MarketSurveyUncheckedUpdateInput>
    /**
     * Choose, which MarketSurvey to update.
     */
    where: MarketSurveyWhereUniqueInput
  }


  /**
   * MarketSurvey updateMany
   */
  export type MarketSurveyUpdateManyArgs = {
    /**
     * The data used to update MarketSurveys.
     */
    data: XOR<MarketSurveyUpdateManyMutationInput, MarketSurveyUncheckedUpdateManyInput>
    /**
     * Filter which MarketSurveys to update
     */
    where?: MarketSurveyWhereInput
  }


  /**
   * MarketSurvey upsert
   */
  export type MarketSurveyUpsertArgs = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * The filter to search for the MarketSurvey to update in case it exists.
     */
    where: MarketSurveyWhereUniqueInput
    /**
     * In case the MarketSurvey found by the `where` argument doesn't exist, create a new MarketSurvey with this data.
     */
    create: XOR<MarketSurveyCreateInput, MarketSurveyUncheckedCreateInput>
    /**
     * In case the MarketSurvey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketSurveyUpdateInput, MarketSurveyUncheckedUpdateInput>
  }


  /**
   * MarketSurvey delete
   */
  export type MarketSurveyDeleteArgs = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
    /**
     * Filter which MarketSurvey to delete.
     */
    where: MarketSurveyWhereUniqueInput
  }


  /**
   * MarketSurvey deleteMany
   */
  export type MarketSurveyDeleteManyArgs = {
    /**
     * Filter which MarketSurveys to delete
     */
    where?: MarketSurveyWhereInput
  }


  /**
   * MarketSurvey.marketSurveyDetail
   */
  export type MarketSurvey$marketSurveyDetailArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    where?: MarketSurveyDetailWhereInput
    orderBy?: Enumerable<MarketSurveyDetailOrderByWithRelationInput>
    cursor?: MarketSurveyDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MarketSurveyDetailScalarFieldEnum>
  }


  /**
   * MarketSurvey without action
   */
  export type MarketSurveyArgs = {
    /**
     * Select specific fields to fetch from the MarketSurvey
     */
    select?: MarketSurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyInclude | null
  }



  /**
   * Model MarketSurveyDetail
   */


  export type AggregateMarketSurveyDetail = {
    _count: MarketSurveyDetailCountAggregateOutputType | null
    _avg: MarketSurveyDetailAvgAggregateOutputType | null
    _sum: MarketSurveyDetailSumAggregateOutputType | null
    _min: MarketSurveyDetailMinAggregateOutputType | null
    _max: MarketSurveyDetailMaxAggregateOutputType | null
  }

  export type MarketSurveyDetailAvgAggregateOutputType = {
    unit: number | null
    priceLocal: number | null
    priceUSD: number | null
  }

  export type MarketSurveyDetailSumAggregateOutputType = {
    unit: number | null
    priceLocal: number | null
    priceUSD: number | null
  }

  export type MarketSurveyDetailMinAggregateOutputType = {
    id: string | null
    brand: string | null
    unit: number | null
    uomId: string | null
    manufacturer: string | null
    countryOrigin: string | null
    priceLocal: number | null
    priceUSD: number | null
    sales: string | null
    marketSurveyId: string | null
  }

  export type MarketSurveyDetailMaxAggregateOutputType = {
    id: string | null
    brand: string | null
    unit: number | null
    uomId: string | null
    manufacturer: string | null
    countryOrigin: string | null
    priceLocal: number | null
    priceUSD: number | null
    sales: string | null
    marketSurveyId: string | null
  }

  export type MarketSurveyDetailCountAggregateOutputType = {
    id: number
    brand: number
    unit: number
    uomId: number
    manufacturer: number
    countryOrigin: number
    priceLocal: number
    priceUSD: number
    sales: number
    marketSurveyId: number
    _all: number
  }


  export type MarketSurveyDetailAvgAggregateInputType = {
    unit?: true
    priceLocal?: true
    priceUSD?: true
  }

  export type MarketSurveyDetailSumAggregateInputType = {
    unit?: true
    priceLocal?: true
    priceUSD?: true
  }

  export type MarketSurveyDetailMinAggregateInputType = {
    id?: true
    brand?: true
    unit?: true
    uomId?: true
    manufacturer?: true
    countryOrigin?: true
    priceLocal?: true
    priceUSD?: true
    sales?: true
    marketSurveyId?: true
  }

  export type MarketSurveyDetailMaxAggregateInputType = {
    id?: true
    brand?: true
    unit?: true
    uomId?: true
    manufacturer?: true
    countryOrigin?: true
    priceLocal?: true
    priceUSD?: true
    sales?: true
    marketSurveyId?: true
  }

  export type MarketSurveyDetailCountAggregateInputType = {
    id?: true
    brand?: true
    unit?: true
    uomId?: true
    manufacturer?: true
    countryOrigin?: true
    priceLocal?: true
    priceUSD?: true
    sales?: true
    marketSurveyId?: true
    _all?: true
  }

  export type MarketSurveyDetailAggregateArgs = {
    /**
     * Filter which MarketSurveyDetail to aggregate.
     */
    where?: MarketSurveyDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyDetails to fetch.
     */
    orderBy?: Enumerable<MarketSurveyDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketSurveyDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketSurveyDetails
    **/
    _count?: true | MarketSurveyDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketSurveyDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketSurveyDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketSurveyDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketSurveyDetailMaxAggregateInputType
  }

  export type GetMarketSurveyDetailAggregateType<T extends MarketSurveyDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketSurveyDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketSurveyDetail[P]>
      : GetScalarType<T[P], AggregateMarketSurveyDetail[P]>
  }




  export type MarketSurveyDetailGroupByArgs = {
    where?: MarketSurveyDetailWhereInput
    orderBy?: Enumerable<MarketSurveyDetailOrderByWithAggregationInput>
    by: MarketSurveyDetailScalarFieldEnum[]
    having?: MarketSurveyDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketSurveyDetailCountAggregateInputType | true
    _avg?: MarketSurveyDetailAvgAggregateInputType
    _sum?: MarketSurveyDetailSumAggregateInputType
    _min?: MarketSurveyDetailMinAggregateInputType
    _max?: MarketSurveyDetailMaxAggregateInputType
  }


  export type MarketSurveyDetailGroupByOutputType = {
    id: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
    marketSurveyId: string | null
    _count: MarketSurveyDetailCountAggregateOutputType | null
    _avg: MarketSurveyDetailAvgAggregateOutputType | null
    _sum: MarketSurveyDetailSumAggregateOutputType | null
    _min: MarketSurveyDetailMinAggregateOutputType | null
    _max: MarketSurveyDetailMaxAggregateOutputType | null
  }

  type GetMarketSurveyDetailGroupByPayload<T extends MarketSurveyDetailGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MarketSurveyDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketSurveyDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketSurveyDetailGroupByOutputType[P]>
            : GetScalarType<T[P], MarketSurveyDetailGroupByOutputType[P]>
        }
      >
    >


  export type MarketSurveyDetailSelect = {
    id?: boolean
    brand?: boolean
    unit?: boolean
    uomId?: boolean
    manufacturer?: boolean
    countryOrigin?: boolean
    priceLocal?: boolean
    priceUSD?: boolean
    sales?: boolean
    MarketSurvey?: boolean | MarketSurveyArgs
    marketSurveyId?: boolean
    marketSurveyDetailComp?: boolean | MarketSurveyDetail$marketSurveyDetailCompArgs
    _count?: boolean | MarketSurveyDetailCountOutputTypeArgs
  }


  export type MarketSurveyDetailInclude = {
    MarketSurvey?: boolean | MarketSurveyArgs
    marketSurveyDetailComp?: boolean | MarketSurveyDetail$marketSurveyDetailCompArgs
    _count?: boolean | MarketSurveyDetailCountOutputTypeArgs
  }

  export type MarketSurveyDetailGetPayload<S extends boolean | null | undefined | MarketSurveyDetailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MarketSurveyDetail :
    S extends undefined ? never :
    S extends { include: any } & (MarketSurveyDetailArgs | MarketSurveyDetailFindManyArgs)
    ? MarketSurveyDetail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'MarketSurvey' ? MarketSurveyGetPayload<S['include'][P]> | null :
        P extends 'marketSurveyDetailComp' ? Array < MarketSurveyDetailCompGetPayload<S['include'][P]>>  :
        P extends '_count' ? MarketSurveyDetailCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MarketSurveyDetailArgs | MarketSurveyDetailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'MarketSurvey' ? MarketSurveyGetPayload<S['select'][P]> | null :
        P extends 'marketSurveyDetailComp' ? Array < MarketSurveyDetailCompGetPayload<S['select'][P]>>  :
        P extends '_count' ? MarketSurveyDetailCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MarketSurveyDetail ? MarketSurveyDetail[P] : never
  } 
      : MarketSurveyDetail


  type MarketSurveyDetailCountArgs = 
    Omit<MarketSurveyDetailFindManyArgs, 'select' | 'include'> & {
      select?: MarketSurveyDetailCountAggregateInputType | true
    }

  export interface MarketSurveyDetailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MarketSurveyDetail that matches the filter.
     * @param {MarketSurveyDetailFindUniqueArgs} args - Arguments to find a MarketSurveyDetail
     * @example
     * // Get one MarketSurveyDetail
     * const marketSurveyDetail = await prisma.marketSurveyDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarketSurveyDetailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarketSurveyDetailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MarketSurveyDetail'> extends True ? Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T>> : Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T> | null, null>

    /**
     * Find one MarketSurveyDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarketSurveyDetailFindUniqueOrThrowArgs} args - Arguments to find a MarketSurveyDetail
     * @example
     * // Get one MarketSurveyDetail
     * const marketSurveyDetail = await prisma.marketSurveyDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarketSurveyDetailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MarketSurveyDetailFindUniqueOrThrowArgs>
    ): Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T>>

    /**
     * Find the first MarketSurveyDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailFindFirstArgs} args - Arguments to find a MarketSurveyDetail
     * @example
     * // Get one MarketSurveyDetail
     * const marketSurveyDetail = await prisma.marketSurveyDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarketSurveyDetailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarketSurveyDetailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MarketSurveyDetail'> extends True ? Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T>> : Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T> | null, null>

    /**
     * Find the first MarketSurveyDetail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailFindFirstOrThrowArgs} args - Arguments to find a MarketSurveyDetail
     * @example
     * // Get one MarketSurveyDetail
     * const marketSurveyDetail = await prisma.marketSurveyDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarketSurveyDetailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MarketSurveyDetailFindFirstOrThrowArgs>
    ): Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T>>

    /**
     * Find zero or more MarketSurveyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketSurveyDetails
     * const marketSurveyDetails = await prisma.marketSurveyDetail.findMany()
     * 
     * // Get first 10 MarketSurveyDetails
     * const marketSurveyDetails = await prisma.marketSurveyDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketSurveyDetailWithIdOnly = await prisma.marketSurveyDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MarketSurveyDetailFindManyArgs>(
      args?: SelectSubset<T, MarketSurveyDetailFindManyArgs>
    ): PrismaPromise<Array<MarketSurveyDetailGetPayload<T>>>

    /**
     * Create a MarketSurveyDetail.
     * @param {MarketSurveyDetailCreateArgs} args - Arguments to create a MarketSurveyDetail.
     * @example
     * // Create one MarketSurveyDetail
     * const MarketSurveyDetail = await prisma.marketSurveyDetail.create({
     *   data: {
     *     // ... data to create a MarketSurveyDetail
     *   }
     * })
     * 
    **/
    create<T extends MarketSurveyDetailCreateArgs>(
      args: SelectSubset<T, MarketSurveyDetailCreateArgs>
    ): Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T>>

    /**
     * Create many MarketSurveyDetails.
     *     @param {MarketSurveyDetailCreateManyArgs} args - Arguments to create many MarketSurveyDetails.
     *     @example
     *     // Create many MarketSurveyDetails
     *     const marketSurveyDetail = await prisma.marketSurveyDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarketSurveyDetailCreateManyArgs>(
      args?: SelectSubset<T, MarketSurveyDetailCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MarketSurveyDetail.
     * @param {MarketSurveyDetailDeleteArgs} args - Arguments to delete one MarketSurveyDetail.
     * @example
     * // Delete one MarketSurveyDetail
     * const MarketSurveyDetail = await prisma.marketSurveyDetail.delete({
     *   where: {
     *     // ... filter to delete one MarketSurveyDetail
     *   }
     * })
     * 
    **/
    delete<T extends MarketSurveyDetailDeleteArgs>(
      args: SelectSubset<T, MarketSurveyDetailDeleteArgs>
    ): Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T>>

    /**
     * Update one MarketSurveyDetail.
     * @param {MarketSurveyDetailUpdateArgs} args - Arguments to update one MarketSurveyDetail.
     * @example
     * // Update one MarketSurveyDetail
     * const marketSurveyDetail = await prisma.marketSurveyDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarketSurveyDetailUpdateArgs>(
      args: SelectSubset<T, MarketSurveyDetailUpdateArgs>
    ): Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T>>

    /**
     * Delete zero or more MarketSurveyDetails.
     * @param {MarketSurveyDetailDeleteManyArgs} args - Arguments to filter MarketSurveyDetails to delete.
     * @example
     * // Delete a few MarketSurveyDetails
     * const { count } = await prisma.marketSurveyDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarketSurveyDetailDeleteManyArgs>(
      args?: SelectSubset<T, MarketSurveyDetailDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketSurveyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketSurveyDetails
     * const marketSurveyDetail = await prisma.marketSurveyDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarketSurveyDetailUpdateManyArgs>(
      args: SelectSubset<T, MarketSurveyDetailUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketSurveyDetail.
     * @param {MarketSurveyDetailUpsertArgs} args - Arguments to update or create a MarketSurveyDetail.
     * @example
     * // Update or create a MarketSurveyDetail
     * const marketSurveyDetail = await prisma.marketSurveyDetail.upsert({
     *   create: {
     *     // ... data to create a MarketSurveyDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketSurveyDetail we want to update
     *   }
     * })
    **/
    upsert<T extends MarketSurveyDetailUpsertArgs>(
      args: SelectSubset<T, MarketSurveyDetailUpsertArgs>
    ): Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T>>

    /**
     * Count the number of MarketSurveyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailCountArgs} args - Arguments to filter MarketSurveyDetails to count.
     * @example
     * // Count the number of MarketSurveyDetails
     * const count = await prisma.marketSurveyDetail.count({
     *   where: {
     *     // ... the filter for the MarketSurveyDetails we want to count
     *   }
     * })
    **/
    count<T extends MarketSurveyDetailCountArgs>(
      args?: Subset<T, MarketSurveyDetailCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketSurveyDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketSurveyDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketSurveyDetailAggregateArgs>(args: Subset<T, MarketSurveyDetailAggregateArgs>): PrismaPromise<GetMarketSurveyDetailAggregateType<T>>

    /**
     * Group by MarketSurveyDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketSurveyDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketSurveyDetailGroupByArgs['orderBy'] }
        : { orderBy?: MarketSurveyDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketSurveyDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketSurveyDetailGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketSurveyDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarketSurveyDetailClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    MarketSurvey<T extends MarketSurveyArgs= {}>(args?: Subset<T, MarketSurveyArgs>): Prisma__MarketSurveyClient<MarketSurveyGetPayload<T> | Null>;

    marketSurveyDetailComp<T extends MarketSurveyDetail$marketSurveyDetailCompArgs= {}>(args?: Subset<T, MarketSurveyDetail$marketSurveyDetailCompArgs>): PrismaPromise<Array<MarketSurveyDetailCompGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MarketSurveyDetail base type for findUnique actions
   */
  export type MarketSurveyDetailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * Filter, which MarketSurveyDetail to fetch.
     */
    where: MarketSurveyDetailWhereUniqueInput
  }

  /**
   * MarketSurveyDetail findUnique
   */
  export interface MarketSurveyDetailFindUniqueArgs extends MarketSurveyDetailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketSurveyDetail findUniqueOrThrow
   */
  export type MarketSurveyDetailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * Filter, which MarketSurveyDetail to fetch.
     */
    where: MarketSurveyDetailWhereUniqueInput
  }


  /**
   * MarketSurveyDetail base type for findFirst actions
   */
  export type MarketSurveyDetailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * Filter, which MarketSurveyDetail to fetch.
     */
    where?: MarketSurveyDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyDetails to fetch.
     */
    orderBy?: Enumerable<MarketSurveyDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSurveyDetails.
     */
    cursor?: MarketSurveyDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSurveyDetails.
     */
    distinct?: Enumerable<MarketSurveyDetailScalarFieldEnum>
  }

  /**
   * MarketSurveyDetail findFirst
   */
  export interface MarketSurveyDetailFindFirstArgs extends MarketSurveyDetailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketSurveyDetail findFirstOrThrow
   */
  export type MarketSurveyDetailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * Filter, which MarketSurveyDetail to fetch.
     */
    where?: MarketSurveyDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyDetails to fetch.
     */
    orderBy?: Enumerable<MarketSurveyDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSurveyDetails.
     */
    cursor?: MarketSurveyDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSurveyDetails.
     */
    distinct?: Enumerable<MarketSurveyDetailScalarFieldEnum>
  }


  /**
   * MarketSurveyDetail findMany
   */
  export type MarketSurveyDetailFindManyArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * Filter, which MarketSurveyDetails to fetch.
     */
    where?: MarketSurveyDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyDetails to fetch.
     */
    orderBy?: Enumerable<MarketSurveyDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketSurveyDetails.
     */
    cursor?: MarketSurveyDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyDetails.
     */
    skip?: number
    distinct?: Enumerable<MarketSurveyDetailScalarFieldEnum>
  }


  /**
   * MarketSurveyDetail create
   */
  export type MarketSurveyDetailCreateArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * The data needed to create a MarketSurveyDetail.
     */
    data: XOR<MarketSurveyDetailCreateInput, MarketSurveyDetailUncheckedCreateInput>
  }


  /**
   * MarketSurveyDetail createMany
   */
  export type MarketSurveyDetailCreateManyArgs = {
    /**
     * The data used to create many MarketSurveyDetails.
     */
    data: Enumerable<MarketSurveyDetailCreateManyInput>
  }


  /**
   * MarketSurveyDetail update
   */
  export type MarketSurveyDetailUpdateArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * The data needed to update a MarketSurveyDetail.
     */
    data: XOR<MarketSurveyDetailUpdateInput, MarketSurveyDetailUncheckedUpdateInput>
    /**
     * Choose, which MarketSurveyDetail to update.
     */
    where: MarketSurveyDetailWhereUniqueInput
  }


  /**
   * MarketSurveyDetail updateMany
   */
  export type MarketSurveyDetailUpdateManyArgs = {
    /**
     * The data used to update MarketSurveyDetails.
     */
    data: XOR<MarketSurveyDetailUpdateManyMutationInput, MarketSurveyDetailUncheckedUpdateManyInput>
    /**
     * Filter which MarketSurveyDetails to update
     */
    where?: MarketSurveyDetailWhereInput
  }


  /**
   * MarketSurveyDetail upsert
   */
  export type MarketSurveyDetailUpsertArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * The filter to search for the MarketSurveyDetail to update in case it exists.
     */
    where: MarketSurveyDetailWhereUniqueInput
    /**
     * In case the MarketSurveyDetail found by the `where` argument doesn't exist, create a new MarketSurveyDetail with this data.
     */
    create: XOR<MarketSurveyDetailCreateInput, MarketSurveyDetailUncheckedCreateInput>
    /**
     * In case the MarketSurveyDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketSurveyDetailUpdateInput, MarketSurveyDetailUncheckedUpdateInput>
  }


  /**
   * MarketSurveyDetail delete
   */
  export type MarketSurveyDetailDeleteArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
    /**
     * Filter which MarketSurveyDetail to delete.
     */
    where: MarketSurveyDetailWhereUniqueInput
  }


  /**
   * MarketSurveyDetail deleteMany
   */
  export type MarketSurveyDetailDeleteManyArgs = {
    /**
     * Filter which MarketSurveyDetails to delete
     */
    where?: MarketSurveyDetailWhereInput
  }


  /**
   * MarketSurveyDetail.marketSurveyDetailComp
   */
  export type MarketSurveyDetail$marketSurveyDetailCompArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    where?: MarketSurveyDetailCompWhereInput
    orderBy?: Enumerable<MarketSurveyDetailCompOrderByWithRelationInput>
    cursor?: MarketSurveyDetailCompWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MarketSurveyDetailCompScalarFieldEnum>
  }


  /**
   * MarketSurveyDetail without action
   */
  export type MarketSurveyDetailArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetail
     */
    select?: MarketSurveyDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailInclude | null
  }



  /**
   * Model MarketSurveyDetailComp
   */


  export type AggregateMarketSurveyDetailComp = {
    _count: MarketSurveyDetailCompCountAggregateOutputType | null
    _min: MarketSurveyDetailCompMinAggregateOutputType | null
    _max: MarketSurveyDetailCompMaxAggregateOutputType | null
  }

  export type MarketSurveyDetailCompMinAggregateOutputType = {
    id: string | null
    composition: string | null
    marketSurveyDetailId: string | null
  }

  export type MarketSurveyDetailCompMaxAggregateOutputType = {
    id: string | null
    composition: string | null
    marketSurveyDetailId: string | null
  }

  export type MarketSurveyDetailCompCountAggregateOutputType = {
    id: number
    composition: number
    marketSurveyDetailId: number
    _all: number
  }


  export type MarketSurveyDetailCompMinAggregateInputType = {
    id?: true
    composition?: true
    marketSurveyDetailId?: true
  }

  export type MarketSurveyDetailCompMaxAggregateInputType = {
    id?: true
    composition?: true
    marketSurveyDetailId?: true
  }

  export type MarketSurveyDetailCompCountAggregateInputType = {
    id?: true
    composition?: true
    marketSurveyDetailId?: true
    _all?: true
  }

  export type MarketSurveyDetailCompAggregateArgs = {
    /**
     * Filter which MarketSurveyDetailComp to aggregate.
     */
    where?: MarketSurveyDetailCompWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyDetailComps to fetch.
     */
    orderBy?: Enumerable<MarketSurveyDetailCompOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketSurveyDetailCompWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyDetailComps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyDetailComps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketSurveyDetailComps
    **/
    _count?: true | MarketSurveyDetailCompCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketSurveyDetailCompMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketSurveyDetailCompMaxAggregateInputType
  }

  export type GetMarketSurveyDetailCompAggregateType<T extends MarketSurveyDetailCompAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketSurveyDetailComp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketSurveyDetailComp[P]>
      : GetScalarType<T[P], AggregateMarketSurveyDetailComp[P]>
  }




  export type MarketSurveyDetailCompGroupByArgs = {
    where?: MarketSurveyDetailCompWhereInput
    orderBy?: Enumerable<MarketSurveyDetailCompOrderByWithAggregationInput>
    by: MarketSurveyDetailCompScalarFieldEnum[]
    having?: MarketSurveyDetailCompScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketSurveyDetailCompCountAggregateInputType | true
    _min?: MarketSurveyDetailCompMinAggregateInputType
    _max?: MarketSurveyDetailCompMaxAggregateInputType
  }


  export type MarketSurveyDetailCompGroupByOutputType = {
    id: string
    composition: string
    marketSurveyDetailId: string | null
    _count: MarketSurveyDetailCompCountAggregateOutputType | null
    _min: MarketSurveyDetailCompMinAggregateOutputType | null
    _max: MarketSurveyDetailCompMaxAggregateOutputType | null
  }

  type GetMarketSurveyDetailCompGroupByPayload<T extends MarketSurveyDetailCompGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MarketSurveyDetailCompGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketSurveyDetailCompGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketSurveyDetailCompGroupByOutputType[P]>
            : GetScalarType<T[P], MarketSurveyDetailCompGroupByOutputType[P]>
        }
      >
    >


  export type MarketSurveyDetailCompSelect = {
    id?: boolean
    composition?: boolean
    MarketSurveyDetail?: boolean | MarketSurveyDetailArgs
    marketSurveyDetailId?: boolean
  }


  export type MarketSurveyDetailCompInclude = {
    MarketSurveyDetail?: boolean | MarketSurveyDetailArgs
  }

  export type MarketSurveyDetailCompGetPayload<S extends boolean | null | undefined | MarketSurveyDetailCompArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MarketSurveyDetailComp :
    S extends undefined ? never :
    S extends { include: any } & (MarketSurveyDetailCompArgs | MarketSurveyDetailCompFindManyArgs)
    ? MarketSurveyDetailComp  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'MarketSurveyDetail' ? MarketSurveyDetailGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (MarketSurveyDetailCompArgs | MarketSurveyDetailCompFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'MarketSurveyDetail' ? MarketSurveyDetailGetPayload<S['select'][P]> | null :  P extends keyof MarketSurveyDetailComp ? MarketSurveyDetailComp[P] : never
  } 
      : MarketSurveyDetailComp


  type MarketSurveyDetailCompCountArgs = 
    Omit<MarketSurveyDetailCompFindManyArgs, 'select' | 'include'> & {
      select?: MarketSurveyDetailCompCountAggregateInputType | true
    }

  export interface MarketSurveyDetailCompDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MarketSurveyDetailComp that matches the filter.
     * @param {MarketSurveyDetailCompFindUniqueArgs} args - Arguments to find a MarketSurveyDetailComp
     * @example
     * // Get one MarketSurveyDetailComp
     * const marketSurveyDetailComp = await prisma.marketSurveyDetailComp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarketSurveyDetailCompFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarketSurveyDetailCompFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MarketSurveyDetailComp'> extends True ? Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T>> : Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T> | null, null>

    /**
     * Find one MarketSurveyDetailComp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarketSurveyDetailCompFindUniqueOrThrowArgs} args - Arguments to find a MarketSurveyDetailComp
     * @example
     * // Get one MarketSurveyDetailComp
     * const marketSurveyDetailComp = await prisma.marketSurveyDetailComp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarketSurveyDetailCompFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MarketSurveyDetailCompFindUniqueOrThrowArgs>
    ): Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T>>

    /**
     * Find the first MarketSurveyDetailComp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailCompFindFirstArgs} args - Arguments to find a MarketSurveyDetailComp
     * @example
     * // Get one MarketSurveyDetailComp
     * const marketSurveyDetailComp = await prisma.marketSurveyDetailComp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarketSurveyDetailCompFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarketSurveyDetailCompFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MarketSurveyDetailComp'> extends True ? Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T>> : Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T> | null, null>

    /**
     * Find the first MarketSurveyDetailComp that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailCompFindFirstOrThrowArgs} args - Arguments to find a MarketSurveyDetailComp
     * @example
     * // Get one MarketSurveyDetailComp
     * const marketSurveyDetailComp = await prisma.marketSurveyDetailComp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarketSurveyDetailCompFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MarketSurveyDetailCompFindFirstOrThrowArgs>
    ): Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T>>

    /**
     * Find zero or more MarketSurveyDetailComps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailCompFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketSurveyDetailComps
     * const marketSurveyDetailComps = await prisma.marketSurveyDetailComp.findMany()
     * 
     * // Get first 10 MarketSurveyDetailComps
     * const marketSurveyDetailComps = await prisma.marketSurveyDetailComp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketSurveyDetailCompWithIdOnly = await prisma.marketSurveyDetailComp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MarketSurveyDetailCompFindManyArgs>(
      args?: SelectSubset<T, MarketSurveyDetailCompFindManyArgs>
    ): PrismaPromise<Array<MarketSurveyDetailCompGetPayload<T>>>

    /**
     * Create a MarketSurveyDetailComp.
     * @param {MarketSurveyDetailCompCreateArgs} args - Arguments to create a MarketSurveyDetailComp.
     * @example
     * // Create one MarketSurveyDetailComp
     * const MarketSurveyDetailComp = await prisma.marketSurveyDetailComp.create({
     *   data: {
     *     // ... data to create a MarketSurveyDetailComp
     *   }
     * })
     * 
    **/
    create<T extends MarketSurveyDetailCompCreateArgs>(
      args: SelectSubset<T, MarketSurveyDetailCompCreateArgs>
    ): Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T>>

    /**
     * Create many MarketSurveyDetailComps.
     *     @param {MarketSurveyDetailCompCreateManyArgs} args - Arguments to create many MarketSurveyDetailComps.
     *     @example
     *     // Create many MarketSurveyDetailComps
     *     const marketSurveyDetailComp = await prisma.marketSurveyDetailComp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarketSurveyDetailCompCreateManyArgs>(
      args?: SelectSubset<T, MarketSurveyDetailCompCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MarketSurveyDetailComp.
     * @param {MarketSurveyDetailCompDeleteArgs} args - Arguments to delete one MarketSurveyDetailComp.
     * @example
     * // Delete one MarketSurveyDetailComp
     * const MarketSurveyDetailComp = await prisma.marketSurveyDetailComp.delete({
     *   where: {
     *     // ... filter to delete one MarketSurveyDetailComp
     *   }
     * })
     * 
    **/
    delete<T extends MarketSurveyDetailCompDeleteArgs>(
      args: SelectSubset<T, MarketSurveyDetailCompDeleteArgs>
    ): Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T>>

    /**
     * Update one MarketSurveyDetailComp.
     * @param {MarketSurveyDetailCompUpdateArgs} args - Arguments to update one MarketSurveyDetailComp.
     * @example
     * // Update one MarketSurveyDetailComp
     * const marketSurveyDetailComp = await prisma.marketSurveyDetailComp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarketSurveyDetailCompUpdateArgs>(
      args: SelectSubset<T, MarketSurveyDetailCompUpdateArgs>
    ): Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T>>

    /**
     * Delete zero or more MarketSurveyDetailComps.
     * @param {MarketSurveyDetailCompDeleteManyArgs} args - Arguments to filter MarketSurveyDetailComps to delete.
     * @example
     * // Delete a few MarketSurveyDetailComps
     * const { count } = await prisma.marketSurveyDetailComp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarketSurveyDetailCompDeleteManyArgs>(
      args?: SelectSubset<T, MarketSurveyDetailCompDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketSurveyDetailComps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailCompUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketSurveyDetailComps
     * const marketSurveyDetailComp = await prisma.marketSurveyDetailComp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarketSurveyDetailCompUpdateManyArgs>(
      args: SelectSubset<T, MarketSurveyDetailCompUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketSurveyDetailComp.
     * @param {MarketSurveyDetailCompUpsertArgs} args - Arguments to update or create a MarketSurveyDetailComp.
     * @example
     * // Update or create a MarketSurveyDetailComp
     * const marketSurveyDetailComp = await prisma.marketSurveyDetailComp.upsert({
     *   create: {
     *     // ... data to create a MarketSurveyDetailComp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketSurveyDetailComp we want to update
     *   }
     * })
    **/
    upsert<T extends MarketSurveyDetailCompUpsertArgs>(
      args: SelectSubset<T, MarketSurveyDetailCompUpsertArgs>
    ): Prisma__MarketSurveyDetailCompClient<MarketSurveyDetailCompGetPayload<T>>

    /**
     * Count the number of MarketSurveyDetailComps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailCompCountArgs} args - Arguments to filter MarketSurveyDetailComps to count.
     * @example
     * // Count the number of MarketSurveyDetailComps
     * const count = await prisma.marketSurveyDetailComp.count({
     *   where: {
     *     // ... the filter for the MarketSurveyDetailComps we want to count
     *   }
     * })
    **/
    count<T extends MarketSurveyDetailCompCountArgs>(
      args?: Subset<T, MarketSurveyDetailCompCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketSurveyDetailCompCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketSurveyDetailComp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailCompAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketSurveyDetailCompAggregateArgs>(args: Subset<T, MarketSurveyDetailCompAggregateArgs>): PrismaPromise<GetMarketSurveyDetailCompAggregateType<T>>

    /**
     * Group by MarketSurveyDetailComp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSurveyDetailCompGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketSurveyDetailCompGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketSurveyDetailCompGroupByArgs['orderBy'] }
        : { orderBy?: MarketSurveyDetailCompGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketSurveyDetailCompGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketSurveyDetailCompGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketSurveyDetailComp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarketSurveyDetailCompClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    MarketSurveyDetail<T extends MarketSurveyDetailArgs= {}>(args?: Subset<T, MarketSurveyDetailArgs>): Prisma__MarketSurveyDetailClient<MarketSurveyDetailGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MarketSurveyDetailComp base type for findUnique actions
   */
  export type MarketSurveyDetailCompFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * Filter, which MarketSurveyDetailComp to fetch.
     */
    where: MarketSurveyDetailCompWhereUniqueInput
  }

  /**
   * MarketSurveyDetailComp findUnique
   */
  export interface MarketSurveyDetailCompFindUniqueArgs extends MarketSurveyDetailCompFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketSurveyDetailComp findUniqueOrThrow
   */
  export type MarketSurveyDetailCompFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * Filter, which MarketSurveyDetailComp to fetch.
     */
    where: MarketSurveyDetailCompWhereUniqueInput
  }


  /**
   * MarketSurveyDetailComp base type for findFirst actions
   */
  export type MarketSurveyDetailCompFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * Filter, which MarketSurveyDetailComp to fetch.
     */
    where?: MarketSurveyDetailCompWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyDetailComps to fetch.
     */
    orderBy?: Enumerable<MarketSurveyDetailCompOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSurveyDetailComps.
     */
    cursor?: MarketSurveyDetailCompWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyDetailComps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyDetailComps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSurveyDetailComps.
     */
    distinct?: Enumerable<MarketSurveyDetailCompScalarFieldEnum>
  }

  /**
   * MarketSurveyDetailComp findFirst
   */
  export interface MarketSurveyDetailCompFindFirstArgs extends MarketSurveyDetailCompFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketSurveyDetailComp findFirstOrThrow
   */
  export type MarketSurveyDetailCompFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * Filter, which MarketSurveyDetailComp to fetch.
     */
    where?: MarketSurveyDetailCompWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyDetailComps to fetch.
     */
    orderBy?: Enumerable<MarketSurveyDetailCompOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSurveyDetailComps.
     */
    cursor?: MarketSurveyDetailCompWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyDetailComps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyDetailComps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSurveyDetailComps.
     */
    distinct?: Enumerable<MarketSurveyDetailCompScalarFieldEnum>
  }


  /**
   * MarketSurveyDetailComp findMany
   */
  export type MarketSurveyDetailCompFindManyArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * Filter, which MarketSurveyDetailComps to fetch.
     */
    where?: MarketSurveyDetailCompWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSurveyDetailComps to fetch.
     */
    orderBy?: Enumerable<MarketSurveyDetailCompOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketSurveyDetailComps.
     */
    cursor?: MarketSurveyDetailCompWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSurveyDetailComps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSurveyDetailComps.
     */
    skip?: number
    distinct?: Enumerable<MarketSurveyDetailCompScalarFieldEnum>
  }


  /**
   * MarketSurveyDetailComp create
   */
  export type MarketSurveyDetailCompCreateArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * The data needed to create a MarketSurveyDetailComp.
     */
    data: XOR<MarketSurveyDetailCompCreateInput, MarketSurveyDetailCompUncheckedCreateInput>
  }


  /**
   * MarketSurveyDetailComp createMany
   */
  export type MarketSurveyDetailCompCreateManyArgs = {
    /**
     * The data used to create many MarketSurveyDetailComps.
     */
    data: Enumerable<MarketSurveyDetailCompCreateManyInput>
  }


  /**
   * MarketSurveyDetailComp update
   */
  export type MarketSurveyDetailCompUpdateArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * The data needed to update a MarketSurveyDetailComp.
     */
    data: XOR<MarketSurveyDetailCompUpdateInput, MarketSurveyDetailCompUncheckedUpdateInput>
    /**
     * Choose, which MarketSurveyDetailComp to update.
     */
    where: MarketSurveyDetailCompWhereUniqueInput
  }


  /**
   * MarketSurveyDetailComp updateMany
   */
  export type MarketSurveyDetailCompUpdateManyArgs = {
    /**
     * The data used to update MarketSurveyDetailComps.
     */
    data: XOR<MarketSurveyDetailCompUpdateManyMutationInput, MarketSurveyDetailCompUncheckedUpdateManyInput>
    /**
     * Filter which MarketSurveyDetailComps to update
     */
    where?: MarketSurveyDetailCompWhereInput
  }


  /**
   * MarketSurveyDetailComp upsert
   */
  export type MarketSurveyDetailCompUpsertArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * The filter to search for the MarketSurveyDetailComp to update in case it exists.
     */
    where: MarketSurveyDetailCompWhereUniqueInput
    /**
     * In case the MarketSurveyDetailComp found by the `where` argument doesn't exist, create a new MarketSurveyDetailComp with this data.
     */
    create: XOR<MarketSurveyDetailCompCreateInput, MarketSurveyDetailCompUncheckedCreateInput>
    /**
     * In case the MarketSurveyDetailComp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketSurveyDetailCompUpdateInput, MarketSurveyDetailCompUncheckedUpdateInput>
  }


  /**
   * MarketSurveyDetailComp delete
   */
  export type MarketSurveyDetailCompDeleteArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
    /**
     * Filter which MarketSurveyDetailComp to delete.
     */
    where: MarketSurveyDetailCompWhereUniqueInput
  }


  /**
   * MarketSurveyDetailComp deleteMany
   */
  export type MarketSurveyDetailCompDeleteManyArgs = {
    /**
     * Filter which MarketSurveyDetailComps to delete
     */
    where?: MarketSurveyDetailCompWhereInput
  }


  /**
   * MarketSurveyDetailComp without action
   */
  export type MarketSurveyDetailCompArgs = {
    /**
     * Select specific fields to fetch from the MarketSurveyDetailComp
     */
    select?: MarketSurveyDetailCompSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketSurveyDetailCompInclude | null
  }



  /**
   * Model MasterRole
   */


  export type AggregateMasterRole = {
    _count: MasterRoleCountAggregateOutputType | null
    _avg: MasterRoleAvgAggregateOutputType | null
    _sum: MasterRoleSumAggregateOutputType | null
    _min: MasterRoleMinAggregateOutputType | null
    _max: MasterRoleMaxAggregateOutputType | null
  }

  export type MasterRoleAvgAggregateOutputType = {
    id: number | null
  }

  export type MasterRoleSumAggregateOutputType = {
    id: number | null
  }

  export type MasterRoleMinAggregateOutputType = {
    id: number | null
    roleName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    createdBy: string | null
  }

  export type MasterRoleMaxAggregateOutputType = {
    id: number | null
    roleName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    createdBy: string | null
  }

  export type MasterRoleCountAggregateOutputType = {
    id: number
    roleName: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    createdBy: number
    _all: number
  }


  export type MasterRoleAvgAggregateInputType = {
    id?: true
  }

  export type MasterRoleSumAggregateInputType = {
    id?: true
  }

  export type MasterRoleMinAggregateInputType = {
    id?: true
    roleName?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
  }

  export type MasterRoleMaxAggregateInputType = {
    id?: true
    roleName?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
  }

  export type MasterRoleCountAggregateInputType = {
    id?: true
    roleName?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
    _all?: true
  }

  export type MasterRoleAggregateArgs = {
    /**
     * Filter which MasterRole to aggregate.
     */
    where?: MasterRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterRoles to fetch.
     */
    orderBy?: Enumerable<MasterRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterRoles
    **/
    _count?: true | MasterRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterRoleMaxAggregateInputType
  }

  export type GetMasterRoleAggregateType<T extends MasterRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterRole[P]>
      : GetScalarType<T[P], AggregateMasterRole[P]>
  }




  export type MasterRoleGroupByArgs = {
    where?: MasterRoleWhereInput
    orderBy?: Enumerable<MasterRoleOrderByWithAggregationInput>
    by: MasterRoleScalarFieldEnum[]
    having?: MasterRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterRoleCountAggregateInputType | true
    _avg?: MasterRoleAvgAggregateInputType
    _sum?: MasterRoleSumAggregateInputType
    _min?: MasterRoleMinAggregateInputType
    _max?: MasterRoleMaxAggregateInputType
  }


  export type MasterRoleGroupByOutputType = {
    id: number
    roleName: string
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    createdBy: string | null
    _count: MasterRoleCountAggregateOutputType | null
    _avg: MasterRoleAvgAggregateOutputType | null
    _sum: MasterRoleSumAggregateOutputType | null
    _min: MasterRoleMinAggregateOutputType | null
    _max: MasterRoleMaxAggregateOutputType | null
  }

  type GetMasterRoleGroupByPayload<T extends MasterRoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterRoleGroupByOutputType[P]>
            : GetScalarType<T[P], MasterRoleGroupByOutputType[P]>
        }
      >
    >


  export type MasterRoleSelect = {
    id?: boolean
    roleName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    createdBy?: boolean
  }


  export type MasterRoleGetPayload<S extends boolean | null | undefined | MasterRoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterRole :
    S extends undefined ? never :
    S extends { include: any } & (MasterRoleArgs | MasterRoleFindManyArgs)
    ? MasterRole 
    : S extends { select: any } & (MasterRoleArgs | MasterRoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MasterRole ? MasterRole[P] : never
  } 
      : MasterRole


  type MasterRoleCountArgs = 
    Omit<MasterRoleFindManyArgs, 'select' | 'include'> & {
      select?: MasterRoleCountAggregateInputType | true
    }

  export interface MasterRoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterRole that matches the filter.
     * @param {MasterRoleFindUniqueArgs} args - Arguments to find a MasterRole
     * @example
     * // Get one MasterRole
     * const masterRole = await prisma.masterRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterRole'> extends True ? Prisma__MasterRoleClient<MasterRoleGetPayload<T>> : Prisma__MasterRoleClient<MasterRoleGetPayload<T> | null, null>

    /**
     * Find one MasterRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterRoleFindUniqueOrThrowArgs} args - Arguments to find a MasterRole
     * @example
     * // Get one MasterRole
     * const masterRole = await prisma.masterRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterRoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterRoleFindUniqueOrThrowArgs>
    ): Prisma__MasterRoleClient<MasterRoleGetPayload<T>>

    /**
     * Find the first MasterRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleFindFirstArgs} args - Arguments to find a MasterRole
     * @example
     * // Get one MasterRole
     * const masterRole = await prisma.masterRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterRole'> extends True ? Prisma__MasterRoleClient<MasterRoleGetPayload<T>> : Prisma__MasterRoleClient<MasterRoleGetPayload<T> | null, null>

    /**
     * Find the first MasterRole that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleFindFirstOrThrowArgs} args - Arguments to find a MasterRole
     * @example
     * // Get one MasterRole
     * const masterRole = await prisma.masterRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterRoleFindFirstOrThrowArgs>
    ): Prisma__MasterRoleClient<MasterRoleGetPayload<T>>

    /**
     * Find zero or more MasterRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterRoles
     * const masterRoles = await prisma.masterRole.findMany()
     * 
     * // Get first 10 MasterRoles
     * const masterRoles = await prisma.masterRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterRoleWithIdOnly = await prisma.masterRole.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterRoleFindManyArgs>(
      args?: SelectSubset<T, MasterRoleFindManyArgs>
    ): PrismaPromise<Array<MasterRoleGetPayload<T>>>

    /**
     * Create a MasterRole.
     * @param {MasterRoleCreateArgs} args - Arguments to create a MasterRole.
     * @example
     * // Create one MasterRole
     * const MasterRole = await prisma.masterRole.create({
     *   data: {
     *     // ... data to create a MasterRole
     *   }
     * })
     * 
    **/
    create<T extends MasterRoleCreateArgs>(
      args: SelectSubset<T, MasterRoleCreateArgs>
    ): Prisma__MasterRoleClient<MasterRoleGetPayload<T>>

    /**
     * Create many MasterRoles.
     *     @param {MasterRoleCreateManyArgs} args - Arguments to create many MasterRoles.
     *     @example
     *     // Create many MasterRoles
     *     const masterRole = await prisma.masterRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterRoleCreateManyArgs>(
      args?: SelectSubset<T, MasterRoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterRole.
     * @param {MasterRoleDeleteArgs} args - Arguments to delete one MasterRole.
     * @example
     * // Delete one MasterRole
     * const MasterRole = await prisma.masterRole.delete({
     *   where: {
     *     // ... filter to delete one MasterRole
     *   }
     * })
     * 
    **/
    delete<T extends MasterRoleDeleteArgs>(
      args: SelectSubset<T, MasterRoleDeleteArgs>
    ): Prisma__MasterRoleClient<MasterRoleGetPayload<T>>

    /**
     * Update one MasterRole.
     * @param {MasterRoleUpdateArgs} args - Arguments to update one MasterRole.
     * @example
     * // Update one MasterRole
     * const masterRole = await prisma.masterRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterRoleUpdateArgs>(
      args: SelectSubset<T, MasterRoleUpdateArgs>
    ): Prisma__MasterRoleClient<MasterRoleGetPayload<T>>

    /**
     * Delete zero or more MasterRoles.
     * @param {MasterRoleDeleteManyArgs} args - Arguments to filter MasterRoles to delete.
     * @example
     * // Delete a few MasterRoles
     * const { count } = await prisma.masterRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterRoleDeleteManyArgs>(
      args?: SelectSubset<T, MasterRoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterRoles
     * const masterRole = await prisma.masterRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterRoleUpdateManyArgs>(
      args: SelectSubset<T, MasterRoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterRole.
     * @param {MasterRoleUpsertArgs} args - Arguments to update or create a MasterRole.
     * @example
     * // Update or create a MasterRole
     * const masterRole = await prisma.masterRole.upsert({
     *   create: {
     *     // ... data to create a MasterRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterRole we want to update
     *   }
     * })
    **/
    upsert<T extends MasterRoleUpsertArgs>(
      args: SelectSubset<T, MasterRoleUpsertArgs>
    ): Prisma__MasterRoleClient<MasterRoleGetPayload<T>>

    /**
     * Count the number of MasterRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleCountArgs} args - Arguments to filter MasterRoles to count.
     * @example
     * // Count the number of MasterRoles
     * const count = await prisma.masterRole.count({
     *   where: {
     *     // ... the filter for the MasterRoles we want to count
     *   }
     * })
    **/
    count<T extends MasterRoleCountArgs>(
      args?: Subset<T, MasterRoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterRoleAggregateArgs>(args: Subset<T, MasterRoleAggregateArgs>): PrismaPromise<GetMasterRoleAggregateType<T>>

    /**
     * Group by MasterRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterRoleGroupByArgs['orderBy'] }
        : { orderBy?: MasterRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterRoleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterRoleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterRole base type for findUnique actions
   */
  export type MasterRoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * Filter, which MasterRole to fetch.
     */
    where: MasterRoleWhereUniqueInput
  }

  /**
   * MasterRole findUnique
   */
  export interface MasterRoleFindUniqueArgs extends MasterRoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterRole findUniqueOrThrow
   */
  export type MasterRoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * Filter, which MasterRole to fetch.
     */
    where: MasterRoleWhereUniqueInput
  }


  /**
   * MasterRole base type for findFirst actions
   */
  export type MasterRoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * Filter, which MasterRole to fetch.
     */
    where?: MasterRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterRoles to fetch.
     */
    orderBy?: Enumerable<MasterRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterRoles.
     */
    cursor?: MasterRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterRoles.
     */
    distinct?: Enumerable<MasterRoleScalarFieldEnum>
  }

  /**
   * MasterRole findFirst
   */
  export interface MasterRoleFindFirstArgs extends MasterRoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterRole findFirstOrThrow
   */
  export type MasterRoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * Filter, which MasterRole to fetch.
     */
    where?: MasterRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterRoles to fetch.
     */
    orderBy?: Enumerable<MasterRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterRoles.
     */
    cursor?: MasterRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterRoles.
     */
    distinct?: Enumerable<MasterRoleScalarFieldEnum>
  }


  /**
   * MasterRole findMany
   */
  export type MasterRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * Filter, which MasterRoles to fetch.
     */
    where?: MasterRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterRoles to fetch.
     */
    orderBy?: Enumerable<MasterRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterRoles.
     */
    cursor?: MasterRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterRoles.
     */
    skip?: number
    distinct?: Enumerable<MasterRoleScalarFieldEnum>
  }


  /**
   * MasterRole create
   */
  export type MasterRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * The data needed to create a MasterRole.
     */
    data: XOR<MasterRoleCreateInput, MasterRoleUncheckedCreateInput>
  }


  /**
   * MasterRole createMany
   */
  export type MasterRoleCreateManyArgs = {
    /**
     * The data used to create many MasterRoles.
     */
    data: Enumerable<MasterRoleCreateManyInput>
  }


  /**
   * MasterRole update
   */
  export type MasterRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * The data needed to update a MasterRole.
     */
    data: XOR<MasterRoleUpdateInput, MasterRoleUncheckedUpdateInput>
    /**
     * Choose, which MasterRole to update.
     */
    where: MasterRoleWhereUniqueInput
  }


  /**
   * MasterRole updateMany
   */
  export type MasterRoleUpdateManyArgs = {
    /**
     * The data used to update MasterRoles.
     */
    data: XOR<MasterRoleUpdateManyMutationInput, MasterRoleUncheckedUpdateManyInput>
    /**
     * Filter which MasterRoles to update
     */
    where?: MasterRoleWhereInput
  }


  /**
   * MasterRole upsert
   */
  export type MasterRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * The filter to search for the MasterRole to update in case it exists.
     */
    where: MasterRoleWhereUniqueInput
    /**
     * In case the MasterRole found by the `where` argument doesn't exist, create a new MasterRole with this data.
     */
    create: XOR<MasterRoleCreateInput, MasterRoleUncheckedCreateInput>
    /**
     * In case the MasterRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterRoleUpdateInput, MasterRoleUncheckedUpdateInput>
  }


  /**
   * MasterRole delete
   */
  export type MasterRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
    /**
     * Filter which MasterRole to delete.
     */
    where: MasterRoleWhereUniqueInput
  }


  /**
   * MasterRole deleteMany
   */
  export type MasterRoleDeleteManyArgs = {
    /**
     * Filter which MasterRoles to delete
     */
    where?: MasterRoleWhereInput
  }


  /**
   * MasterRole without action
   */
  export type MasterRoleArgs = {
    /**
     * Select specific fields to fetch from the MasterRole
     */
    select?: MasterRoleSelect | null
  }



  /**
   * Model MasterRoleUser
   */


  export type AggregateMasterRoleUser = {
    _count: MasterRoleUserCountAggregateOutputType | null
    _avg: MasterRoleUserAvgAggregateOutputType | null
    _sum: MasterRoleUserSumAggregateOutputType | null
    _min: MasterRoleUserMinAggregateOutputType | null
    _max: MasterRoleUserMaxAggregateOutputType | null
  }

  export type MasterRoleUserAvgAggregateOutputType = {
    id: number | null
  }

  export type MasterRoleUserSumAggregateOutputType = {
    id: number | null
  }

  export type MasterRoleUserMinAggregateOutputType = {
    id: number | null
    userId: string | null
    nameRoleUser: string | null
  }

  export type MasterRoleUserMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    nameRoleUser: string | null
  }

  export type MasterRoleUserCountAggregateOutputType = {
    id: number
    userId: number
    nameRoleUser: number
    _all: number
  }


  export type MasterRoleUserAvgAggregateInputType = {
    id?: true
  }

  export type MasterRoleUserSumAggregateInputType = {
    id?: true
  }

  export type MasterRoleUserMinAggregateInputType = {
    id?: true
    userId?: true
    nameRoleUser?: true
  }

  export type MasterRoleUserMaxAggregateInputType = {
    id?: true
    userId?: true
    nameRoleUser?: true
  }

  export type MasterRoleUserCountAggregateInputType = {
    id?: true
    userId?: true
    nameRoleUser?: true
    _all?: true
  }

  export type MasterRoleUserAggregateArgs = {
    /**
     * Filter which MasterRoleUser to aggregate.
     */
    where?: MasterRoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterRoleUsers to fetch.
     */
    orderBy?: Enumerable<MasterRoleUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterRoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterRoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterRoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterRoleUsers
    **/
    _count?: true | MasterRoleUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterRoleUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterRoleUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterRoleUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterRoleUserMaxAggregateInputType
  }

  export type GetMasterRoleUserAggregateType<T extends MasterRoleUserAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterRoleUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterRoleUser[P]>
      : GetScalarType<T[P], AggregateMasterRoleUser[P]>
  }




  export type MasterRoleUserGroupByArgs = {
    where?: MasterRoleUserWhereInput
    orderBy?: Enumerable<MasterRoleUserOrderByWithAggregationInput>
    by: MasterRoleUserScalarFieldEnum[]
    having?: MasterRoleUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterRoleUserCountAggregateInputType | true
    _avg?: MasterRoleUserAvgAggregateInputType
    _sum?: MasterRoleUserSumAggregateInputType
    _min?: MasterRoleUserMinAggregateInputType
    _max?: MasterRoleUserMaxAggregateInputType
  }


  export type MasterRoleUserGroupByOutputType = {
    id: number
    userId: string
    nameRoleUser: string
    _count: MasterRoleUserCountAggregateOutputType | null
    _avg: MasterRoleUserAvgAggregateOutputType | null
    _sum: MasterRoleUserSumAggregateOutputType | null
    _min: MasterRoleUserMinAggregateOutputType | null
    _max: MasterRoleUserMaxAggregateOutputType | null
  }

  type GetMasterRoleUserGroupByPayload<T extends MasterRoleUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MasterRoleUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterRoleUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterRoleUserGroupByOutputType[P]>
            : GetScalarType<T[P], MasterRoleUserGroupByOutputType[P]>
        }
      >
    >


  export type MasterRoleUserSelect = {
    id?: boolean
    userId?: boolean
    nameRoleUser?: boolean
  }


  export type MasterRoleUserGetPayload<S extends boolean | null | undefined | MasterRoleUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MasterRoleUser :
    S extends undefined ? never :
    S extends { include: any } & (MasterRoleUserArgs | MasterRoleUserFindManyArgs)
    ? MasterRoleUser 
    : S extends { select: any } & (MasterRoleUserArgs | MasterRoleUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MasterRoleUser ? MasterRoleUser[P] : never
  } 
      : MasterRoleUser


  type MasterRoleUserCountArgs = 
    Omit<MasterRoleUserFindManyArgs, 'select' | 'include'> & {
      select?: MasterRoleUserCountAggregateInputType | true
    }

  export interface MasterRoleUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MasterRoleUser that matches the filter.
     * @param {MasterRoleUserFindUniqueArgs} args - Arguments to find a MasterRoleUser
     * @example
     * // Get one MasterRoleUser
     * const masterRoleUser = await prisma.masterRoleUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterRoleUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MasterRoleUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MasterRoleUser'> extends True ? Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T>> : Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T> | null, null>

    /**
     * Find one MasterRoleUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterRoleUserFindUniqueOrThrowArgs} args - Arguments to find a MasterRoleUser
     * @example
     * // Get one MasterRoleUser
     * const masterRoleUser = await prisma.masterRoleUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterRoleUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MasterRoleUserFindUniqueOrThrowArgs>
    ): Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T>>

    /**
     * Find the first MasterRoleUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleUserFindFirstArgs} args - Arguments to find a MasterRoleUser
     * @example
     * // Get one MasterRoleUser
     * const masterRoleUser = await prisma.masterRoleUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterRoleUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MasterRoleUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MasterRoleUser'> extends True ? Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T>> : Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T> | null, null>

    /**
     * Find the first MasterRoleUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleUserFindFirstOrThrowArgs} args - Arguments to find a MasterRoleUser
     * @example
     * // Get one MasterRoleUser
     * const masterRoleUser = await prisma.masterRoleUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterRoleUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MasterRoleUserFindFirstOrThrowArgs>
    ): Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T>>

    /**
     * Find zero or more MasterRoleUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterRoleUsers
     * const masterRoleUsers = await prisma.masterRoleUser.findMany()
     * 
     * // Get first 10 MasterRoleUsers
     * const masterRoleUsers = await prisma.masterRoleUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterRoleUserWithIdOnly = await prisma.masterRoleUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterRoleUserFindManyArgs>(
      args?: SelectSubset<T, MasterRoleUserFindManyArgs>
    ): PrismaPromise<Array<MasterRoleUserGetPayload<T>>>

    /**
     * Create a MasterRoleUser.
     * @param {MasterRoleUserCreateArgs} args - Arguments to create a MasterRoleUser.
     * @example
     * // Create one MasterRoleUser
     * const MasterRoleUser = await prisma.masterRoleUser.create({
     *   data: {
     *     // ... data to create a MasterRoleUser
     *   }
     * })
     * 
    **/
    create<T extends MasterRoleUserCreateArgs>(
      args: SelectSubset<T, MasterRoleUserCreateArgs>
    ): Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T>>

    /**
     * Create many MasterRoleUsers.
     *     @param {MasterRoleUserCreateManyArgs} args - Arguments to create many MasterRoleUsers.
     *     @example
     *     // Create many MasterRoleUsers
     *     const masterRoleUser = await prisma.masterRoleUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterRoleUserCreateManyArgs>(
      args?: SelectSubset<T, MasterRoleUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MasterRoleUser.
     * @param {MasterRoleUserDeleteArgs} args - Arguments to delete one MasterRoleUser.
     * @example
     * // Delete one MasterRoleUser
     * const MasterRoleUser = await prisma.masterRoleUser.delete({
     *   where: {
     *     // ... filter to delete one MasterRoleUser
     *   }
     * })
     * 
    **/
    delete<T extends MasterRoleUserDeleteArgs>(
      args: SelectSubset<T, MasterRoleUserDeleteArgs>
    ): Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T>>

    /**
     * Update one MasterRoleUser.
     * @param {MasterRoleUserUpdateArgs} args - Arguments to update one MasterRoleUser.
     * @example
     * // Update one MasterRoleUser
     * const masterRoleUser = await prisma.masterRoleUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterRoleUserUpdateArgs>(
      args: SelectSubset<T, MasterRoleUserUpdateArgs>
    ): Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T>>

    /**
     * Delete zero or more MasterRoleUsers.
     * @param {MasterRoleUserDeleteManyArgs} args - Arguments to filter MasterRoleUsers to delete.
     * @example
     * // Delete a few MasterRoleUsers
     * const { count } = await prisma.masterRoleUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterRoleUserDeleteManyArgs>(
      args?: SelectSubset<T, MasterRoleUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterRoleUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterRoleUsers
     * const masterRoleUser = await prisma.masterRoleUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterRoleUserUpdateManyArgs>(
      args: SelectSubset<T, MasterRoleUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterRoleUser.
     * @param {MasterRoleUserUpsertArgs} args - Arguments to update or create a MasterRoleUser.
     * @example
     * // Update or create a MasterRoleUser
     * const masterRoleUser = await prisma.masterRoleUser.upsert({
     *   create: {
     *     // ... data to create a MasterRoleUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterRoleUser we want to update
     *   }
     * })
    **/
    upsert<T extends MasterRoleUserUpsertArgs>(
      args: SelectSubset<T, MasterRoleUserUpsertArgs>
    ): Prisma__MasterRoleUserClient<MasterRoleUserGetPayload<T>>

    /**
     * Count the number of MasterRoleUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleUserCountArgs} args - Arguments to filter MasterRoleUsers to count.
     * @example
     * // Count the number of MasterRoleUsers
     * const count = await prisma.masterRoleUser.count({
     *   where: {
     *     // ... the filter for the MasterRoleUsers we want to count
     *   }
     * })
    **/
    count<T extends MasterRoleUserCountArgs>(
      args?: Subset<T, MasterRoleUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterRoleUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterRoleUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterRoleUserAggregateArgs>(args: Subset<T, MasterRoleUserAggregateArgs>): PrismaPromise<GetMasterRoleUserAggregateType<T>>

    /**
     * Group by MasterRoleUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterRoleUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterRoleUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterRoleUserGroupByArgs['orderBy'] }
        : { orderBy?: MasterRoleUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterRoleUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterRoleUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterRoleUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MasterRoleUserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MasterRoleUser base type for findUnique actions
   */
  export type MasterRoleUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * Filter, which MasterRoleUser to fetch.
     */
    where: MasterRoleUserWhereUniqueInput
  }

  /**
   * MasterRoleUser findUnique
   */
  export interface MasterRoleUserFindUniqueArgs extends MasterRoleUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterRoleUser findUniqueOrThrow
   */
  export type MasterRoleUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * Filter, which MasterRoleUser to fetch.
     */
    where: MasterRoleUserWhereUniqueInput
  }


  /**
   * MasterRoleUser base type for findFirst actions
   */
  export type MasterRoleUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * Filter, which MasterRoleUser to fetch.
     */
    where?: MasterRoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterRoleUsers to fetch.
     */
    orderBy?: Enumerable<MasterRoleUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterRoleUsers.
     */
    cursor?: MasterRoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterRoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterRoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterRoleUsers.
     */
    distinct?: Enumerable<MasterRoleUserScalarFieldEnum>
  }

  /**
   * MasterRoleUser findFirst
   */
  export interface MasterRoleUserFindFirstArgs extends MasterRoleUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MasterRoleUser findFirstOrThrow
   */
  export type MasterRoleUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * Filter, which MasterRoleUser to fetch.
     */
    where?: MasterRoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterRoleUsers to fetch.
     */
    orderBy?: Enumerable<MasterRoleUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterRoleUsers.
     */
    cursor?: MasterRoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterRoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterRoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterRoleUsers.
     */
    distinct?: Enumerable<MasterRoleUserScalarFieldEnum>
  }


  /**
   * MasterRoleUser findMany
   */
  export type MasterRoleUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * Filter, which MasterRoleUsers to fetch.
     */
    where?: MasterRoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterRoleUsers to fetch.
     */
    orderBy?: Enumerable<MasterRoleUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterRoleUsers.
     */
    cursor?: MasterRoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterRoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterRoleUsers.
     */
    skip?: number
    distinct?: Enumerable<MasterRoleUserScalarFieldEnum>
  }


  /**
   * MasterRoleUser create
   */
  export type MasterRoleUserCreateArgs = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * The data needed to create a MasterRoleUser.
     */
    data: XOR<MasterRoleUserCreateInput, MasterRoleUserUncheckedCreateInput>
  }


  /**
   * MasterRoleUser createMany
   */
  export type MasterRoleUserCreateManyArgs = {
    /**
     * The data used to create many MasterRoleUsers.
     */
    data: Enumerable<MasterRoleUserCreateManyInput>
  }


  /**
   * MasterRoleUser update
   */
  export type MasterRoleUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * The data needed to update a MasterRoleUser.
     */
    data: XOR<MasterRoleUserUpdateInput, MasterRoleUserUncheckedUpdateInput>
    /**
     * Choose, which MasterRoleUser to update.
     */
    where: MasterRoleUserWhereUniqueInput
  }


  /**
   * MasterRoleUser updateMany
   */
  export type MasterRoleUserUpdateManyArgs = {
    /**
     * The data used to update MasterRoleUsers.
     */
    data: XOR<MasterRoleUserUpdateManyMutationInput, MasterRoleUserUncheckedUpdateManyInput>
    /**
     * Filter which MasterRoleUsers to update
     */
    where?: MasterRoleUserWhereInput
  }


  /**
   * MasterRoleUser upsert
   */
  export type MasterRoleUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * The filter to search for the MasterRoleUser to update in case it exists.
     */
    where: MasterRoleUserWhereUniqueInput
    /**
     * In case the MasterRoleUser found by the `where` argument doesn't exist, create a new MasterRoleUser with this data.
     */
    create: XOR<MasterRoleUserCreateInput, MasterRoleUserUncheckedCreateInput>
    /**
     * In case the MasterRoleUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterRoleUserUpdateInput, MasterRoleUserUncheckedUpdateInput>
  }


  /**
   * MasterRoleUser delete
   */
  export type MasterRoleUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
    /**
     * Filter which MasterRoleUser to delete.
     */
    where: MasterRoleUserWhereUniqueInput
  }


  /**
   * MasterRoleUser deleteMany
   */
  export type MasterRoleUserDeleteManyArgs = {
    /**
     * Filter which MasterRoleUsers to delete
     */
    where?: MasterRoleUserWhereInput
  }


  /**
   * MasterRoleUser without action
   */
  export type MasterRoleUserArgs = {
    /**
     * Select specific fields to fetch from the MasterRoleUser
     */
    select?: MasterRoleUserSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const MarketSurveyDetailCompScalarFieldEnum: {
    id: 'id',
    composition: 'composition',
    marketSurveyDetailId: 'marketSurveyDetailId'
  };

  export type MarketSurveyDetailCompScalarFieldEnum = (typeof MarketSurveyDetailCompScalarFieldEnum)[keyof typeof MarketSurveyDetailCompScalarFieldEnum]


  export const MarketSurveyDetailScalarFieldEnum: {
    id: 'id',
    brand: 'brand',
    unit: 'unit',
    uomId: 'uomId',
    manufacturer: 'manufacturer',
    countryOrigin: 'countryOrigin',
    priceLocal: 'priceLocal',
    priceUSD: 'priceUSD',
    sales: 'sales',
    marketSurveyId: 'marketSurveyId'
  };

  export type MarketSurveyDetailScalarFieldEnum = (typeof MarketSurveyDetailScalarFieldEnum)[keyof typeof MarketSurveyDetailScalarFieldEnum]


  export const MarketSurveyRequestScalarFieldEnum: {
    id: 'id',
    numberDocument: 'numberDocument',
    type: 'type',
    idBrand: 'idBrand',
    country: 'country',
    brand: 'brand',
    dosageForm: 'dosageForm',
    date: 'date',
    originatorBrand: 'originatorBrand',
    originatorCompany: 'originatorCompany',
    statusForm: 'statusForm',
    approvedIdUser: 'approvedIdUser',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    createdBy: 'createdBy'
  };

  export type MarketSurveyRequestScalarFieldEnum = (typeof MarketSurveyRequestScalarFieldEnum)[keyof typeof MarketSurveyRequestScalarFieldEnum]


  export const MarketSurveyScalarFieldEnum: {
    id: 'id',
    numberDocument: 'numberDocument',
    pic: 'pic',
    date: 'date',
    priceSurveyed: 'priceSurveyed',
    statusForm: 'statusForm',
    approvedIdUser: 'approvedIdUser',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    createdBy: 'createdBy'
  };

  export type MarketSurveyScalarFieldEnum = (typeof MarketSurveyScalarFieldEnum)[keyof typeof MarketSurveyScalarFieldEnum]


  export const MasterBrandScalarFieldEnum: {
    id: 'id',
    umbrellaBrandId: 'umbrellaBrandId',
    nameBrand: 'nameBrand',
    isActive: 'isActive'
  };

  export type MasterBrandScalarFieldEnum = (typeof MasterBrandScalarFieldEnum)[keyof typeof MasterBrandScalarFieldEnum]


  export const MasterCompositionScalarFieldEnum: {
    id: 'id',
    brandId: 'brandId',
    nameComposition: 'nameComposition',
    sku: 'sku',
    isActive: 'isActive'
  };

  export type MasterCompositionScalarFieldEnum = (typeof MasterCompositionScalarFieldEnum)[keyof typeof MasterCompositionScalarFieldEnum]


  export const MasterCountryScalarFieldEnum: {
    id: 'id',
    codeCountry: 'codeCountry',
    countryName: 'countryName',
    typeCountry: 'typeCountry',
    isActive: 'isActive'
  };

  export type MasterCountryScalarFieldEnum = (typeof MasterCountryScalarFieldEnum)[keyof typeof MasterCountryScalarFieldEnum]


  export const MasterDistributionPartnerScalarFieldEnum: {
    id: 'id',
    nameDist: 'nameDist',
    isActive: 'isActive'
  };

  export type MasterDistributionPartnerScalarFieldEnum = (typeof MasterDistributionPartnerScalarFieldEnum)[keyof typeof MasterDistributionPartnerScalarFieldEnum]


  export const MasterDosageScalarFieldEnum: {
    id: 'id',
    nameDossage: 'nameDossage',
    isActive: 'isActive'
  };

  export type MasterDosageScalarFieldEnum = (typeof MasterDosageScalarFieldEnum)[keyof typeof MasterDosageScalarFieldEnum]


  export const MasterRoleScalarFieldEnum: {
    id: 'id',
    roleName: 'roleName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    createdBy: 'createdBy'
  };

  export type MasterRoleScalarFieldEnum = (typeof MasterRoleScalarFieldEnum)[keyof typeof MasterRoleScalarFieldEnum]


  export const MasterRoleUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    nameRoleUser: 'nameRoleUser'
  };

  export type MasterRoleUserScalarFieldEnum = (typeof MasterRoleUserScalarFieldEnum)[keyof typeof MasterRoleUserScalarFieldEnum]


  export const MasterSpecialityScalarFieldEnum: {
    id: 'id',
    nameSpeciality: 'nameSpeciality',
    isActive: 'isActive'
  };

  export type MasterSpecialityScalarFieldEnum = (typeof MasterSpecialityScalarFieldEnum)[keyof typeof MasterSpecialityScalarFieldEnum]


  export const MasterUmbrellaBrandScalarFieldEnum: {
    id: 'id',
    nameUmbrellaBrand: 'nameUmbrellaBrand',
    isActive: 'isActive',
    masterSpecialityId: 'masterSpecialityId'
  };

  export type MasterUmbrellaBrandScalarFieldEnum = (typeof MasterUmbrellaBrandScalarFieldEnum)[keyof typeof MasterUmbrellaBrandScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type MasterCountryWhereInput = {
    AND?: Enumerable<MasterCountryWhereInput>
    OR?: Enumerable<MasterCountryWhereInput>
    NOT?: Enumerable<MasterCountryWhereInput>
    id?: IntFilter | number
    codeCountry?: StringFilter | string
    countryName?: StringFilter | string
    typeCountry?: StringFilter | string
    isActive?: IntFilter | number
  }

  export type MasterCountryOrderByWithRelationInput = {
    id?: SortOrder
    codeCountry?: SortOrder
    countryName?: SortOrder
    typeCountry?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCountryWhereUniqueInput = {
    id?: number
  }

  export type MasterCountryOrderByWithAggregationInput = {
    id?: SortOrder
    codeCountry?: SortOrder
    countryName?: SortOrder
    typeCountry?: SortOrder
    isActive?: SortOrder
    _count?: MasterCountryCountOrderByAggregateInput
    _avg?: MasterCountryAvgOrderByAggregateInput
    _max?: MasterCountryMaxOrderByAggregateInput
    _min?: MasterCountryMinOrderByAggregateInput
    _sum?: MasterCountrySumOrderByAggregateInput
  }

  export type MasterCountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterCountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterCountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterCountryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    codeCountry?: StringWithAggregatesFilter | string
    countryName?: StringWithAggregatesFilter | string
    typeCountry?: StringWithAggregatesFilter | string
    isActive?: IntWithAggregatesFilter | number
  }

  export type MasterDosageWhereInput = {
    AND?: Enumerable<MasterDosageWhereInput>
    OR?: Enumerable<MasterDosageWhereInput>
    NOT?: Enumerable<MasterDosageWhereInput>
    id?: IntFilter | number
    nameDossage?: StringFilter | string
    isActive?: IntFilter | number
  }

  export type MasterDosageOrderByWithRelationInput = {
    id?: SortOrder
    nameDossage?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDosageWhereUniqueInput = {
    id?: number
  }

  export type MasterDosageOrderByWithAggregationInput = {
    id?: SortOrder
    nameDossage?: SortOrder
    isActive?: SortOrder
    _count?: MasterDosageCountOrderByAggregateInput
    _avg?: MasterDosageAvgOrderByAggregateInput
    _max?: MasterDosageMaxOrderByAggregateInput
    _min?: MasterDosageMinOrderByAggregateInput
    _sum?: MasterDosageSumOrderByAggregateInput
  }

  export type MasterDosageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterDosageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterDosageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterDosageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nameDossage?: StringWithAggregatesFilter | string
    isActive?: IntWithAggregatesFilter | number
  }

  export type MasterSpecialityWhereInput = {
    AND?: Enumerable<MasterSpecialityWhereInput>
    OR?: Enumerable<MasterSpecialityWhereInput>
    NOT?: Enumerable<MasterSpecialityWhereInput>
    id?: IntFilter | number
    nameSpeciality?: StringFilter | string
    isActive?: IntFilter | number
    umbrellaBrand?: MasterUmbrellaBrandListRelationFilter
  }

  export type MasterSpecialityOrderByWithRelationInput = {
    id?: SortOrder
    nameSpeciality?: SortOrder
    isActive?: SortOrder
    umbrellaBrand?: MasterUmbrellaBrandOrderByRelationAggregateInput
  }

  export type MasterSpecialityWhereUniqueInput = {
    id?: number
  }

  export type MasterSpecialityOrderByWithAggregationInput = {
    id?: SortOrder
    nameSpeciality?: SortOrder
    isActive?: SortOrder
    _count?: MasterSpecialityCountOrderByAggregateInput
    _avg?: MasterSpecialityAvgOrderByAggregateInput
    _max?: MasterSpecialityMaxOrderByAggregateInput
    _min?: MasterSpecialityMinOrderByAggregateInput
    _sum?: MasterSpecialitySumOrderByAggregateInput
  }

  export type MasterSpecialityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterSpecialityScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterSpecialityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterSpecialityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nameSpeciality?: StringWithAggregatesFilter | string
    isActive?: IntWithAggregatesFilter | number
  }

  export type MasterUmbrellaBrandWhereInput = {
    AND?: Enumerable<MasterUmbrellaBrandWhereInput>
    OR?: Enumerable<MasterUmbrellaBrandWhereInput>
    NOT?: Enumerable<MasterUmbrellaBrandWhereInput>
    id?: IntFilter | number
    nameUmbrellaBrand?: StringFilter | string
    isActive?: IntFilter | number
    masterBrand?: MasterBrandListRelationFilter
    MasterSpeciality?: XOR<MasterSpecialityRelationFilter, MasterSpecialityWhereInput> | null
    masterSpecialityId?: IntNullableFilter | number | null
  }

  export type MasterUmbrellaBrandOrderByWithRelationInput = {
    id?: SortOrder
    nameUmbrellaBrand?: SortOrder
    isActive?: SortOrder
    masterBrand?: MasterBrandOrderByRelationAggregateInput
    MasterSpeciality?: MasterSpecialityOrderByWithRelationInput
    masterSpecialityId?: SortOrder
  }

  export type MasterUmbrellaBrandWhereUniqueInput = {
    id?: number
  }

  export type MasterUmbrellaBrandOrderByWithAggregationInput = {
    id?: SortOrder
    nameUmbrellaBrand?: SortOrder
    isActive?: SortOrder
    masterSpecialityId?: SortOrder
    _count?: MasterUmbrellaBrandCountOrderByAggregateInput
    _avg?: MasterUmbrellaBrandAvgOrderByAggregateInput
    _max?: MasterUmbrellaBrandMaxOrderByAggregateInput
    _min?: MasterUmbrellaBrandMinOrderByAggregateInput
    _sum?: MasterUmbrellaBrandSumOrderByAggregateInput
  }

  export type MasterUmbrellaBrandScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterUmbrellaBrandScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterUmbrellaBrandScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterUmbrellaBrandScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nameUmbrellaBrand?: StringWithAggregatesFilter | string
    isActive?: IntWithAggregatesFilter | number
    masterSpecialityId?: IntNullableWithAggregatesFilter | number | null
  }

  export type MasterBrandWhereInput = {
    AND?: Enumerable<MasterBrandWhereInput>
    OR?: Enumerable<MasterBrandWhereInput>
    NOT?: Enumerable<MasterBrandWhereInput>
    id?: IntFilter | number
    umbrellaBrand?: XOR<MasterUmbrellaBrandRelationFilter, MasterUmbrellaBrandWhereInput>
    umbrellaBrandId?: IntFilter | number
    nameBrand?: StringFilter | string
    isActive?: IntFilter | number
    MasterComposition?: MasterCompositionListRelationFilter
  }

  export type MasterBrandOrderByWithRelationInput = {
    id?: SortOrder
    umbrellaBrand?: MasterUmbrellaBrandOrderByWithRelationInput
    umbrellaBrandId?: SortOrder
    nameBrand?: SortOrder
    isActive?: SortOrder
    MasterComposition?: MasterCompositionOrderByRelationAggregateInput
  }

  export type MasterBrandWhereUniqueInput = {
    id?: number
  }

  export type MasterBrandOrderByWithAggregationInput = {
    id?: SortOrder
    umbrellaBrandId?: SortOrder
    nameBrand?: SortOrder
    isActive?: SortOrder
    _count?: MasterBrandCountOrderByAggregateInput
    _avg?: MasterBrandAvgOrderByAggregateInput
    _max?: MasterBrandMaxOrderByAggregateInput
    _min?: MasterBrandMinOrderByAggregateInput
    _sum?: MasterBrandSumOrderByAggregateInput
  }

  export type MasterBrandScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterBrandScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterBrandScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterBrandScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    umbrellaBrandId?: IntWithAggregatesFilter | number
    nameBrand?: StringWithAggregatesFilter | string
    isActive?: IntWithAggregatesFilter | number
  }

  export type MasterCompositionWhereInput = {
    AND?: Enumerable<MasterCompositionWhereInput>
    OR?: Enumerable<MasterCompositionWhereInput>
    NOT?: Enumerable<MasterCompositionWhereInput>
    id?: IntFilter | number
    brand?: XOR<MasterBrandRelationFilter, MasterBrandWhereInput>
    brandId?: IntFilter | number
    nameComposition?: StringFilter | string
    sku?: StringFilter | string
    isActive?: IntFilter | number
  }

  export type MasterCompositionOrderByWithRelationInput = {
    id?: SortOrder
    brand?: MasterBrandOrderByWithRelationInput
    brandId?: SortOrder
    nameComposition?: SortOrder
    sku?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCompositionWhereUniqueInput = {
    id?: number
  }

  export type MasterCompositionOrderByWithAggregationInput = {
    id?: SortOrder
    brandId?: SortOrder
    nameComposition?: SortOrder
    sku?: SortOrder
    isActive?: SortOrder
    _count?: MasterCompositionCountOrderByAggregateInput
    _avg?: MasterCompositionAvgOrderByAggregateInput
    _max?: MasterCompositionMaxOrderByAggregateInput
    _min?: MasterCompositionMinOrderByAggregateInput
    _sum?: MasterCompositionSumOrderByAggregateInput
  }

  export type MasterCompositionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterCompositionScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterCompositionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterCompositionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    brandId?: IntWithAggregatesFilter | number
    nameComposition?: StringWithAggregatesFilter | string
    sku?: StringWithAggregatesFilter | string
    isActive?: IntWithAggregatesFilter | number
  }

  export type MasterDistributionPartnerWhereInput = {
    AND?: Enumerable<MasterDistributionPartnerWhereInput>
    OR?: Enumerable<MasterDistributionPartnerWhereInput>
    NOT?: Enumerable<MasterDistributionPartnerWhereInput>
    id?: IntFilter | number
    nameDist?: StringFilter | string
    isActive?: IntFilter | number
  }

  export type MasterDistributionPartnerOrderByWithRelationInput = {
    id?: SortOrder
    nameDist?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDistributionPartnerWhereUniqueInput = {
    id?: number
  }

  export type MasterDistributionPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    nameDist?: SortOrder
    isActive?: SortOrder
    _count?: MasterDistributionPartnerCountOrderByAggregateInput
    _avg?: MasterDistributionPartnerAvgOrderByAggregateInput
    _max?: MasterDistributionPartnerMaxOrderByAggregateInput
    _min?: MasterDistributionPartnerMinOrderByAggregateInput
    _sum?: MasterDistributionPartnerSumOrderByAggregateInput
  }

  export type MasterDistributionPartnerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterDistributionPartnerScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterDistributionPartnerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterDistributionPartnerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nameDist?: StringWithAggregatesFilter | string
    isActive?: IntWithAggregatesFilter | number
  }

  export type MarketSurveyRequestWhereInput = {
    AND?: Enumerable<MarketSurveyRequestWhereInput>
    OR?: Enumerable<MarketSurveyRequestWhereInput>
    NOT?: Enumerable<MarketSurveyRequestWhereInput>
    id?: StringFilter | string
    numberDocument?: StringFilter | string
    type?: StringFilter | string
    idBrand?: IntFilter | number
    country?: StringFilter | string
    brand?: StringFilter | string
    dosageForm?: StringFilter | string
    date?: DateTimeFilter | Date | string
    originatorBrand?: StringFilter | string
    originatorCompany?: StringFilter | string
    statusForm?: StringFilter | string
    approvedIdUser?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    updatedBy?: StringNullableFilter | string | null
    createdBy?: StringNullableFilter | string | null
  }

  export type MarketSurveyRequestOrderByWithRelationInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    type?: SortOrder
    idBrand?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    dosageForm?: SortOrder
    date?: SortOrder
    originatorBrand?: SortOrder
    originatorCompany?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MarketSurveyRequestWhereUniqueInput = {
    id?: string
  }

  export type MarketSurveyRequestOrderByWithAggregationInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    type?: SortOrder
    idBrand?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    dosageForm?: SortOrder
    date?: SortOrder
    originatorBrand?: SortOrder
    originatorCompany?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    _count?: MarketSurveyRequestCountOrderByAggregateInput
    _avg?: MarketSurveyRequestAvgOrderByAggregateInput
    _max?: MarketSurveyRequestMaxOrderByAggregateInput
    _min?: MarketSurveyRequestMinOrderByAggregateInput
    _sum?: MarketSurveyRequestSumOrderByAggregateInput
  }

  export type MarketSurveyRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarketSurveyRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarketSurveyRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarketSurveyRequestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    numberDocument?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    idBrand?: IntWithAggregatesFilter | number
    country?: StringWithAggregatesFilter | string
    brand?: StringWithAggregatesFilter | string
    dosageForm?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    originatorBrand?: StringWithAggregatesFilter | string
    originatorCompany?: StringWithAggregatesFilter | string
    statusForm?: StringWithAggregatesFilter | string
    approvedIdUser?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    createdBy?: StringNullableWithAggregatesFilter | string | null
  }

  export type MarketSurveyWhereInput = {
    AND?: Enumerable<MarketSurveyWhereInput>
    OR?: Enumerable<MarketSurveyWhereInput>
    NOT?: Enumerable<MarketSurveyWhereInput>
    id?: StringFilter | string
    numberDocument?: StringFilter | string
    pic?: StringFilter | string
    date?: DateTimeFilter | Date | string
    priceSurveyed?: StringFilter | string
    statusForm?: StringFilter | string
    approvedIdUser?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    updatedBy?: StringNullableFilter | string | null
    createdBy?: StringNullableFilter | string | null
    marketSurveyDetail?: MarketSurveyDetailListRelationFilter
  }

  export type MarketSurveyOrderByWithRelationInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    pic?: SortOrder
    date?: SortOrder
    priceSurveyed?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    marketSurveyDetail?: MarketSurveyDetailOrderByRelationAggregateInput
  }

  export type MarketSurveyWhereUniqueInput = {
    id?: string
  }

  export type MarketSurveyOrderByWithAggregationInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    pic?: SortOrder
    date?: SortOrder
    priceSurveyed?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    _count?: MarketSurveyCountOrderByAggregateInput
    _max?: MarketSurveyMaxOrderByAggregateInput
    _min?: MarketSurveyMinOrderByAggregateInput
  }

  export type MarketSurveyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarketSurveyScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarketSurveyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarketSurveyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    numberDocument?: StringWithAggregatesFilter | string
    pic?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    priceSurveyed?: StringWithAggregatesFilter | string
    statusForm?: StringWithAggregatesFilter | string
    approvedIdUser?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    createdBy?: StringNullableWithAggregatesFilter | string | null
  }

  export type MarketSurveyDetailWhereInput = {
    AND?: Enumerable<MarketSurveyDetailWhereInput>
    OR?: Enumerable<MarketSurveyDetailWhereInput>
    NOT?: Enumerable<MarketSurveyDetailWhereInput>
    id?: StringFilter | string
    brand?: StringFilter | string
    unit?: IntFilter | number
    uomId?: StringFilter | string
    manufacturer?: StringFilter | string
    countryOrigin?: StringFilter | string
    priceLocal?: FloatFilter | number
    priceUSD?: FloatFilter | number
    sales?: StringFilter | string
    MarketSurvey?: XOR<MarketSurveyRelationFilter, MarketSurveyWhereInput> | null
    marketSurveyId?: StringNullableFilter | string | null
    marketSurveyDetailComp?: MarketSurveyDetailCompListRelationFilter
  }

  export type MarketSurveyDetailOrderByWithRelationInput = {
    id?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
    uomId?: SortOrder
    manufacturer?: SortOrder
    countryOrigin?: SortOrder
    priceLocal?: SortOrder
    priceUSD?: SortOrder
    sales?: SortOrder
    MarketSurvey?: MarketSurveyOrderByWithRelationInput
    marketSurveyId?: SortOrder
    marketSurveyDetailComp?: MarketSurveyDetailCompOrderByRelationAggregateInput
  }

  export type MarketSurveyDetailWhereUniqueInput = {
    id?: string
  }

  export type MarketSurveyDetailOrderByWithAggregationInput = {
    id?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
    uomId?: SortOrder
    manufacturer?: SortOrder
    countryOrigin?: SortOrder
    priceLocal?: SortOrder
    priceUSD?: SortOrder
    sales?: SortOrder
    marketSurveyId?: SortOrder
    _count?: MarketSurveyDetailCountOrderByAggregateInput
    _avg?: MarketSurveyDetailAvgOrderByAggregateInput
    _max?: MarketSurveyDetailMaxOrderByAggregateInput
    _min?: MarketSurveyDetailMinOrderByAggregateInput
    _sum?: MarketSurveyDetailSumOrderByAggregateInput
  }

  export type MarketSurveyDetailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarketSurveyDetailScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarketSurveyDetailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarketSurveyDetailScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    brand?: StringWithAggregatesFilter | string
    unit?: IntWithAggregatesFilter | number
    uomId?: StringWithAggregatesFilter | string
    manufacturer?: StringWithAggregatesFilter | string
    countryOrigin?: StringWithAggregatesFilter | string
    priceLocal?: FloatWithAggregatesFilter | number
    priceUSD?: FloatWithAggregatesFilter | number
    sales?: StringWithAggregatesFilter | string
    marketSurveyId?: StringNullableWithAggregatesFilter | string | null
  }

  export type MarketSurveyDetailCompWhereInput = {
    AND?: Enumerable<MarketSurveyDetailCompWhereInput>
    OR?: Enumerable<MarketSurveyDetailCompWhereInput>
    NOT?: Enumerable<MarketSurveyDetailCompWhereInput>
    id?: StringFilter | string
    composition?: StringFilter | string
    MarketSurveyDetail?: XOR<MarketSurveyDetailRelationFilter, MarketSurveyDetailWhereInput> | null
    marketSurveyDetailId?: StringNullableFilter | string | null
  }

  export type MarketSurveyDetailCompOrderByWithRelationInput = {
    id?: SortOrder
    composition?: SortOrder
    MarketSurveyDetail?: MarketSurveyDetailOrderByWithRelationInput
    marketSurveyDetailId?: SortOrder
  }

  export type MarketSurveyDetailCompWhereUniqueInput = {
    id?: string
  }

  export type MarketSurveyDetailCompOrderByWithAggregationInput = {
    id?: SortOrder
    composition?: SortOrder
    marketSurveyDetailId?: SortOrder
    _count?: MarketSurveyDetailCompCountOrderByAggregateInput
    _max?: MarketSurveyDetailCompMaxOrderByAggregateInput
    _min?: MarketSurveyDetailCompMinOrderByAggregateInput
  }

  export type MarketSurveyDetailCompScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarketSurveyDetailCompScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarketSurveyDetailCompScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarketSurveyDetailCompScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    composition?: StringWithAggregatesFilter | string
    marketSurveyDetailId?: StringNullableWithAggregatesFilter | string | null
  }

  export type MasterRoleWhereInput = {
    AND?: Enumerable<MasterRoleWhereInput>
    OR?: Enumerable<MasterRoleWhereInput>
    NOT?: Enumerable<MasterRoleWhereInput>
    id?: IntFilter | number
    roleName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    updatedBy?: StringNullableFilter | string | null
    createdBy?: StringNullableFilter | string | null
  }

  export type MasterRoleOrderByWithRelationInput = {
    id?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MasterRoleWhereUniqueInput = {
    id?: number
  }

  export type MasterRoleOrderByWithAggregationInput = {
    id?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    _count?: MasterRoleCountOrderByAggregateInput
    _avg?: MasterRoleAvgOrderByAggregateInput
    _max?: MasterRoleMaxOrderByAggregateInput
    _min?: MasterRoleMinOrderByAggregateInput
    _sum?: MasterRoleSumOrderByAggregateInput
  }

  export type MasterRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterRoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    roleName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    createdBy?: StringNullableWithAggregatesFilter | string | null
  }

  export type MasterRoleUserWhereInput = {
    AND?: Enumerable<MasterRoleUserWhereInput>
    OR?: Enumerable<MasterRoleUserWhereInput>
    NOT?: Enumerable<MasterRoleUserWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    nameRoleUser?: StringFilter | string
  }

  export type MasterRoleUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    nameRoleUser?: SortOrder
  }

  export type MasterRoleUserWhereUniqueInput = {
    id?: number
  }

  export type MasterRoleUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    nameRoleUser?: SortOrder
    _count?: MasterRoleUserCountOrderByAggregateInput
    _avg?: MasterRoleUserAvgOrderByAggregateInput
    _max?: MasterRoleUserMaxOrderByAggregateInput
    _min?: MasterRoleUserMinOrderByAggregateInput
    _sum?: MasterRoleUserSumOrderByAggregateInput
  }

  export type MasterRoleUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MasterRoleUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<MasterRoleUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MasterRoleUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    nameRoleUser?: StringWithAggregatesFilter | string
  }

  export type MasterCountryCreateInput = {
    codeCountry: string
    countryName: string
    typeCountry: string
    isActive?: number
  }

  export type MasterCountryUncheckedCreateInput = {
    id?: number
    codeCountry: string
    countryName: string
    typeCountry: string
    isActive?: number
  }

  export type MasterCountryUpdateInput = {
    codeCountry?: StringFieldUpdateOperationsInput | string
    countryName?: StringFieldUpdateOperationsInput | string
    typeCountry?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeCountry?: StringFieldUpdateOperationsInput | string
    countryName?: StringFieldUpdateOperationsInput | string
    typeCountry?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCountryCreateManyInput = {
    codeCountry: string
    countryName: string
    typeCountry: string
    isActive?: number
  }

  export type MasterCountryUpdateManyMutationInput = {
    codeCountry?: StringFieldUpdateOperationsInput | string
    countryName?: StringFieldUpdateOperationsInput | string
    typeCountry?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeCountry?: StringFieldUpdateOperationsInput | string
    countryName?: StringFieldUpdateOperationsInput | string
    typeCountry?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterDosageCreateInput = {
    nameDossage: string
    isActive?: number
  }

  export type MasterDosageUncheckedCreateInput = {
    id?: number
    nameDossage: string
    isActive?: number
  }

  export type MasterDosageUpdateInput = {
    nameDossage?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterDosageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameDossage?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterDosageCreateManyInput = {
    nameDossage: string
    isActive?: number
  }

  export type MasterDosageUpdateManyMutationInput = {
    nameDossage?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterDosageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameDossage?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterSpecialityCreateInput = {
    nameSpeciality: string
    isActive?: number
    umbrellaBrand?: MasterUmbrellaBrandCreateNestedManyWithoutMasterSpecialityInput
  }

  export type MasterSpecialityUncheckedCreateInput = {
    id?: number
    nameSpeciality: string
    isActive?: number
    umbrellaBrand?: MasterUmbrellaBrandUncheckedCreateNestedManyWithoutMasterSpecialityInput
  }

  export type MasterSpecialityUpdateInput = {
    nameSpeciality?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    umbrellaBrand?: MasterUmbrellaBrandUpdateManyWithoutMasterSpecialityNestedInput
  }

  export type MasterSpecialityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameSpeciality?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    umbrellaBrand?: MasterUmbrellaBrandUncheckedUpdateManyWithoutMasterSpecialityNestedInput
  }

  export type MasterSpecialityCreateManyInput = {
    nameSpeciality: string
    isActive?: number
  }

  export type MasterSpecialityUpdateManyMutationInput = {
    nameSpeciality?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterSpecialityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameSpeciality?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterUmbrellaBrandCreateInput = {
    nameUmbrellaBrand: string
    isActive?: number
    masterBrand?: MasterBrandCreateNestedManyWithoutUmbrellaBrandInput
    MasterSpeciality?: MasterSpecialityCreateNestedOneWithoutUmbrellaBrandInput
  }

  export type MasterUmbrellaBrandUncheckedCreateInput = {
    id?: number
    nameUmbrellaBrand: string
    isActive?: number
    masterBrand?: MasterBrandUncheckedCreateNestedManyWithoutUmbrellaBrandInput
    masterSpecialityId?: number | null
  }

  export type MasterUmbrellaBrandUpdateInput = {
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    masterBrand?: MasterBrandUpdateManyWithoutUmbrellaBrandNestedInput
    MasterSpeciality?: MasterSpecialityUpdateOneWithoutUmbrellaBrandNestedInput
  }

  export type MasterUmbrellaBrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    masterBrand?: MasterBrandUncheckedUpdateManyWithoutUmbrellaBrandNestedInput
    masterSpecialityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MasterUmbrellaBrandCreateManyInput = {
    nameUmbrellaBrand: string
    isActive?: number
    masterSpecialityId?: number | null
  }

  export type MasterUmbrellaBrandUpdateManyMutationInput = {
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterUmbrellaBrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    masterSpecialityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MasterBrandCreateInput = {
    umbrellaBrand: MasterUmbrellaBrandCreateNestedOneWithoutMasterBrandInput
    nameBrand: string
    isActive?: number
    MasterComposition?: MasterCompositionCreateNestedManyWithoutBrandInput
  }

  export type MasterBrandUncheckedCreateInput = {
    id?: number
    umbrellaBrandId: number
    nameBrand: string
    isActive?: number
    MasterComposition?: MasterCompositionUncheckedCreateNestedManyWithoutBrandInput
  }

  export type MasterBrandUpdateInput = {
    umbrellaBrand?: MasterUmbrellaBrandUpdateOneRequiredWithoutMasterBrandNestedInput
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    MasterComposition?: MasterCompositionUpdateManyWithoutBrandNestedInput
  }

  export type MasterBrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    umbrellaBrandId?: IntFieldUpdateOperationsInput | number
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    MasterComposition?: MasterCompositionUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type MasterBrandCreateManyInput = {
    umbrellaBrandId: number
    nameBrand: string
    isActive?: number
  }

  export type MasterBrandUpdateManyMutationInput = {
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterBrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    umbrellaBrandId?: IntFieldUpdateOperationsInput | number
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCompositionCreateInput = {
    brand: MasterBrandCreateNestedOneWithoutMasterCompositionInput
    nameComposition: string
    sku: string
    isActive?: number
  }

  export type MasterCompositionUncheckedCreateInput = {
    id?: number
    brandId: number
    nameComposition: string
    sku: string
    isActive?: number
  }

  export type MasterCompositionUpdateInput = {
    brand?: MasterBrandUpdateOneRequiredWithoutMasterCompositionNestedInput
    nameComposition?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCompositionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    nameComposition?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCompositionCreateManyInput = {
    brandId: number
    nameComposition: string
    sku: string
    isActive?: number
  }

  export type MasterCompositionUpdateManyMutationInput = {
    nameComposition?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCompositionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    nameComposition?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterDistributionPartnerCreateInput = {
    nameDist: string
    isActive?: number
  }

  export type MasterDistributionPartnerUncheckedCreateInput = {
    id?: number
    nameDist: string
    isActive?: number
  }

  export type MasterDistributionPartnerUpdateInput = {
    nameDist?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterDistributionPartnerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameDist?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterDistributionPartnerCreateManyInput = {
    nameDist: string
    isActive?: number
  }

  export type MasterDistributionPartnerUpdateManyMutationInput = {
    nameDist?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterDistributionPartnerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameDist?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MarketSurveyRequestCreateInput = {
    id?: string
    numberDocument: string
    type: string
    idBrand: number
    country: string
    brand: string
    dosageForm: string
    date?: Date | string
    originatorBrand: string
    originatorCompany: string
    statusForm: string
    approvedIdUser: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MarketSurveyRequestUncheckedCreateInput = {
    id?: string
    numberDocument: string
    type: string
    idBrand: number
    country: string
    brand: string
    dosageForm: string
    date?: Date | string
    originatorBrand: string
    originatorCompany: string
    statusForm: string
    approvedIdUser: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MarketSurveyRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    idBrand?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    dosageForm?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originatorBrand?: StringFieldUpdateOperationsInput | string
    originatorCompany?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    idBrand?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    dosageForm?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originatorBrand?: StringFieldUpdateOperationsInput | string
    originatorCompany?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyRequestCreateManyInput = {
    id?: string
    numberDocument: string
    type: string
    idBrand: number
    country: string
    brand: string
    dosageForm: string
    date?: Date | string
    originatorBrand: string
    originatorCompany: string
    statusForm: string
    approvedIdUser: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MarketSurveyRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    idBrand?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    dosageForm?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originatorBrand?: StringFieldUpdateOperationsInput | string
    originatorCompany?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    idBrand?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    dosageForm?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    originatorBrand?: StringFieldUpdateOperationsInput | string
    originatorCompany?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyCreateInput = {
    id?: string
    numberDocument: string
    pic: string
    date?: Date | string
    priceSurveyed: string
    statusForm: string
    approvedIdUser: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    marketSurveyDetail?: MarketSurveyDetailCreateNestedManyWithoutMarketSurveyInput
  }

  export type MarketSurveyUncheckedCreateInput = {
    id?: string
    numberDocument: string
    pic: string
    date?: Date | string
    priceSurveyed: string
    statusForm: string
    approvedIdUser: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    marketSurveyDetail?: MarketSurveyDetailUncheckedCreateNestedManyWithoutMarketSurveyInput
  }

  export type MarketSurveyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    pic?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    priceSurveyed?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    marketSurveyDetail?: MarketSurveyDetailUpdateManyWithoutMarketSurveyNestedInput
  }

  export type MarketSurveyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    pic?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    priceSurveyed?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    marketSurveyDetail?: MarketSurveyDetailUncheckedUpdateManyWithoutMarketSurveyNestedInput
  }

  export type MarketSurveyCreateManyInput = {
    id?: string
    numberDocument: string
    pic: string
    date?: Date | string
    priceSurveyed: string
    statusForm: string
    approvedIdUser: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MarketSurveyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    pic?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    priceSurveyed?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    pic?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    priceSurveyed?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyDetailCreateInput = {
    id?: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
    MarketSurvey?: MarketSurveyCreateNestedOneWithoutMarketSurveyDetailInput
    marketSurveyDetailComp?: MarketSurveyDetailCompCreateNestedManyWithoutMarketSurveyDetailInput
  }

  export type MarketSurveyDetailUncheckedCreateInput = {
    id?: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
    marketSurveyId?: string | null
    marketSurveyDetailComp?: MarketSurveyDetailCompUncheckedCreateNestedManyWithoutMarketSurveyDetailInput
  }

  export type MarketSurveyDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
    MarketSurvey?: MarketSurveyUpdateOneWithoutMarketSurveyDetailNestedInput
    marketSurveyDetailComp?: MarketSurveyDetailCompUpdateManyWithoutMarketSurveyDetailNestedInput
  }

  export type MarketSurveyDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
    marketSurveyId?: NullableStringFieldUpdateOperationsInput | string | null
    marketSurveyDetailComp?: MarketSurveyDetailCompUncheckedUpdateManyWithoutMarketSurveyDetailNestedInput
  }

  export type MarketSurveyDetailCreateManyInput = {
    id?: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
    marketSurveyId?: string | null
  }

  export type MarketSurveyDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
  }

  export type MarketSurveyDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
    marketSurveyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyDetailCompCreateInput = {
    id?: string
    composition: string
    MarketSurveyDetail?: MarketSurveyDetailCreateNestedOneWithoutMarketSurveyDetailCompInput
  }

  export type MarketSurveyDetailCompUncheckedCreateInput = {
    id?: string
    composition: string
    marketSurveyDetailId?: string | null
  }

  export type MarketSurveyDetailCompUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    composition?: StringFieldUpdateOperationsInput | string
    MarketSurveyDetail?: MarketSurveyDetailUpdateOneWithoutMarketSurveyDetailCompNestedInput
  }

  export type MarketSurveyDetailCompUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    composition?: StringFieldUpdateOperationsInput | string
    marketSurveyDetailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyDetailCompCreateManyInput = {
    id?: string
    composition: string
    marketSurveyDetailId?: string | null
  }

  export type MarketSurveyDetailCompUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    composition?: StringFieldUpdateOperationsInput | string
  }

  export type MarketSurveyDetailCompUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    composition?: StringFieldUpdateOperationsInput | string
    marketSurveyDetailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterRoleCreateInput = {
    roleName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MasterRoleUncheckedCreateInput = {
    id?: number
    roleName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MasterRoleUpdateInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterRoleCreateManyInput = {
    roleName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MasterRoleUpdateManyMutationInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterRoleUserCreateInput = {
    userId: string
    nameRoleUser: string
  }

  export type MasterRoleUserUncheckedCreateInput = {
    id?: number
    userId: string
    nameRoleUser: string
  }

  export type MasterRoleUserUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    nameRoleUser?: StringFieldUpdateOperationsInput | string
  }

  export type MasterRoleUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    nameRoleUser?: StringFieldUpdateOperationsInput | string
  }

  export type MasterRoleUserCreateManyInput = {
    userId: string
    nameRoleUser: string
  }

  export type MasterRoleUserUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    nameRoleUser?: StringFieldUpdateOperationsInput | string
  }

  export type MasterRoleUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    nameRoleUser?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type MasterCountryCountOrderByAggregateInput = {
    id?: SortOrder
    codeCountry?: SortOrder
    countryName?: SortOrder
    typeCountry?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCountryAvgOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCountryMaxOrderByAggregateInput = {
    id?: SortOrder
    codeCountry?: SortOrder
    countryName?: SortOrder
    typeCountry?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCountryMinOrderByAggregateInput = {
    id?: SortOrder
    codeCountry?: SortOrder
    countryName?: SortOrder
    typeCountry?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCountrySumOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type MasterDosageCountOrderByAggregateInput = {
    id?: SortOrder
    nameDossage?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDosageAvgOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDosageMaxOrderByAggregateInput = {
    id?: SortOrder
    nameDossage?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDosageMinOrderByAggregateInput = {
    id?: SortOrder
    nameDossage?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDosageSumOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
  }

  export type MasterUmbrellaBrandListRelationFilter = {
    every?: MasterUmbrellaBrandWhereInput
    some?: MasterUmbrellaBrandWhereInput
    none?: MasterUmbrellaBrandWhereInput
  }

  export type MasterUmbrellaBrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterSpecialityCountOrderByAggregateInput = {
    id?: SortOrder
    nameSpeciality?: SortOrder
    isActive?: SortOrder
  }

  export type MasterSpecialityAvgOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
  }

  export type MasterSpecialityMaxOrderByAggregateInput = {
    id?: SortOrder
    nameSpeciality?: SortOrder
    isActive?: SortOrder
  }

  export type MasterSpecialityMinOrderByAggregateInput = {
    id?: SortOrder
    nameSpeciality?: SortOrder
    isActive?: SortOrder
  }

  export type MasterSpecialitySumOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
  }

  export type MasterBrandListRelationFilter = {
    every?: MasterBrandWhereInput
    some?: MasterBrandWhereInput
    none?: MasterBrandWhereInput
  }

  export type MasterSpecialityRelationFilter = {
    is?: MasterSpecialityWhereInput | null
    isNot?: MasterSpecialityWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type MasterBrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterUmbrellaBrandCountOrderByAggregateInput = {
    id?: SortOrder
    nameUmbrellaBrand?: SortOrder
    isActive?: SortOrder
    masterSpecialityId?: SortOrder
  }

  export type MasterUmbrellaBrandAvgOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    masterSpecialityId?: SortOrder
  }

  export type MasterUmbrellaBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    nameUmbrellaBrand?: SortOrder
    isActive?: SortOrder
    masterSpecialityId?: SortOrder
  }

  export type MasterUmbrellaBrandMinOrderByAggregateInput = {
    id?: SortOrder
    nameUmbrellaBrand?: SortOrder
    isActive?: SortOrder
    masterSpecialityId?: SortOrder
  }

  export type MasterUmbrellaBrandSumOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    masterSpecialityId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type MasterUmbrellaBrandRelationFilter = {
    is?: MasterUmbrellaBrandWhereInput
    isNot?: MasterUmbrellaBrandWhereInput
  }

  export type MasterCompositionListRelationFilter = {
    every?: MasterCompositionWhereInput
    some?: MasterCompositionWhereInput
    none?: MasterCompositionWhereInput
  }

  export type MasterCompositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterBrandCountOrderByAggregateInput = {
    id?: SortOrder
    umbrellaBrandId?: SortOrder
    nameBrand?: SortOrder
    isActive?: SortOrder
  }

  export type MasterBrandAvgOrderByAggregateInput = {
    id?: SortOrder
    umbrellaBrandId?: SortOrder
    isActive?: SortOrder
  }

  export type MasterBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    umbrellaBrandId?: SortOrder
    nameBrand?: SortOrder
    isActive?: SortOrder
  }

  export type MasterBrandMinOrderByAggregateInput = {
    id?: SortOrder
    umbrellaBrandId?: SortOrder
    nameBrand?: SortOrder
    isActive?: SortOrder
  }

  export type MasterBrandSumOrderByAggregateInput = {
    id?: SortOrder
    umbrellaBrandId?: SortOrder
    isActive?: SortOrder
  }

  export type MasterBrandRelationFilter = {
    is?: MasterBrandWhereInput
    isNot?: MasterBrandWhereInput
  }

  export type MasterCompositionCountOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    nameComposition?: SortOrder
    sku?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCompositionAvgOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCompositionMaxOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    nameComposition?: SortOrder
    sku?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCompositionMinOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    nameComposition?: SortOrder
    sku?: SortOrder
    isActive?: SortOrder
  }

  export type MasterCompositionSumOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDistributionPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    nameDist?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDistributionPartnerAvgOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDistributionPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    nameDist?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDistributionPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    nameDist?: SortOrder
    isActive?: SortOrder
  }

  export type MasterDistributionPartnerSumOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type MarketSurveyRequestCountOrderByAggregateInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    type?: SortOrder
    idBrand?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    dosageForm?: SortOrder
    date?: SortOrder
    originatorBrand?: SortOrder
    originatorCompany?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MarketSurveyRequestAvgOrderByAggregateInput = {
    idBrand?: SortOrder
  }

  export type MarketSurveyRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    type?: SortOrder
    idBrand?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    dosageForm?: SortOrder
    date?: SortOrder
    originatorBrand?: SortOrder
    originatorCompany?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MarketSurveyRequestMinOrderByAggregateInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    type?: SortOrder
    idBrand?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    dosageForm?: SortOrder
    date?: SortOrder
    originatorBrand?: SortOrder
    originatorCompany?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MarketSurveyRequestSumOrderByAggregateInput = {
    idBrand?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type MarketSurveyDetailListRelationFilter = {
    every?: MarketSurveyDetailWhereInput
    some?: MarketSurveyDetailWhereInput
    none?: MarketSurveyDetailWhereInput
  }

  export type MarketSurveyDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketSurveyCountOrderByAggregateInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    pic?: SortOrder
    date?: SortOrder
    priceSurveyed?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MarketSurveyMaxOrderByAggregateInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    pic?: SortOrder
    date?: SortOrder
    priceSurveyed?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MarketSurveyMinOrderByAggregateInput = {
    id?: SortOrder
    numberDocument?: SortOrder
    pic?: SortOrder
    date?: SortOrder
    priceSurveyed?: SortOrder
    statusForm?: SortOrder
    approvedIdUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type MarketSurveyRelationFilter = {
    is?: MarketSurveyWhereInput | null
    isNot?: MarketSurveyWhereInput | null
  }

  export type MarketSurveyDetailCompListRelationFilter = {
    every?: MarketSurveyDetailCompWhereInput
    some?: MarketSurveyDetailCompWhereInput
    none?: MarketSurveyDetailCompWhereInput
  }

  export type MarketSurveyDetailCompOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketSurveyDetailCountOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
    uomId?: SortOrder
    manufacturer?: SortOrder
    countryOrigin?: SortOrder
    priceLocal?: SortOrder
    priceUSD?: SortOrder
    sales?: SortOrder
    marketSurveyId?: SortOrder
  }

  export type MarketSurveyDetailAvgOrderByAggregateInput = {
    unit?: SortOrder
    priceLocal?: SortOrder
    priceUSD?: SortOrder
  }

  export type MarketSurveyDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
    uomId?: SortOrder
    manufacturer?: SortOrder
    countryOrigin?: SortOrder
    priceLocal?: SortOrder
    priceUSD?: SortOrder
    sales?: SortOrder
    marketSurveyId?: SortOrder
  }

  export type MarketSurveyDetailMinOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
    uomId?: SortOrder
    manufacturer?: SortOrder
    countryOrigin?: SortOrder
    priceLocal?: SortOrder
    priceUSD?: SortOrder
    sales?: SortOrder
    marketSurveyId?: SortOrder
  }

  export type MarketSurveyDetailSumOrderByAggregateInput = {
    unit?: SortOrder
    priceLocal?: SortOrder
    priceUSD?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type MarketSurveyDetailRelationFilter = {
    is?: MarketSurveyDetailWhereInput | null
    isNot?: MarketSurveyDetailWhereInput | null
  }

  export type MarketSurveyDetailCompCountOrderByAggregateInput = {
    id?: SortOrder
    composition?: SortOrder
    marketSurveyDetailId?: SortOrder
  }

  export type MarketSurveyDetailCompMaxOrderByAggregateInput = {
    id?: SortOrder
    composition?: SortOrder
    marketSurveyDetailId?: SortOrder
  }

  export type MarketSurveyDetailCompMinOrderByAggregateInput = {
    id?: SortOrder
    composition?: SortOrder
    marketSurveyDetailId?: SortOrder
  }

  export type MasterRoleCountOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MasterRoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MasterRoleMinOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type MasterRoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterRoleUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nameRoleUser?: SortOrder
  }

  export type MasterRoleUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterRoleUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nameRoleUser?: SortOrder
  }

  export type MasterRoleUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nameRoleUser?: SortOrder
  }

  export type MasterRoleUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MasterUmbrellaBrandCreateNestedManyWithoutMasterSpecialityInput = {
    create?: XOR<Enumerable<MasterUmbrellaBrandCreateWithoutMasterSpecialityInput>, Enumerable<MasterUmbrellaBrandUncheckedCreateWithoutMasterSpecialityInput>>
    connectOrCreate?: Enumerable<MasterUmbrellaBrandCreateOrConnectWithoutMasterSpecialityInput>
    createMany?: MasterUmbrellaBrandCreateManyMasterSpecialityInputEnvelope
    connect?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
  }

  export type MasterUmbrellaBrandUncheckedCreateNestedManyWithoutMasterSpecialityInput = {
    create?: XOR<Enumerable<MasterUmbrellaBrandCreateWithoutMasterSpecialityInput>, Enumerable<MasterUmbrellaBrandUncheckedCreateWithoutMasterSpecialityInput>>
    connectOrCreate?: Enumerable<MasterUmbrellaBrandCreateOrConnectWithoutMasterSpecialityInput>
    createMany?: MasterUmbrellaBrandCreateManyMasterSpecialityInputEnvelope
    connect?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
  }

  export type MasterUmbrellaBrandUpdateManyWithoutMasterSpecialityNestedInput = {
    create?: XOR<Enumerable<MasterUmbrellaBrandCreateWithoutMasterSpecialityInput>, Enumerable<MasterUmbrellaBrandUncheckedCreateWithoutMasterSpecialityInput>>
    connectOrCreate?: Enumerable<MasterUmbrellaBrandCreateOrConnectWithoutMasterSpecialityInput>
    upsert?: Enumerable<MasterUmbrellaBrandUpsertWithWhereUniqueWithoutMasterSpecialityInput>
    createMany?: MasterUmbrellaBrandCreateManyMasterSpecialityInputEnvelope
    set?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
    disconnect?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
    delete?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
    connect?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
    update?: Enumerable<MasterUmbrellaBrandUpdateWithWhereUniqueWithoutMasterSpecialityInput>
    updateMany?: Enumerable<MasterUmbrellaBrandUpdateManyWithWhereWithoutMasterSpecialityInput>
    deleteMany?: Enumerable<MasterUmbrellaBrandScalarWhereInput>
  }

  export type MasterUmbrellaBrandUncheckedUpdateManyWithoutMasterSpecialityNestedInput = {
    create?: XOR<Enumerable<MasterUmbrellaBrandCreateWithoutMasterSpecialityInput>, Enumerable<MasterUmbrellaBrandUncheckedCreateWithoutMasterSpecialityInput>>
    connectOrCreate?: Enumerable<MasterUmbrellaBrandCreateOrConnectWithoutMasterSpecialityInput>
    upsert?: Enumerable<MasterUmbrellaBrandUpsertWithWhereUniqueWithoutMasterSpecialityInput>
    createMany?: MasterUmbrellaBrandCreateManyMasterSpecialityInputEnvelope
    set?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
    disconnect?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
    delete?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
    connect?: Enumerable<MasterUmbrellaBrandWhereUniqueInput>
    update?: Enumerable<MasterUmbrellaBrandUpdateWithWhereUniqueWithoutMasterSpecialityInput>
    updateMany?: Enumerable<MasterUmbrellaBrandUpdateManyWithWhereWithoutMasterSpecialityInput>
    deleteMany?: Enumerable<MasterUmbrellaBrandScalarWhereInput>
  }

  export type MasterBrandCreateNestedManyWithoutUmbrellaBrandInput = {
    create?: XOR<Enumerable<MasterBrandCreateWithoutUmbrellaBrandInput>, Enumerable<MasterBrandUncheckedCreateWithoutUmbrellaBrandInput>>
    connectOrCreate?: Enumerable<MasterBrandCreateOrConnectWithoutUmbrellaBrandInput>
    createMany?: MasterBrandCreateManyUmbrellaBrandInputEnvelope
    connect?: Enumerable<MasterBrandWhereUniqueInput>
  }

  export type MasterSpecialityCreateNestedOneWithoutUmbrellaBrandInput = {
    create?: XOR<MasterSpecialityCreateWithoutUmbrellaBrandInput, MasterSpecialityUncheckedCreateWithoutUmbrellaBrandInput>
    connectOrCreate?: MasterSpecialityCreateOrConnectWithoutUmbrellaBrandInput
    connect?: MasterSpecialityWhereUniqueInput
  }

  export type MasterBrandUncheckedCreateNestedManyWithoutUmbrellaBrandInput = {
    create?: XOR<Enumerable<MasterBrandCreateWithoutUmbrellaBrandInput>, Enumerable<MasterBrandUncheckedCreateWithoutUmbrellaBrandInput>>
    connectOrCreate?: Enumerable<MasterBrandCreateOrConnectWithoutUmbrellaBrandInput>
    createMany?: MasterBrandCreateManyUmbrellaBrandInputEnvelope
    connect?: Enumerable<MasterBrandWhereUniqueInput>
  }

  export type MasterBrandUpdateManyWithoutUmbrellaBrandNestedInput = {
    create?: XOR<Enumerable<MasterBrandCreateWithoutUmbrellaBrandInput>, Enumerable<MasterBrandUncheckedCreateWithoutUmbrellaBrandInput>>
    connectOrCreate?: Enumerable<MasterBrandCreateOrConnectWithoutUmbrellaBrandInput>
    upsert?: Enumerable<MasterBrandUpsertWithWhereUniqueWithoutUmbrellaBrandInput>
    createMany?: MasterBrandCreateManyUmbrellaBrandInputEnvelope
    set?: Enumerable<MasterBrandWhereUniqueInput>
    disconnect?: Enumerable<MasterBrandWhereUniqueInput>
    delete?: Enumerable<MasterBrandWhereUniqueInput>
    connect?: Enumerable<MasterBrandWhereUniqueInput>
    update?: Enumerable<MasterBrandUpdateWithWhereUniqueWithoutUmbrellaBrandInput>
    updateMany?: Enumerable<MasterBrandUpdateManyWithWhereWithoutUmbrellaBrandInput>
    deleteMany?: Enumerable<MasterBrandScalarWhereInput>
  }

  export type MasterSpecialityUpdateOneWithoutUmbrellaBrandNestedInput = {
    create?: XOR<MasterSpecialityCreateWithoutUmbrellaBrandInput, MasterSpecialityUncheckedCreateWithoutUmbrellaBrandInput>
    connectOrCreate?: MasterSpecialityCreateOrConnectWithoutUmbrellaBrandInput
    upsert?: MasterSpecialityUpsertWithoutUmbrellaBrandInput
    disconnect?: boolean
    delete?: boolean
    connect?: MasterSpecialityWhereUniqueInput
    update?: XOR<MasterSpecialityUpdateWithoutUmbrellaBrandInput, MasterSpecialityUncheckedUpdateWithoutUmbrellaBrandInput>
  }

  export type MasterBrandUncheckedUpdateManyWithoutUmbrellaBrandNestedInput = {
    create?: XOR<Enumerable<MasterBrandCreateWithoutUmbrellaBrandInput>, Enumerable<MasterBrandUncheckedCreateWithoutUmbrellaBrandInput>>
    connectOrCreate?: Enumerable<MasterBrandCreateOrConnectWithoutUmbrellaBrandInput>
    upsert?: Enumerable<MasterBrandUpsertWithWhereUniqueWithoutUmbrellaBrandInput>
    createMany?: MasterBrandCreateManyUmbrellaBrandInputEnvelope
    set?: Enumerable<MasterBrandWhereUniqueInput>
    disconnect?: Enumerable<MasterBrandWhereUniqueInput>
    delete?: Enumerable<MasterBrandWhereUniqueInput>
    connect?: Enumerable<MasterBrandWhereUniqueInput>
    update?: Enumerable<MasterBrandUpdateWithWhereUniqueWithoutUmbrellaBrandInput>
    updateMany?: Enumerable<MasterBrandUpdateManyWithWhereWithoutUmbrellaBrandInput>
    deleteMany?: Enumerable<MasterBrandScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MasterUmbrellaBrandCreateNestedOneWithoutMasterBrandInput = {
    create?: XOR<MasterUmbrellaBrandCreateWithoutMasterBrandInput, MasterUmbrellaBrandUncheckedCreateWithoutMasterBrandInput>
    connectOrCreate?: MasterUmbrellaBrandCreateOrConnectWithoutMasterBrandInput
    connect?: MasterUmbrellaBrandWhereUniqueInput
  }

  export type MasterCompositionCreateNestedManyWithoutBrandInput = {
    create?: XOR<Enumerable<MasterCompositionCreateWithoutBrandInput>, Enumerable<MasterCompositionUncheckedCreateWithoutBrandInput>>
    connectOrCreate?: Enumerable<MasterCompositionCreateOrConnectWithoutBrandInput>
    createMany?: MasterCompositionCreateManyBrandInputEnvelope
    connect?: Enumerable<MasterCompositionWhereUniqueInput>
  }

  export type MasterCompositionUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<Enumerable<MasterCompositionCreateWithoutBrandInput>, Enumerable<MasterCompositionUncheckedCreateWithoutBrandInput>>
    connectOrCreate?: Enumerable<MasterCompositionCreateOrConnectWithoutBrandInput>
    createMany?: MasterCompositionCreateManyBrandInputEnvelope
    connect?: Enumerable<MasterCompositionWhereUniqueInput>
  }

  export type MasterUmbrellaBrandUpdateOneRequiredWithoutMasterBrandNestedInput = {
    create?: XOR<MasterUmbrellaBrandCreateWithoutMasterBrandInput, MasterUmbrellaBrandUncheckedCreateWithoutMasterBrandInput>
    connectOrCreate?: MasterUmbrellaBrandCreateOrConnectWithoutMasterBrandInput
    upsert?: MasterUmbrellaBrandUpsertWithoutMasterBrandInput
    connect?: MasterUmbrellaBrandWhereUniqueInput
    update?: XOR<MasterUmbrellaBrandUpdateWithoutMasterBrandInput, MasterUmbrellaBrandUncheckedUpdateWithoutMasterBrandInput>
  }

  export type MasterCompositionUpdateManyWithoutBrandNestedInput = {
    create?: XOR<Enumerable<MasterCompositionCreateWithoutBrandInput>, Enumerable<MasterCompositionUncheckedCreateWithoutBrandInput>>
    connectOrCreate?: Enumerable<MasterCompositionCreateOrConnectWithoutBrandInput>
    upsert?: Enumerable<MasterCompositionUpsertWithWhereUniqueWithoutBrandInput>
    createMany?: MasterCompositionCreateManyBrandInputEnvelope
    set?: Enumerable<MasterCompositionWhereUniqueInput>
    disconnect?: Enumerable<MasterCompositionWhereUniqueInput>
    delete?: Enumerable<MasterCompositionWhereUniqueInput>
    connect?: Enumerable<MasterCompositionWhereUniqueInput>
    update?: Enumerable<MasterCompositionUpdateWithWhereUniqueWithoutBrandInput>
    updateMany?: Enumerable<MasterCompositionUpdateManyWithWhereWithoutBrandInput>
    deleteMany?: Enumerable<MasterCompositionScalarWhereInput>
  }

  export type MasterCompositionUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<Enumerable<MasterCompositionCreateWithoutBrandInput>, Enumerable<MasterCompositionUncheckedCreateWithoutBrandInput>>
    connectOrCreate?: Enumerable<MasterCompositionCreateOrConnectWithoutBrandInput>
    upsert?: Enumerable<MasterCompositionUpsertWithWhereUniqueWithoutBrandInput>
    createMany?: MasterCompositionCreateManyBrandInputEnvelope
    set?: Enumerable<MasterCompositionWhereUniqueInput>
    disconnect?: Enumerable<MasterCompositionWhereUniqueInput>
    delete?: Enumerable<MasterCompositionWhereUniqueInput>
    connect?: Enumerable<MasterCompositionWhereUniqueInput>
    update?: Enumerable<MasterCompositionUpdateWithWhereUniqueWithoutBrandInput>
    updateMany?: Enumerable<MasterCompositionUpdateManyWithWhereWithoutBrandInput>
    deleteMany?: Enumerable<MasterCompositionScalarWhereInput>
  }

  export type MasterBrandCreateNestedOneWithoutMasterCompositionInput = {
    create?: XOR<MasterBrandCreateWithoutMasterCompositionInput, MasterBrandUncheckedCreateWithoutMasterCompositionInput>
    connectOrCreate?: MasterBrandCreateOrConnectWithoutMasterCompositionInput
    connect?: MasterBrandWhereUniqueInput
  }

  export type MasterBrandUpdateOneRequiredWithoutMasterCompositionNestedInput = {
    create?: XOR<MasterBrandCreateWithoutMasterCompositionInput, MasterBrandUncheckedCreateWithoutMasterCompositionInput>
    connectOrCreate?: MasterBrandCreateOrConnectWithoutMasterCompositionInput
    upsert?: MasterBrandUpsertWithoutMasterCompositionInput
    connect?: MasterBrandWhereUniqueInput
    update?: XOR<MasterBrandUpdateWithoutMasterCompositionInput, MasterBrandUncheckedUpdateWithoutMasterCompositionInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type MarketSurveyDetailCreateNestedManyWithoutMarketSurveyInput = {
    create?: XOR<Enumerable<MarketSurveyDetailCreateWithoutMarketSurveyInput>, Enumerable<MarketSurveyDetailUncheckedCreateWithoutMarketSurveyInput>>
    connectOrCreate?: Enumerable<MarketSurveyDetailCreateOrConnectWithoutMarketSurveyInput>
    createMany?: MarketSurveyDetailCreateManyMarketSurveyInputEnvelope
    connect?: Enumerable<MarketSurveyDetailWhereUniqueInput>
  }

  export type MarketSurveyDetailUncheckedCreateNestedManyWithoutMarketSurveyInput = {
    create?: XOR<Enumerable<MarketSurveyDetailCreateWithoutMarketSurveyInput>, Enumerable<MarketSurveyDetailUncheckedCreateWithoutMarketSurveyInput>>
    connectOrCreate?: Enumerable<MarketSurveyDetailCreateOrConnectWithoutMarketSurveyInput>
    createMany?: MarketSurveyDetailCreateManyMarketSurveyInputEnvelope
    connect?: Enumerable<MarketSurveyDetailWhereUniqueInput>
  }

  export type MarketSurveyDetailUpdateManyWithoutMarketSurveyNestedInput = {
    create?: XOR<Enumerable<MarketSurveyDetailCreateWithoutMarketSurveyInput>, Enumerable<MarketSurveyDetailUncheckedCreateWithoutMarketSurveyInput>>
    connectOrCreate?: Enumerable<MarketSurveyDetailCreateOrConnectWithoutMarketSurveyInput>
    upsert?: Enumerable<MarketSurveyDetailUpsertWithWhereUniqueWithoutMarketSurveyInput>
    createMany?: MarketSurveyDetailCreateManyMarketSurveyInputEnvelope
    set?: Enumerable<MarketSurveyDetailWhereUniqueInput>
    disconnect?: Enumerable<MarketSurveyDetailWhereUniqueInput>
    delete?: Enumerable<MarketSurveyDetailWhereUniqueInput>
    connect?: Enumerable<MarketSurveyDetailWhereUniqueInput>
    update?: Enumerable<MarketSurveyDetailUpdateWithWhereUniqueWithoutMarketSurveyInput>
    updateMany?: Enumerable<MarketSurveyDetailUpdateManyWithWhereWithoutMarketSurveyInput>
    deleteMany?: Enumerable<MarketSurveyDetailScalarWhereInput>
  }

  export type MarketSurveyDetailUncheckedUpdateManyWithoutMarketSurveyNestedInput = {
    create?: XOR<Enumerable<MarketSurveyDetailCreateWithoutMarketSurveyInput>, Enumerable<MarketSurveyDetailUncheckedCreateWithoutMarketSurveyInput>>
    connectOrCreate?: Enumerable<MarketSurveyDetailCreateOrConnectWithoutMarketSurveyInput>
    upsert?: Enumerable<MarketSurveyDetailUpsertWithWhereUniqueWithoutMarketSurveyInput>
    createMany?: MarketSurveyDetailCreateManyMarketSurveyInputEnvelope
    set?: Enumerable<MarketSurveyDetailWhereUniqueInput>
    disconnect?: Enumerable<MarketSurveyDetailWhereUniqueInput>
    delete?: Enumerable<MarketSurveyDetailWhereUniqueInput>
    connect?: Enumerable<MarketSurveyDetailWhereUniqueInput>
    update?: Enumerable<MarketSurveyDetailUpdateWithWhereUniqueWithoutMarketSurveyInput>
    updateMany?: Enumerable<MarketSurveyDetailUpdateManyWithWhereWithoutMarketSurveyInput>
    deleteMany?: Enumerable<MarketSurveyDetailScalarWhereInput>
  }

  export type MarketSurveyCreateNestedOneWithoutMarketSurveyDetailInput = {
    create?: XOR<MarketSurveyCreateWithoutMarketSurveyDetailInput, MarketSurveyUncheckedCreateWithoutMarketSurveyDetailInput>
    connectOrCreate?: MarketSurveyCreateOrConnectWithoutMarketSurveyDetailInput
    connect?: MarketSurveyWhereUniqueInput
  }

  export type MarketSurveyDetailCompCreateNestedManyWithoutMarketSurveyDetailInput = {
    create?: XOR<Enumerable<MarketSurveyDetailCompCreateWithoutMarketSurveyDetailInput>, Enumerable<MarketSurveyDetailCompUncheckedCreateWithoutMarketSurveyDetailInput>>
    connectOrCreate?: Enumerable<MarketSurveyDetailCompCreateOrConnectWithoutMarketSurveyDetailInput>
    createMany?: MarketSurveyDetailCompCreateManyMarketSurveyDetailInputEnvelope
    connect?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
  }

  export type MarketSurveyDetailCompUncheckedCreateNestedManyWithoutMarketSurveyDetailInput = {
    create?: XOR<Enumerable<MarketSurveyDetailCompCreateWithoutMarketSurveyDetailInput>, Enumerable<MarketSurveyDetailCompUncheckedCreateWithoutMarketSurveyDetailInput>>
    connectOrCreate?: Enumerable<MarketSurveyDetailCompCreateOrConnectWithoutMarketSurveyDetailInput>
    createMany?: MarketSurveyDetailCompCreateManyMarketSurveyDetailInputEnvelope
    connect?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MarketSurveyUpdateOneWithoutMarketSurveyDetailNestedInput = {
    create?: XOR<MarketSurveyCreateWithoutMarketSurveyDetailInput, MarketSurveyUncheckedCreateWithoutMarketSurveyDetailInput>
    connectOrCreate?: MarketSurveyCreateOrConnectWithoutMarketSurveyDetailInput
    upsert?: MarketSurveyUpsertWithoutMarketSurveyDetailInput
    disconnect?: boolean
    delete?: boolean
    connect?: MarketSurveyWhereUniqueInput
    update?: XOR<MarketSurveyUpdateWithoutMarketSurveyDetailInput, MarketSurveyUncheckedUpdateWithoutMarketSurveyDetailInput>
  }

  export type MarketSurveyDetailCompUpdateManyWithoutMarketSurveyDetailNestedInput = {
    create?: XOR<Enumerable<MarketSurveyDetailCompCreateWithoutMarketSurveyDetailInput>, Enumerable<MarketSurveyDetailCompUncheckedCreateWithoutMarketSurveyDetailInput>>
    connectOrCreate?: Enumerable<MarketSurveyDetailCompCreateOrConnectWithoutMarketSurveyDetailInput>
    upsert?: Enumerable<MarketSurveyDetailCompUpsertWithWhereUniqueWithoutMarketSurveyDetailInput>
    createMany?: MarketSurveyDetailCompCreateManyMarketSurveyDetailInputEnvelope
    set?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
    disconnect?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
    delete?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
    connect?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
    update?: Enumerable<MarketSurveyDetailCompUpdateWithWhereUniqueWithoutMarketSurveyDetailInput>
    updateMany?: Enumerable<MarketSurveyDetailCompUpdateManyWithWhereWithoutMarketSurveyDetailInput>
    deleteMany?: Enumerable<MarketSurveyDetailCompScalarWhereInput>
  }

  export type MarketSurveyDetailCompUncheckedUpdateManyWithoutMarketSurveyDetailNestedInput = {
    create?: XOR<Enumerable<MarketSurveyDetailCompCreateWithoutMarketSurveyDetailInput>, Enumerable<MarketSurveyDetailCompUncheckedCreateWithoutMarketSurveyDetailInput>>
    connectOrCreate?: Enumerable<MarketSurveyDetailCompCreateOrConnectWithoutMarketSurveyDetailInput>
    upsert?: Enumerable<MarketSurveyDetailCompUpsertWithWhereUniqueWithoutMarketSurveyDetailInput>
    createMany?: MarketSurveyDetailCompCreateManyMarketSurveyDetailInputEnvelope
    set?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
    disconnect?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
    delete?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
    connect?: Enumerable<MarketSurveyDetailCompWhereUniqueInput>
    update?: Enumerable<MarketSurveyDetailCompUpdateWithWhereUniqueWithoutMarketSurveyDetailInput>
    updateMany?: Enumerable<MarketSurveyDetailCompUpdateManyWithWhereWithoutMarketSurveyDetailInput>
    deleteMany?: Enumerable<MarketSurveyDetailCompScalarWhereInput>
  }

  export type MarketSurveyDetailCreateNestedOneWithoutMarketSurveyDetailCompInput = {
    create?: XOR<MarketSurveyDetailCreateWithoutMarketSurveyDetailCompInput, MarketSurveyDetailUncheckedCreateWithoutMarketSurveyDetailCompInput>
    connectOrCreate?: MarketSurveyDetailCreateOrConnectWithoutMarketSurveyDetailCompInput
    connect?: MarketSurveyDetailWhereUniqueInput
  }

  export type MarketSurveyDetailUpdateOneWithoutMarketSurveyDetailCompNestedInput = {
    create?: XOR<MarketSurveyDetailCreateWithoutMarketSurveyDetailCompInput, MarketSurveyDetailUncheckedCreateWithoutMarketSurveyDetailCompInput>
    connectOrCreate?: MarketSurveyDetailCreateOrConnectWithoutMarketSurveyDetailCompInput
    upsert?: MarketSurveyDetailUpsertWithoutMarketSurveyDetailCompInput
    disconnect?: boolean
    delete?: boolean
    connect?: MarketSurveyDetailWhereUniqueInput
    update?: XOR<MarketSurveyDetailUpdateWithoutMarketSurveyDetailCompInput, MarketSurveyDetailUncheckedUpdateWithoutMarketSurveyDetailCompInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type MasterUmbrellaBrandCreateWithoutMasterSpecialityInput = {
    nameUmbrellaBrand: string
    isActive?: number
    masterBrand?: MasterBrandCreateNestedManyWithoutUmbrellaBrandInput
  }

  export type MasterUmbrellaBrandUncheckedCreateWithoutMasterSpecialityInput = {
    id?: number
    nameUmbrellaBrand: string
    isActive?: number
    masterBrand?: MasterBrandUncheckedCreateNestedManyWithoutUmbrellaBrandInput
  }

  export type MasterUmbrellaBrandCreateOrConnectWithoutMasterSpecialityInput = {
    where: MasterUmbrellaBrandWhereUniqueInput
    create: XOR<MasterUmbrellaBrandCreateWithoutMasterSpecialityInput, MasterUmbrellaBrandUncheckedCreateWithoutMasterSpecialityInput>
  }

  export type MasterUmbrellaBrandCreateManyMasterSpecialityInputEnvelope = {
    data: Enumerable<MasterUmbrellaBrandCreateManyMasterSpecialityInput>
  }

  export type MasterUmbrellaBrandUpsertWithWhereUniqueWithoutMasterSpecialityInput = {
    where: MasterUmbrellaBrandWhereUniqueInput
    update: XOR<MasterUmbrellaBrandUpdateWithoutMasterSpecialityInput, MasterUmbrellaBrandUncheckedUpdateWithoutMasterSpecialityInput>
    create: XOR<MasterUmbrellaBrandCreateWithoutMasterSpecialityInput, MasterUmbrellaBrandUncheckedCreateWithoutMasterSpecialityInput>
  }

  export type MasterUmbrellaBrandUpdateWithWhereUniqueWithoutMasterSpecialityInput = {
    where: MasterUmbrellaBrandWhereUniqueInput
    data: XOR<MasterUmbrellaBrandUpdateWithoutMasterSpecialityInput, MasterUmbrellaBrandUncheckedUpdateWithoutMasterSpecialityInput>
  }

  export type MasterUmbrellaBrandUpdateManyWithWhereWithoutMasterSpecialityInput = {
    where: MasterUmbrellaBrandScalarWhereInput
    data: XOR<MasterUmbrellaBrandUpdateManyMutationInput, MasterUmbrellaBrandUncheckedUpdateManyWithoutUmbrellaBrandInput>
  }

  export type MasterUmbrellaBrandScalarWhereInput = {
    AND?: Enumerable<MasterUmbrellaBrandScalarWhereInput>
    OR?: Enumerable<MasterUmbrellaBrandScalarWhereInput>
    NOT?: Enumerable<MasterUmbrellaBrandScalarWhereInput>
    id?: IntFilter | number
    nameUmbrellaBrand?: StringFilter | string
    isActive?: IntFilter | number
    masterSpecialityId?: IntNullableFilter | number | null
  }

  export type MasterBrandCreateWithoutUmbrellaBrandInput = {
    nameBrand: string
    isActive?: number
    MasterComposition?: MasterCompositionCreateNestedManyWithoutBrandInput
  }

  export type MasterBrandUncheckedCreateWithoutUmbrellaBrandInput = {
    id?: number
    nameBrand: string
    isActive?: number
    MasterComposition?: MasterCompositionUncheckedCreateNestedManyWithoutBrandInput
  }

  export type MasterBrandCreateOrConnectWithoutUmbrellaBrandInput = {
    where: MasterBrandWhereUniqueInput
    create: XOR<MasterBrandCreateWithoutUmbrellaBrandInput, MasterBrandUncheckedCreateWithoutUmbrellaBrandInput>
  }

  export type MasterBrandCreateManyUmbrellaBrandInputEnvelope = {
    data: Enumerable<MasterBrandCreateManyUmbrellaBrandInput>
  }

  export type MasterSpecialityCreateWithoutUmbrellaBrandInput = {
    nameSpeciality: string
    isActive?: number
  }

  export type MasterSpecialityUncheckedCreateWithoutUmbrellaBrandInput = {
    id?: number
    nameSpeciality: string
    isActive?: number
  }

  export type MasterSpecialityCreateOrConnectWithoutUmbrellaBrandInput = {
    where: MasterSpecialityWhereUniqueInput
    create: XOR<MasterSpecialityCreateWithoutUmbrellaBrandInput, MasterSpecialityUncheckedCreateWithoutUmbrellaBrandInput>
  }

  export type MasterBrandUpsertWithWhereUniqueWithoutUmbrellaBrandInput = {
    where: MasterBrandWhereUniqueInput
    update: XOR<MasterBrandUpdateWithoutUmbrellaBrandInput, MasterBrandUncheckedUpdateWithoutUmbrellaBrandInput>
    create: XOR<MasterBrandCreateWithoutUmbrellaBrandInput, MasterBrandUncheckedCreateWithoutUmbrellaBrandInput>
  }

  export type MasterBrandUpdateWithWhereUniqueWithoutUmbrellaBrandInput = {
    where: MasterBrandWhereUniqueInput
    data: XOR<MasterBrandUpdateWithoutUmbrellaBrandInput, MasterBrandUncheckedUpdateWithoutUmbrellaBrandInput>
  }

  export type MasterBrandUpdateManyWithWhereWithoutUmbrellaBrandInput = {
    where: MasterBrandScalarWhereInput
    data: XOR<MasterBrandUpdateManyMutationInput, MasterBrandUncheckedUpdateManyWithoutMasterBrandInput>
  }

  export type MasterBrandScalarWhereInput = {
    AND?: Enumerable<MasterBrandScalarWhereInput>
    OR?: Enumerable<MasterBrandScalarWhereInput>
    NOT?: Enumerable<MasterBrandScalarWhereInput>
    id?: IntFilter | number
    umbrellaBrandId?: IntFilter | number
    nameBrand?: StringFilter | string
    isActive?: IntFilter | number
  }

  export type MasterSpecialityUpsertWithoutUmbrellaBrandInput = {
    update: XOR<MasterSpecialityUpdateWithoutUmbrellaBrandInput, MasterSpecialityUncheckedUpdateWithoutUmbrellaBrandInput>
    create: XOR<MasterSpecialityCreateWithoutUmbrellaBrandInput, MasterSpecialityUncheckedCreateWithoutUmbrellaBrandInput>
  }

  export type MasterSpecialityUpdateWithoutUmbrellaBrandInput = {
    nameSpeciality?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterSpecialityUncheckedUpdateWithoutUmbrellaBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameSpeciality?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterUmbrellaBrandCreateWithoutMasterBrandInput = {
    nameUmbrellaBrand: string
    isActive?: number
    MasterSpeciality?: MasterSpecialityCreateNestedOneWithoutUmbrellaBrandInput
  }

  export type MasterUmbrellaBrandUncheckedCreateWithoutMasterBrandInput = {
    id?: number
    nameUmbrellaBrand: string
    isActive?: number
    masterSpecialityId?: number | null
  }

  export type MasterUmbrellaBrandCreateOrConnectWithoutMasterBrandInput = {
    where: MasterUmbrellaBrandWhereUniqueInput
    create: XOR<MasterUmbrellaBrandCreateWithoutMasterBrandInput, MasterUmbrellaBrandUncheckedCreateWithoutMasterBrandInput>
  }

  export type MasterCompositionCreateWithoutBrandInput = {
    nameComposition: string
    sku: string
    isActive?: number
  }

  export type MasterCompositionUncheckedCreateWithoutBrandInput = {
    id?: number
    nameComposition: string
    sku: string
    isActive?: number
  }

  export type MasterCompositionCreateOrConnectWithoutBrandInput = {
    where: MasterCompositionWhereUniqueInput
    create: XOR<MasterCompositionCreateWithoutBrandInput, MasterCompositionUncheckedCreateWithoutBrandInput>
  }

  export type MasterCompositionCreateManyBrandInputEnvelope = {
    data: Enumerable<MasterCompositionCreateManyBrandInput>
  }

  export type MasterUmbrellaBrandUpsertWithoutMasterBrandInput = {
    update: XOR<MasterUmbrellaBrandUpdateWithoutMasterBrandInput, MasterUmbrellaBrandUncheckedUpdateWithoutMasterBrandInput>
    create: XOR<MasterUmbrellaBrandCreateWithoutMasterBrandInput, MasterUmbrellaBrandUncheckedCreateWithoutMasterBrandInput>
  }

  export type MasterUmbrellaBrandUpdateWithoutMasterBrandInput = {
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    MasterSpeciality?: MasterSpecialityUpdateOneWithoutUmbrellaBrandNestedInput
  }

  export type MasterUmbrellaBrandUncheckedUpdateWithoutMasterBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    masterSpecialityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MasterCompositionUpsertWithWhereUniqueWithoutBrandInput = {
    where: MasterCompositionWhereUniqueInput
    update: XOR<MasterCompositionUpdateWithoutBrandInput, MasterCompositionUncheckedUpdateWithoutBrandInput>
    create: XOR<MasterCompositionCreateWithoutBrandInput, MasterCompositionUncheckedCreateWithoutBrandInput>
  }

  export type MasterCompositionUpdateWithWhereUniqueWithoutBrandInput = {
    where: MasterCompositionWhereUniqueInput
    data: XOR<MasterCompositionUpdateWithoutBrandInput, MasterCompositionUncheckedUpdateWithoutBrandInput>
  }

  export type MasterCompositionUpdateManyWithWhereWithoutBrandInput = {
    where: MasterCompositionScalarWhereInput
    data: XOR<MasterCompositionUpdateManyMutationInput, MasterCompositionUncheckedUpdateManyWithoutMasterCompositionInput>
  }

  export type MasterCompositionScalarWhereInput = {
    AND?: Enumerable<MasterCompositionScalarWhereInput>
    OR?: Enumerable<MasterCompositionScalarWhereInput>
    NOT?: Enumerable<MasterCompositionScalarWhereInput>
    id?: IntFilter | number
    brandId?: IntFilter | number
    nameComposition?: StringFilter | string
    sku?: StringFilter | string
    isActive?: IntFilter | number
  }

  export type MasterBrandCreateWithoutMasterCompositionInput = {
    umbrellaBrand: MasterUmbrellaBrandCreateNestedOneWithoutMasterBrandInput
    nameBrand: string
    isActive?: number
  }

  export type MasterBrandUncheckedCreateWithoutMasterCompositionInput = {
    id?: number
    umbrellaBrandId: number
    nameBrand: string
    isActive?: number
  }

  export type MasterBrandCreateOrConnectWithoutMasterCompositionInput = {
    where: MasterBrandWhereUniqueInput
    create: XOR<MasterBrandCreateWithoutMasterCompositionInput, MasterBrandUncheckedCreateWithoutMasterCompositionInput>
  }

  export type MasterBrandUpsertWithoutMasterCompositionInput = {
    update: XOR<MasterBrandUpdateWithoutMasterCompositionInput, MasterBrandUncheckedUpdateWithoutMasterCompositionInput>
    create: XOR<MasterBrandCreateWithoutMasterCompositionInput, MasterBrandUncheckedCreateWithoutMasterCompositionInput>
  }

  export type MasterBrandUpdateWithoutMasterCompositionInput = {
    umbrellaBrand?: MasterUmbrellaBrandUpdateOneRequiredWithoutMasterBrandNestedInput
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterBrandUncheckedUpdateWithoutMasterCompositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    umbrellaBrandId?: IntFieldUpdateOperationsInput | number
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MarketSurveyDetailCreateWithoutMarketSurveyInput = {
    id?: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
    marketSurveyDetailComp?: MarketSurveyDetailCompCreateNestedManyWithoutMarketSurveyDetailInput
  }

  export type MarketSurveyDetailUncheckedCreateWithoutMarketSurveyInput = {
    id?: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
    marketSurveyDetailComp?: MarketSurveyDetailCompUncheckedCreateNestedManyWithoutMarketSurveyDetailInput
  }

  export type MarketSurveyDetailCreateOrConnectWithoutMarketSurveyInput = {
    where: MarketSurveyDetailWhereUniqueInput
    create: XOR<MarketSurveyDetailCreateWithoutMarketSurveyInput, MarketSurveyDetailUncheckedCreateWithoutMarketSurveyInput>
  }

  export type MarketSurveyDetailCreateManyMarketSurveyInputEnvelope = {
    data: Enumerable<MarketSurveyDetailCreateManyMarketSurveyInput>
  }

  export type MarketSurveyDetailUpsertWithWhereUniqueWithoutMarketSurveyInput = {
    where: MarketSurveyDetailWhereUniqueInput
    update: XOR<MarketSurveyDetailUpdateWithoutMarketSurveyInput, MarketSurveyDetailUncheckedUpdateWithoutMarketSurveyInput>
    create: XOR<MarketSurveyDetailCreateWithoutMarketSurveyInput, MarketSurveyDetailUncheckedCreateWithoutMarketSurveyInput>
  }

  export type MarketSurveyDetailUpdateWithWhereUniqueWithoutMarketSurveyInput = {
    where: MarketSurveyDetailWhereUniqueInput
    data: XOR<MarketSurveyDetailUpdateWithoutMarketSurveyInput, MarketSurveyDetailUncheckedUpdateWithoutMarketSurveyInput>
  }

  export type MarketSurveyDetailUpdateManyWithWhereWithoutMarketSurveyInput = {
    where: MarketSurveyDetailScalarWhereInput
    data: XOR<MarketSurveyDetailUpdateManyMutationInput, MarketSurveyDetailUncheckedUpdateManyWithoutMarketSurveyDetailInput>
  }

  export type MarketSurveyDetailScalarWhereInput = {
    AND?: Enumerable<MarketSurveyDetailScalarWhereInput>
    OR?: Enumerable<MarketSurveyDetailScalarWhereInput>
    NOT?: Enumerable<MarketSurveyDetailScalarWhereInput>
    id?: StringFilter | string
    brand?: StringFilter | string
    unit?: IntFilter | number
    uomId?: StringFilter | string
    manufacturer?: StringFilter | string
    countryOrigin?: StringFilter | string
    priceLocal?: FloatFilter | number
    priceUSD?: FloatFilter | number
    sales?: StringFilter | string
    marketSurveyId?: StringNullableFilter | string | null
  }

  export type MarketSurveyCreateWithoutMarketSurveyDetailInput = {
    id?: string
    numberDocument: string
    pic: string
    date?: Date | string
    priceSurveyed: string
    statusForm: string
    approvedIdUser: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MarketSurveyUncheckedCreateWithoutMarketSurveyDetailInput = {
    id?: string
    numberDocument: string
    pic: string
    date?: Date | string
    priceSurveyed: string
    statusForm: string
    approvedIdUser: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
  }

  export type MarketSurveyCreateOrConnectWithoutMarketSurveyDetailInput = {
    where: MarketSurveyWhereUniqueInput
    create: XOR<MarketSurveyCreateWithoutMarketSurveyDetailInput, MarketSurveyUncheckedCreateWithoutMarketSurveyDetailInput>
  }

  export type MarketSurveyDetailCompCreateWithoutMarketSurveyDetailInput = {
    id?: string
    composition: string
  }

  export type MarketSurveyDetailCompUncheckedCreateWithoutMarketSurveyDetailInput = {
    id?: string
    composition: string
  }

  export type MarketSurveyDetailCompCreateOrConnectWithoutMarketSurveyDetailInput = {
    where: MarketSurveyDetailCompWhereUniqueInput
    create: XOR<MarketSurveyDetailCompCreateWithoutMarketSurveyDetailInput, MarketSurveyDetailCompUncheckedCreateWithoutMarketSurveyDetailInput>
  }

  export type MarketSurveyDetailCompCreateManyMarketSurveyDetailInputEnvelope = {
    data: Enumerable<MarketSurveyDetailCompCreateManyMarketSurveyDetailInput>
  }

  export type MarketSurveyUpsertWithoutMarketSurveyDetailInput = {
    update: XOR<MarketSurveyUpdateWithoutMarketSurveyDetailInput, MarketSurveyUncheckedUpdateWithoutMarketSurveyDetailInput>
    create: XOR<MarketSurveyCreateWithoutMarketSurveyDetailInput, MarketSurveyUncheckedCreateWithoutMarketSurveyDetailInput>
  }

  export type MarketSurveyUpdateWithoutMarketSurveyDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    pic?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    priceSurveyed?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyUncheckedUpdateWithoutMarketSurveyDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberDocument?: StringFieldUpdateOperationsInput | string
    pic?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    priceSurveyed?: StringFieldUpdateOperationsInput | string
    statusForm?: StringFieldUpdateOperationsInput | string
    approvedIdUser?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketSurveyDetailCompUpsertWithWhereUniqueWithoutMarketSurveyDetailInput = {
    where: MarketSurveyDetailCompWhereUniqueInput
    update: XOR<MarketSurveyDetailCompUpdateWithoutMarketSurveyDetailInput, MarketSurveyDetailCompUncheckedUpdateWithoutMarketSurveyDetailInput>
    create: XOR<MarketSurveyDetailCompCreateWithoutMarketSurveyDetailInput, MarketSurveyDetailCompUncheckedCreateWithoutMarketSurveyDetailInput>
  }

  export type MarketSurveyDetailCompUpdateWithWhereUniqueWithoutMarketSurveyDetailInput = {
    where: MarketSurveyDetailCompWhereUniqueInput
    data: XOR<MarketSurveyDetailCompUpdateWithoutMarketSurveyDetailInput, MarketSurveyDetailCompUncheckedUpdateWithoutMarketSurveyDetailInput>
  }

  export type MarketSurveyDetailCompUpdateManyWithWhereWithoutMarketSurveyDetailInput = {
    where: MarketSurveyDetailCompScalarWhereInput
    data: XOR<MarketSurveyDetailCompUpdateManyMutationInput, MarketSurveyDetailCompUncheckedUpdateManyWithoutMarketSurveyDetailCompInput>
  }

  export type MarketSurveyDetailCompScalarWhereInput = {
    AND?: Enumerable<MarketSurveyDetailCompScalarWhereInput>
    OR?: Enumerable<MarketSurveyDetailCompScalarWhereInput>
    NOT?: Enumerable<MarketSurveyDetailCompScalarWhereInput>
    id?: StringFilter | string
    composition?: StringFilter | string
    marketSurveyDetailId?: StringNullableFilter | string | null
  }

  export type MarketSurveyDetailCreateWithoutMarketSurveyDetailCompInput = {
    id?: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
    MarketSurvey?: MarketSurveyCreateNestedOneWithoutMarketSurveyDetailInput
  }

  export type MarketSurveyDetailUncheckedCreateWithoutMarketSurveyDetailCompInput = {
    id?: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
    marketSurveyId?: string | null
  }

  export type MarketSurveyDetailCreateOrConnectWithoutMarketSurveyDetailCompInput = {
    where: MarketSurveyDetailWhereUniqueInput
    create: XOR<MarketSurveyDetailCreateWithoutMarketSurveyDetailCompInput, MarketSurveyDetailUncheckedCreateWithoutMarketSurveyDetailCompInput>
  }

  export type MarketSurveyDetailUpsertWithoutMarketSurveyDetailCompInput = {
    update: XOR<MarketSurveyDetailUpdateWithoutMarketSurveyDetailCompInput, MarketSurveyDetailUncheckedUpdateWithoutMarketSurveyDetailCompInput>
    create: XOR<MarketSurveyDetailCreateWithoutMarketSurveyDetailCompInput, MarketSurveyDetailUncheckedCreateWithoutMarketSurveyDetailCompInput>
  }

  export type MarketSurveyDetailUpdateWithoutMarketSurveyDetailCompInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
    MarketSurvey?: MarketSurveyUpdateOneWithoutMarketSurveyDetailNestedInput
  }

  export type MarketSurveyDetailUncheckedUpdateWithoutMarketSurveyDetailCompInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
    marketSurveyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterUmbrellaBrandCreateManyMasterSpecialityInput = {
    nameUmbrellaBrand: string
    isActive?: number
  }

  export type MasterUmbrellaBrandUpdateWithoutMasterSpecialityInput = {
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    masterBrand?: MasterBrandUpdateManyWithoutUmbrellaBrandNestedInput
  }

  export type MasterUmbrellaBrandUncheckedUpdateWithoutMasterSpecialityInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    masterBrand?: MasterBrandUncheckedUpdateManyWithoutUmbrellaBrandNestedInput
  }

  export type MasterUmbrellaBrandUncheckedUpdateManyWithoutUmbrellaBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameUmbrellaBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterBrandCreateManyUmbrellaBrandInput = {
    nameBrand: string
    isActive?: number
  }

  export type MasterBrandUpdateWithoutUmbrellaBrandInput = {
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    MasterComposition?: MasterCompositionUpdateManyWithoutBrandNestedInput
  }

  export type MasterBrandUncheckedUpdateWithoutUmbrellaBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
    MasterComposition?: MasterCompositionUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type MasterBrandUncheckedUpdateManyWithoutMasterBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameBrand?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCompositionCreateManyBrandInput = {
    nameComposition: string
    sku: string
    isActive?: number
  }

  export type MasterCompositionUpdateWithoutBrandInput = {
    nameComposition?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCompositionUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameComposition?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MasterCompositionUncheckedUpdateManyWithoutMasterCompositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameComposition?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    isActive?: IntFieldUpdateOperationsInput | number
  }

  export type MarketSurveyDetailCreateManyMarketSurveyInput = {
    id?: string
    brand: string
    unit: number
    uomId: string
    manufacturer: string
    countryOrigin: string
    priceLocal: number
    priceUSD: number
    sales: string
  }

  export type MarketSurveyDetailUpdateWithoutMarketSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
    marketSurveyDetailComp?: MarketSurveyDetailCompUpdateManyWithoutMarketSurveyDetailNestedInput
  }

  export type MarketSurveyDetailUncheckedUpdateWithoutMarketSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
    marketSurveyDetailComp?: MarketSurveyDetailCompUncheckedUpdateManyWithoutMarketSurveyDetailNestedInput
  }

  export type MarketSurveyDetailUncheckedUpdateManyWithoutMarketSurveyDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    unit?: IntFieldUpdateOperationsInput | number
    uomId?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    countryOrigin?: StringFieldUpdateOperationsInput | string
    priceLocal?: FloatFieldUpdateOperationsInput | number
    priceUSD?: FloatFieldUpdateOperationsInput | number
    sales?: StringFieldUpdateOperationsInput | string
  }

  export type MarketSurveyDetailCompCreateManyMarketSurveyDetailInput = {
    id?: string
    composition: string
  }

  export type MarketSurveyDetailCompUpdateWithoutMarketSurveyDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    composition?: StringFieldUpdateOperationsInput | string
  }

  export type MarketSurveyDetailCompUncheckedUpdateWithoutMarketSurveyDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    composition?: StringFieldUpdateOperationsInput | string
  }

  export type MarketSurveyDetailCompUncheckedUpdateManyWithoutMarketSurveyDetailCompInput = {
    id?: StringFieldUpdateOperationsInput | string
    composition?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}